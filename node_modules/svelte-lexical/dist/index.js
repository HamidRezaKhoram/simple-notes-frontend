(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Lexical = {}));
})(this, (function (exports) { 'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    // Adapted from https://github.com/then/is-promise/blob/master/index.js
    // Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE
    function is_promise(value) {
        return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function append_styles(target, style_sheet_id, styles) {
        const append_styles_to = get_root_for_style(target);
        if (!append_styles_to.getElementById(style_sheet_id)) {
            const style = element('style');
            style.id = style_sheet_id;
            style.textContent = styles;
            append_stylesheet(append_styles_to, style);
        }
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Associates an arbitrary `context` object with the current component and the specified `key`
     * and returns that object. The context is then available to children of the component
     * (including slotted content) with `getContext`.
     *
     * Like lifecycle functions, this must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-setcontext
     */
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }
    function update_await_block_branch(info, ctx, dirty) {
        const child_ctx = ctx.slice();
        const { resolved } = info;
        if (info.current === info.then) {
            child_ctx[info.value] = resolved;
        }
        if (info.current === info.catch) {
            child_ctx[info.error] = resolved;
        }
        info.block.p(child_ctx, dirty);
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var LexicalPlainText_dev = {};

    var LexicalClipboard_dev = {};

    var LexicalHtml_dev = {};

    var LexicalSelection_dev = {};

    var Lexical_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexical_dev;

    function requireLexical_dev () {
    	if (hasRequiredLexical_dev) return Lexical_dev;
    	hasRequiredLexical_dev = 1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function createCommand(type) {
    	  return {
    	    type
    	  } ;
    	}
    	const SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');
    	const CLICK_COMMAND = createCommand('CLICK_COMMAND');
    	const DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');
    	const INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');
    	const INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');
    	const CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');
    	const PASTE_COMMAND = createCommand('PASTE_COMMAND');
    	const REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');
    	const DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');
    	const DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');
    	const FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');
    	const UNDO_COMMAND = createCommand('UNDO_COMMAND');
    	const REDO_COMMAND = createCommand('REDO_COMMAND');
    	const KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');
    	const MOVE_TO_END = createCommand('MOVE_TO_END');
    	const KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');
    	const MOVE_TO_START = createCommand('MOVE_TO_START');
    	const KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');
    	const KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');
    	const KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');
    	const KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');
    	const KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');
    	const KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');
    	const KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');
    	const KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');
    	const INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');
    	const OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');
    	const DROP_COMMAND = createCommand('DROP_COMMAND');
    	const FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');
    	const DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');
    	const DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');
    	const DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');
    	const COPY_COMMAND = createCommand('COPY_COMMAND');
    	const CUT_COMMAND = createCommand('CUT_COMMAND');
    	const CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');
    	const CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');
    	const CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');
    	const CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');
    	const FOCUS_COMMAND = createCommand('FOCUS_COMMAND');
    	const BLUR_COMMAND = createCommand('BLUR_COMMAND');
    	const KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;
    	const IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    	const IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    	const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;
    	const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    	const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.
    	// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);

    	const IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	const DOM_ELEMENT_TYPE = 1;
    	const DOM_TEXT_TYPE = 3; // Reconciling

    	const NO_DIRTY_NODES = 0;
    	const HAS_DIRTY_NODES = 1;
    	const FULL_RECONCILE = 2; // Text node modes

    	const IS_NORMAL = 0;
    	const IS_TOKEN = 1;
    	const IS_SEGMENTED = 2; // IS_INERT = 3
    	// Text node formatting

    	const IS_BOLD = 1;
    	const IS_ITALIC = 1 << 1;
    	const IS_STRIKETHROUGH = 1 << 2;
    	const IS_UNDERLINE = 1 << 3;
    	const IS_CODE = 1 << 4;
    	const IS_SUBSCRIPT = 1 << 5;
    	const IS_SUPERSCRIPT = 1 << 6;
    	const IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT; // Text node details

    	const IS_DIRECTIONLESS = 1;
    	const IS_UNMERGEABLE = 1 << 1; // Element node formatting

    	const IS_ALIGN_LEFT = 1;
    	const IS_ALIGN_CENTER = 2;
    	const IS_ALIGN_RIGHT = 3;
    	const IS_ALIGN_JUSTIFY = 4;
    	const IS_ALIGN_START = 5;
    	const IS_ALIGN_END = 6; // Reconciliation

    	const NON_BREAKING_SPACE = '\u00A0';
    	const ZERO_WIDTH_SPACE = '\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears
    	// overlapping the composed text.

    	const COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
    	const DOUBLE_LINE_BREAK = '\n\n'; // For FF, we need to use a non-breaking space, or it gets composition
    	// in a stuck state.

    	const COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
    	const RTL = '\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC';
    	const LTR = 'A-Za-z\u00C0-\u00D6\u00D8-\u00F6' + '\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u200E\u2C00-\uFB1C' + '\uFE00-\uFE6F\uFEFD-\uFFFF'; // eslint-disable-next-line no-misleading-character-class

    	const RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class

    	const LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');
    	const TEXT_TYPE_TO_FORMAT = {
    	  bold: IS_BOLD,
    	  code: IS_CODE,
    	  italic: IS_ITALIC,
    	  strikethrough: IS_STRIKETHROUGH,
    	  subscript: IS_SUBSCRIPT,
    	  superscript: IS_SUPERSCRIPT,
    	  underline: IS_UNDERLINE
    	};
    	const DETAIL_TYPE_TO_DETAIL = {
    	  directionless: IS_DIRECTIONLESS,
    	  unmergeable: IS_UNMERGEABLE
    	};
    	const ELEMENT_TYPE_TO_FORMAT = {
    	  center: IS_ALIGN_CENTER,
    	  end: IS_ALIGN_END,
    	  justify: IS_ALIGN_JUSTIFY,
    	  left: IS_ALIGN_LEFT,
    	  right: IS_ALIGN_RIGHT,
    	  start: IS_ALIGN_START
    	};
    	const ELEMENT_FORMAT_TO_TYPE = {
    	  [IS_ALIGN_CENTER]: 'center',
    	  [IS_ALIGN_END]: 'end',
    	  [IS_ALIGN_JUSTIFY]: 'justify',
    	  [IS_ALIGN_LEFT]: 'left',
    	  [IS_ALIGN_RIGHT]: 'right',
    	  [IS_ALIGN_START]: 'start'
    	};
    	const TEXT_MODE_TO_TYPE = {
    	  normal: IS_NORMAL,
    	  segmented: IS_SEGMENTED,
    	  token: IS_TOKEN
    	};
    	const TEXT_TYPE_TO_MODE = {
    	  [IS_NORMAL]: 'normal',
    	  [IS_SEGMENTED]: 'segmented',
    	  [IS_TOKEN]: 'token'
    	};

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	const TEXT_MUTATION_VARIANCE = 100;
    	let isProcessingMutations = false;
    	let lastTextEntryTimeStamp = 0;
    	function getIsProcesssingMutations() {
    	  return isProcessingMutations;
    	}

    	function updateTimeStamp(event) {
    	  lastTextEntryTimeStamp = event.timeStamp;
    	}

    	function initTextEntryListener(editor) {
    	  if (lastTextEntryTimeStamp === 0) {
    	    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);
    	  }
    	}

    	function isManagedLineBreak(dom, target, editor) {
    	  return (// @ts-expect-error: internal field
    	    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.
    	    dom[`__lexicalKey_${editor._key}`] !== undefined
    	  );
    	}

    	function getLastSelection(editor) {
    	  return editor.getEditorState().read(() => {
    	    const selection = $getSelection();
    	    return selection !== null ? selection.clone() : null;
    	  });
    	}

    	function handleTextMutation(target, node, editor) {
    	  const domSelection = getDOMSelection(editor._window);
    	  let anchorOffset = null;
    	  let focusOffset = null;

    	  if (domSelection !== null && domSelection.anchorNode === target) {
    	    anchorOffset = domSelection.anchorOffset;
    	    focusOffset = domSelection.focusOffset;
    	  }

    	  const text = target.nodeValue;

    	  if (text !== null) {
    	    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
    	  }
    	}

    	function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
    	  if ($isRangeSelection(selection)) {
    	    const anchorNode = selection.anchor.getNode();

    	    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
    	      return false;
    	    }
    	  }

    	  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();
    	}

    	function $flushMutations$1(editor, mutations, observer) {
    	  isProcessingMutations = true;
    	  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;

    	  try {
    	    updateEditor(editor, () => {
    	      const selection = $getSelection() || getLastSelection(editor);
    	      const badDOMTargets = new Map();
    	      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is
    	      // actually "on screen".

    	      const currentEditorState = editor._editorState;
    	      const blockCursorElement = editor._blockCursorElement;
    	      let shouldRevertSelection = false;
    	      let possibleTextForFirefoxPaste = '';

    	      for (let i = 0; i < mutations.length; i++) {
    	        const mutation = mutations[i];
    	        const type = mutation.type;
    	        const targetDOM = mutation.target;
    	        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);

    	        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {
    	          continue;
    	        }

    	        if (type === 'characterData') {
    	          // Text mutations are deferred and passed to mutation listeners to be
    	          // processed outside of the Lexical engine.
    	          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
    	            handleTextMutation( // nodeType === DOM_TEXT_TYPE is a Text DOM node
    	            targetDOM, targetNode, editor);
    	          }
    	        } else if (type === 'childList') {
    	          shouldRevertSelection = true; // We attempt to "undo" any changes that have occurred outside
    	          // of Lexical. We want Lexical's editor state to be source of truth.
    	          // To the user, these will look like no-ops.

    	          const addedDOMs = mutation.addedNodes;

    	          for (let s = 0; s < addedDOMs.length; s++) {
    	            const addedDOM = addedDOMs[s];
    	            const node = getNodeFromDOMNode(addedDOM);
    	            const parentDOM = addedDOM.parentNode;

    	            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {
    	              if (IS_FIREFOX) {
    	                const possibleText = addedDOM.innerText || addedDOM.nodeValue;

    	                if (possibleText) {
    	                  possibleTextForFirefoxPaste += possibleText;
    	                }
    	              }

    	              parentDOM.removeChild(addedDOM);
    	            }
    	          }

    	          const removedDOMs = mutation.removedNodes;
    	          const removedDOMsLength = removedDOMs.length;

    	          if (removedDOMsLength > 0) {
    	            let unremovedBRs = 0;

    	            for (let s = 0; s < removedDOMsLength; s++) {
    	              const removedDOM = removedDOMs[s];

    	              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
    	                targetDOM.appendChild(removedDOM);
    	                unremovedBRs++;
    	              }
    	            }

    	            if (removedDOMsLength !== unremovedBRs) {
    	              if (targetDOM === rootElement) {
    	                targetNode = internalGetRoot(currentEditorState);
    	              }

    	              badDOMTargets.set(targetDOM, targetNode);
    	            }
    	          }
    	        }
    	      } // Now we process each of the unique target nodes, attempting
    	      // to restore their contents back to the source of truth, which
    	      // is Lexical's "current" editor state. This is basically like
    	      // an internal revert on the DOM.


    	      if (badDOMTargets.size > 0) {
    	        for (const [targetDOM, targetNode] of badDOMTargets) {
    	          if ($isElementNode(targetNode)) {
    	            const childKeys = targetNode.getChildrenKeys();
    	            let currentDOM = targetDOM.firstChild;

    	            for (let s = 0; s < childKeys.length; s++) {
    	              const key = childKeys[s];
    	              const correctDOM = editor.getElementByKey(key);

    	              if (correctDOM === null) {
    	                continue;
    	              }

    	              if (currentDOM == null) {
    	                targetDOM.appendChild(correctDOM);
    	                currentDOM = correctDOM;
    	              } else if (currentDOM !== correctDOM) {
    	                targetDOM.replaceChild(correctDOM, currentDOM);
    	              }

    	              currentDOM = currentDOM.nextSibling;
    	            }
    	          } else if ($isTextNode(targetNode)) {
    	            targetNode.markDirty();
    	          }
    	        }
    	      } // Capture all the mutations made during this function. This
    	      // also prevents us having to process them on the next cycle
    	      // of onMutation, as these mutations were made by us.


    	      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.
    	      // These get added by the browser when we undo the above mutations
    	      // and this can lead to a broken UI.

    	      if (records.length > 0) {
    	        for (let i = 0; i < records.length; i++) {
    	          const record = records[i];
    	          const addedNodes = record.addedNodes;
    	          const target = record.target;

    	          for (let s = 0; s < addedNodes.length; s++) {
    	            const addedDOM = addedNodes[s];
    	            const parentDOM = addedDOM.parentNode;

    	            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {
    	              parentDOM.removeChild(addedDOM);
    	            }
    	          }
    	        } // Clear any of those removal mutations


    	        observer.takeRecords();
    	      }

    	      if (selection !== null) {
    	        if (shouldRevertSelection) {
    	          selection.dirty = true;
    	          $setSelection(selection);
    	        }

    	        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    	          selection.insertRawText(possibleTextForFirefoxPaste);
    	        }
    	      }
    	    });
    	  } finally {
    	    isProcessingMutations = false;
    	  }
    	}
    	function flushRootMutations(editor) {
    	  const observer = editor._observer;

    	  if (observer !== null) {
    	    const mutations = observer.takeRecords();
    	    $flushMutations$1(editor, mutations, observer);
    	  }
    	}
    	function initMutationObserver(editor) {
    	  initTextEntryListener(editor);
    	  editor._observer = new MutationObserver((mutations, observer) => {
    	    $flushMutations$1(editor, mutations, observer);
    	  });
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	let keyCounter = 1;
    	function generateRandomKey() {
    	  return '' + keyCounter++;
    	}
    	function getRegisteredNodeOrThrow(editor, nodeType) {
    	  const registeredNode = editor._nodes.get(nodeType);

    	  if (registeredNode === undefined) {
    	    {
    	      throw Error(`registeredNode: Type ${nodeType} not found`);
    	    }
    	  }

    	  return registeredNode;
    	}
    	const scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {
    	  // No window prefix intended (#1400)
    	  Promise.resolve().then(fn);
    	};
    	function $isSelectionCapturedInDecorator(node) {
    	  return $isDecoratorNode($getNearestNodeFromDOMNode(node));
    	}
    	function isSelectionCapturedInDecoratorInput(anchorDOM) {
    	  const activeElement = document.activeElement;

    	  if (activeElement === null) {
    	    return false;
    	  }

    	  const nodeName = activeElement.nodeName;
    	  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && // @ts-ignore iternal field
    	  activeElement.__lexicalEditor == null);
    	}
    	function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
    	  const rootElement = editor.getRootElement();

    	  try {
    	    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    	    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
    	  } catch (error) {
    	    return false;
    	  }
    	}
    	function getNearestEditorFromDOMNode(node) {
    	  let currentNode = node;

    	  while (currentNode != null) {
    	    // @ts-expect-error: internal field
    	    const editor = currentNode.__lexicalEditor;

    	    if (editor != null) {
    	      return editor;
    	    }

    	    currentNode = getParentElement(currentNode);
    	  }

    	  return null;
    	}
    	function getTextDirection(text) {
    	  if (RTL_REGEX.test(text)) {
    	    return 'rtl';
    	  }

    	  if (LTR_REGEX.test(text)) {
    	    return 'ltr';
    	  }

    	  return null;
    	}
    	function $isTokenOrSegmented(node) {
    	  return node.isToken() || node.isSegmented();
    	}

    	function isDOMNodeLexicalTextNode(node) {
    	  return node.nodeType === DOM_TEXT_TYPE;
    	}

    	function getDOMTextNode(element) {
    	  let node = element;

    	  while (node != null) {
    	    if (isDOMNodeLexicalTextNode(node)) {
    	      return node;
    	    }

    	    node = node.firstChild;
    	  }

    	  return null;
    	}
    	function toggleTextFormatType(format, type, alignWithFormat) {
    	  const activeFormat = TEXT_TYPE_TO_FORMAT[type];
    	  const isStateFlagPresent = format & activeFormat;

    	  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {
    	    // Remove the state flag.
    	    return format ^ activeFormat;
    	  }

    	  if (alignWithFormat === null || alignWithFormat & activeFormat) {
    	    // Add the state flag.
    	    return format | activeFormat;
    	  }

    	  return format;
    	}
    	function $isLeafNode(node) {
    	  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
    	}
    	function $setNodeKey(node, existingKey) {
    	  if (existingKey != null) {
    	    node.__key = existingKey;
    	    return;
    	  }

    	  errorOnReadOnly();
    	  errorOnInfiniteTransforms();
    	  const editor = getActiveEditor();
    	  const editorState = getActiveEditorState();
    	  const key = generateRandomKey();

    	  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element


    	  if ($isElementNode(node)) {
    	    editor._dirtyElements.set(key, true);
    	  } else {
    	    editor._dirtyLeaves.add(key);
    	  }

    	  editor._cloneNotNeeded.add(key);

    	  editor._dirtyType = HAS_DIRTY_NODES;
    	  node.__key = key;
    	}

    	function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
    	  let nextParentKey = parentKey;

    	  while (nextParentKey !== null) {
    	    if (dirtyElements.has(nextParentKey)) {
    	      return;
    	    }

    	    const node = nodeMap.get(nextParentKey);

    	    if (node === undefined) {
    	      break;
    	    }

    	    dirtyElements.set(nextParentKey, false);
    	    nextParentKey = node.__parent;
    	  }
    	}

    	function removeFromParent(node) {
    	  const oldParent = node.getParent();

    	  if (oldParent !== null) {
    	    const writableNode = node.getWritable();
    	    const writableParent = oldParent.getWritable();
    	    const prevSibling = node.getPreviousSibling();
    	    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.

    	    if (prevSibling === null) {
    	      if (nextSibling !== null) {
    	        const writableNextSibling = nextSibling.getWritable();
    	        writableParent.__first = nextSibling.__key;
    	        writableNextSibling.__prev = null;
    	      } else {
    	        writableParent.__first = null;
    	      }
    	    } else {
    	      const writablePrevSibling = prevSibling.getWritable();

    	      if (nextSibling !== null) {
    	        const writableNextSibling = nextSibling.getWritable();
    	        writableNextSibling.__prev = writablePrevSibling.__key;
    	        writablePrevSibling.__next = writableNextSibling.__key;
    	      } else {
    	        writablePrevSibling.__next = null;
    	      }

    	      writableNode.__prev = null;
    	    }

    	    if (nextSibling === null) {
    	      if (prevSibling !== null) {
    	        const writablePrevSibling = prevSibling.getWritable();
    	        writableParent.__last = prevSibling.__key;
    	        writablePrevSibling.__next = null;
    	      } else {
    	        writableParent.__last = null;
    	      }
    	    } else {
    	      const writableNextSibling = nextSibling.getWritable();

    	      if (prevSibling !== null) {
    	        const writablePrevSibling = prevSibling.getWritable();
    	        writablePrevSibling.__next = writableNextSibling.__key;
    	        writableNextSibling.__prev = writablePrevSibling.__key;
    	      } else {
    	        writableNextSibling.__prev = null;
    	      }

    	      writableNode.__next = null;
    	    }

    	    writableParent.__size--;
    	    writableNode.__parent = null;
    	  }
    	} // Never use this function directly! It will break
    	// the cloning heuristic. Instead use node.getWritable().

    	function internalMarkNodeAsDirty(node) {
    	  errorOnInfiniteTransforms();
    	  const latest = node.getLatest();
    	  const parent = latest.__parent;
    	  const editorState = getActiveEditorState();
    	  const editor = getActiveEditor();
    	  const nodeMap = editorState._nodeMap;
    	  const dirtyElements = editor._dirtyElements;

    	  if (parent !== null) {
    	    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
    	  }

    	  const key = latest.__key;
    	  editor._dirtyType = HAS_DIRTY_NODES;

    	  if ($isElementNode(node)) {
    	    dirtyElements.set(key, true);
    	  } else {
    	    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions
    	    editor._dirtyLeaves.add(key);
    	  }
    	}
    	function internalMarkSiblingsAsDirty(node) {
    	  const previousNode = node.getPreviousSibling();
    	  const nextNode = node.getNextSibling();

    	  if (previousNode !== null) {
    	    internalMarkNodeAsDirty(previousNode);
    	  }

    	  if (nextNode !== null) {
    	    internalMarkNodeAsDirty(nextNode);
    	  }
    	}
    	function $setCompositionKey(compositionKey) {
    	  errorOnReadOnly();
    	  const editor = getActiveEditor();
    	  const previousCompositionKey = editor._compositionKey;

    	  if (compositionKey !== previousCompositionKey) {
    	    editor._compositionKey = compositionKey;

    	    if (previousCompositionKey !== null) {
    	      const node = $getNodeByKey(previousCompositionKey);

    	      if (node !== null) {
    	        node.getWritable();
    	      }
    	    }

    	    if (compositionKey !== null) {
    	      const node = $getNodeByKey(compositionKey);

    	      if (node !== null) {
    	        node.getWritable();
    	      }
    	    }
    	  }
    	}
    	function $getCompositionKey() {
    	  if (isCurrentlyReadOnlyMode()) {
    	    return null;
    	  }

    	  const editor = getActiveEditor();
    	  return editor._compositionKey;
    	}
    	function $getNodeByKey(key, _editorState) {
    	  const editorState = _editorState || getActiveEditorState();

    	  const node = editorState._nodeMap.get(key);

    	  if (node === undefined) {
    	    return null;
    	  }

    	  return node;
    	}
    	function getNodeFromDOMNode(dom, editorState) {
    	  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.

    	  const key = dom[`__lexicalKey_${editor._key}`];

    	  if (key !== undefined) {
    	    return $getNodeByKey(key, editorState);
    	  }

    	  return null;
    	}
    	function $getNearestNodeFromDOMNode(startingDOM, editorState) {
    	  let dom = startingDOM;

    	  while (dom != null) {
    	    const node = getNodeFromDOMNode(dom, editorState);

    	    if (node !== null) {
    	      return node;
    	    }

    	    dom = getParentElement(dom);
    	  }

    	  return null;
    	}
    	function cloneDecorators(editor) {
    	  const currentDecorators = editor._decorators;
    	  const pendingDecorators = Object.assign({}, currentDecorators);
    	  editor._pendingDecorators = pendingDecorators;
    	  return pendingDecorators;
    	}
    	function getEditorStateTextContent(editorState) {
    	  return editorState.read(() => $getRoot().getTextContent());
    	}
    	function markAllNodesAsDirty(editor, type) {
    	  // Mark all existing text nodes as dirty
    	  updateEditor(editor, () => {
    	    const editorState = getActiveEditorState();

    	    if (editorState.isEmpty()) {
    	      return;
    	    }

    	    if (type === 'root') {
    	      $getRoot().markDirty();
    	      return;
    	    }

    	    const nodeMap = editorState._nodeMap;

    	    for (const [, node] of nodeMap) {
    	      node.markDirty();
    	    }
    	  }, editor._pendingEditorState === null ? {
    	    tag: 'history-merge'
    	  } : undefined);
    	}
    	function $getRoot() {
    	  return internalGetRoot(getActiveEditorState());
    	}
    	function internalGetRoot(editorState) {
    	  return editorState._nodeMap.get('root');
    	}
    	function $setSelection(selection) {
    	  errorOnReadOnly();
    	  const editorState = getActiveEditorState();

    	  if (selection !== null) {
    	    {
    	      if (Object.isFrozen(selection)) {
    	        {
    	          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
    	        }
    	      }
    	    }

    	    selection.dirty = true;
    	    selection._cachedNodes = null;
    	  }

    	  editorState._selection = selection;
    	}
    	function $flushMutations() {
    	  errorOnReadOnly();
    	  const editor = getActiveEditor();
    	  flushRootMutations(editor);
    	}
    	function getNodeFromDOM(dom) {
    	  const editor = getActiveEditor();
    	  const nodeKey = getNodeKeyFromDOM(dom, editor);

    	  if (nodeKey === null) {
    	    const rootElement = editor.getRootElement();

    	    if (dom === rootElement) {
    	      return $getNodeByKey('root');
    	    }

    	    return null;
    	  }

    	  return $getNodeByKey(nodeKey);
    	}
    	function getTextNodeOffset(node, moveSelectionToEnd) {
    	  return moveSelectionToEnd ? node.getTextContentSize() : 0;
    	}

    	function getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node
    	dom, editor) {
    	  let node = dom;

    	  while (node != null) {
    	    // @ts-ignore We intentionally add this to the Node.
    	    const key = node[`__lexicalKey_${editor._key}`];

    	    if (key !== undefined) {
    	      return key;
    	    }

    	    node = getParentElement(node);
    	  }

    	  return null;
    	}

    	function doesContainGrapheme(str) {
    	  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
    	}
    	function getEditorsToPropagate(editor) {
    	  const editorsToPropagate = [];
    	  let currentEditor = editor;

    	  while (currentEditor !== null) {
    	    editorsToPropagate.push(currentEditor);
    	    currentEditor = currentEditor._parentEditor;
    	  }

    	  return editorsToPropagate;
    	}
    	function createUID() {
    	  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
    	}
    	function getAnchorTextFromDOM(anchorNode) {
    	  if (anchorNode.nodeType === DOM_TEXT_TYPE) {
    	    return anchorNode.nodeValue;
    	  }

    	  return null;
    	}
    	function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
    	  // Update the text content with the latest composition text
    	  const domSelection = getDOMSelection(editor._window);

    	  if (domSelection === null) {
    	    return;
    	  }

    	  const anchorNode = domSelection.anchorNode;
    	  let {
    	    anchorOffset,
    	    focusOffset
    	  } = domSelection;

    	  if (anchorNode !== null) {
    	    let textContent = getAnchorTextFromDOM(anchorNode);
    	    const node = $getNearestNodeFromDOMNode(anchorNode);

    	    if (textContent !== null && $isTextNode(node)) {
    	      // Data is intentionally truthy, as we check for boolean, null and empty string.
    	      if (textContent === COMPOSITION_SUFFIX && data) {
    	        const offset = data.length;
    	        textContent = data;
    	        anchorOffset = offset;
    	        focusOffset = offset;
    	      }

    	      if (textContent !== null) {
    	        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
    	      }
    	    }
    	  }
    	}
    	function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
    	  let node = textNode;

    	  if (node.isAttached() && (compositionEnd || !node.isDirty())) {
    	    const isComposing = node.isComposing();
    	    let normalizedTextContent = textContent;

    	    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
    	      normalizedTextContent = textContent.slice(0, -1);
    	    }

    	    const prevTextContent = node.getTextContent();

    	    if (compositionEnd || normalizedTextContent !== prevTextContent) {
    	      if (normalizedTextContent === '') {
    	        $setCompositionKey(null);

    	        if (!IS_SAFARI && !IS_IOS) {
    	          // For composition (mainly Android), we have to remove the node on a later update
    	          const editor = getActiveEditor();
    	          setTimeout(() => {
    	            editor.update(() => {
    	              if (node.isAttached()) {
    	                node.remove();
    	              }
    	            });
    	          }, 20);
    	        } else {
    	          node.remove();
    	        }

    	        return;
    	      }

    	      const parent = node.getParent();
    	      const prevSelection = $getPreviousSelection();
    	      const compositionKey = $getCompositionKey();
    	      const nodeKey = node.getKey();

    	      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start, and we need
    	      // to clear this input from occurring as that action wasn't
    	      // permitted.
    	      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {
    	        node.markDirty();
    	        return;
    	      }

    	      const selection = $getSelection();

    	      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
    	        node.setTextContent(normalizedTextContent);
    	        return;
    	      }

    	      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);

    	      if (node.isSegmented()) {
    	        const originalTextContent = node.getTextContent();
    	        const replacement = $createTextNode(originalTextContent);
    	        node.replace(replacement);
    	        node = replacement;
    	      }

    	      node.setTextContent(normalizedTextContent);
    	    }
    	  }
    	}

    	function $previousSiblingDoesNotAcceptText(node) {
    	  const previousSibling = node.getPreviousSibling();
    	  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
    	} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the
    	// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,
    	// in the case of a LinkNode, boundaries are not writable.


    	function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
    	  if (node.isSegmented()) {
    	    return true;
    	  }

    	  if (!selection.isCollapsed()) {
    	    return false;
    	  }

    	  const offset = selection.anchor.offset;
    	  const parent = node.getParentOrThrow();
    	  const isToken = node.isToken();

    	  if (offset === 0) {
    	    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);
    	  } else if (offset === node.getTextContentSize()) {
    	    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;
    	  } else {
    	    return false;
    	  }
    	}
    	function isTab(keyCode, altKey, ctrlKey, metaKey) {
    	  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;
    	}
    	function isBold(keyCode, altKey, metaKey, ctrlKey) {
    	  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);
    	}
    	function isItalic(keyCode, altKey, metaKey, ctrlKey) {
    	  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);
    	}
    	function isUnderline(keyCode, altKey, metaKey, ctrlKey) {
    	  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);
    	}
    	function isParagraph(keyCode, shiftKey) {
    	  return isReturn(keyCode) && !shiftKey;
    	}
    	function isLineBreak(keyCode, shiftKey) {
    	  return isReturn(keyCode) && shiftKey;
    	} // Inserts a new line after the selection

    	function isOpenLineBreak(keyCode, ctrlKey) {
    	  // 79 = KeyO
    	  return IS_APPLE && ctrlKey && keyCode === 79;
    	}
    	function isDeleteWordBackward(keyCode, altKey, ctrlKey) {
    	  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);
    	}
    	function isDeleteWordForward(keyCode, altKey, ctrlKey) {
    	  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);
    	}
    	function isDeleteLineBackward(keyCode, metaKey) {
    	  return IS_APPLE && metaKey && isBackspace(keyCode);
    	}
    	function isDeleteLineForward(keyCode, metaKey) {
    	  return IS_APPLE && metaKey && isDelete(keyCode);
    	}
    	function isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {
    	  if (IS_APPLE) {
    	    if (altKey || metaKey) {
    	      return false;
    	    }

    	    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;
    	  }

    	  if (ctrlKey || altKey || metaKey) {
    	    return false;
    	  }

    	  return isBackspace(keyCode);
    	}
    	function isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
    	  if (IS_APPLE) {
    	    if (shiftKey || altKey || metaKey) {
    	      return false;
    	    }

    	    return isDelete(keyCode) || keyCode === 68 && ctrlKey;
    	  }

    	  if (ctrlKey || altKey || metaKey) {
    	    return false;
    	  }

    	  return isDelete(keyCode);
    	}
    	function isUndo(keyCode, shiftKey, metaKey, ctrlKey) {
    	  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);
    	}
    	function isRedo(keyCode, shiftKey, metaKey, ctrlKey) {
    	  if (IS_APPLE) {
    	    return keyCode === 90 && metaKey && shiftKey;
    	  }

    	  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;
    	}
    	function isCopy(keyCode, shiftKey, metaKey, ctrlKey) {
    	  if (shiftKey) {
    	    return false;
    	  }

    	  if (keyCode === 67) {
    	    return IS_APPLE ? metaKey : ctrlKey;
    	  }

    	  return false;
    	}
    	function isCut(keyCode, shiftKey, metaKey, ctrlKey) {
    	  if (shiftKey) {
    	    return false;
    	  }

    	  if (keyCode === 88) {
    	    return IS_APPLE ? metaKey : ctrlKey;
    	  }

    	  return false;
    	}

    	function isArrowLeft(keyCode) {
    	  return keyCode === 37;
    	}

    	function isArrowRight(keyCode) {
    	  return keyCode === 39;
    	}

    	function isArrowUp(keyCode) {
    	  return keyCode === 38;
    	}

    	function isArrowDown(keyCode) {
    	  return keyCode === 40;
    	}

    	function isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {
    	  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;
    	}
    	function isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
    	  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    	}
    	function isMoveForward(keyCode, ctrlKey, altKey, metaKey) {
    	  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;
    	}
    	function isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
    	  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    	}
    	function isMoveUp(keyCode, ctrlKey, metaKey) {
    	  return isArrowUp(keyCode) && !ctrlKey && !metaKey;
    	}
    	function isMoveDown(keyCode, ctrlKey, metaKey) {
    	  return isArrowDown(keyCode) && !ctrlKey && !metaKey;
    	}
    	function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
    	  return ctrlKey || shiftKey || altKey || metaKey;
    	}
    	function isSpace(keyCode) {
    	  return keyCode === 32;
    	}
    	function controlOrMeta(metaKey, ctrlKey) {
    	  if (IS_APPLE) {
    	    return metaKey;
    	  }

    	  return ctrlKey;
    	}
    	function isReturn(keyCode) {
    	  return keyCode === 13;
    	}
    	function isBackspace(keyCode) {
    	  return keyCode === 8;
    	}
    	function isEscape(keyCode) {
    	  return keyCode === 27;
    	}
    	function isDelete(keyCode) {
    	  return keyCode === 46;
    	}
    	function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
    	  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need
    	  // to handle className tokens that have spaces.
    	  // The easiest way to do this to convert the
    	  // className tokens to an array that can be
    	  // applied to classList.add()/remove().

    	  if (typeof classNames === 'string') {
    	    const classNamesArr = classNames.split(' ');
    	    classNamesTheme[classNameThemeType] = classNamesArr;
    	    return classNamesArr;
    	  }

    	  return classNames;
    	}
    	function setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {
    	  if (mutationListeners.size === 0) {
    	    return;
    	  }

    	  const nodeType = node.__type;
    	  const nodeKey = node.__key;
    	  const registeredNode = registeredNodes.get(nodeType);

    	  if (registeredNode === undefined) {
    	    {
    	      throw Error(`Type ${nodeType} not in registeredNodes`);
    	    }
    	  }

    	  const klass = registeredNode.klass;
    	  let mutatedNodesByType = mutatedNodes.get(klass);

    	  if (mutatedNodesByType === undefined) {
    	    mutatedNodesByType = new Map();
    	    mutatedNodes.set(klass, mutatedNodesByType);
    	  }

    	  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been "destroyed", yet we are
    	  // re-making it, then this means a move likely happened.
    	  // We should change the mutation to be that of "updated"
    	  // instead.

    	  const isMove = prevMutation === 'destroyed' && mutation === 'created';

    	  if (prevMutation === undefined || isMove) {
    	    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);
    	  }
    	}
    	function $nodesOfType(klass) {
    	  const editorState = getActiveEditorState();
    	  const readOnly = editorState._readOnly;
    	  const klassType = klass.getType();
    	  const nodes = editorState._nodeMap;
    	  const nodesOfType = [];

    	  for (const [, node] of nodes) {
    	    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {
    	      nodesOfType.push(node);
    	    }
    	  }

    	  return nodesOfType;
    	}

    	function resolveElement(element, isBackward, focusOffset) {
    	  const parent = element.getParent();
    	  let offset = focusOffset;
    	  let block = element;

    	  if (parent !== null) {
    	    if (isBackward && focusOffset === 0) {
    	      offset = block.getIndexWithinParent();
    	      block = parent;
    	    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
    	      offset = block.getIndexWithinParent() + 1;
    	      block = parent;
    	    }
    	  }

    	  return block.getChildAtIndex(isBackward ? offset - 1 : offset);
    	}

    	function $getAdjacentNode(focus, isBackward) {
    	  const focusOffset = focus.offset;

    	  if (focus.type === 'element') {
    	    const block = focus.getNode();
    	    return resolveElement(block, isBackward, focusOffset);
    	  } else {
    	    const focusNode = focus.getNode();

    	    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
    	      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();

    	      if (possibleNode === null) {
    	        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
    	      }

    	      return possibleNode;
    	    }
    	  }

    	  return null;
    	}
    	function isFirefoxClipboardEvents(editor) {
    	  const event = getWindow(editor).event;
    	  const inputType = event && event.inputType;
    	  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';
    	}
    	function dispatchCommand(editor, command, payload) {
    	  return triggerCommandListeners(editor, command, payload);
    	}
    	function $textContentRequiresDoubleLinebreakAtEnd(node) {
    	  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
    	}
    	function getElementByKeyOrThrow(editor, key) {
    	  const element = editor._keyToDOMMap.get(key);

    	  if (element === undefined) {
    	    {
    	      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    	    }
    	  }

    	  return element;
    	}
    	function getParentElement(node) {
    	  const parentElement = node.assignedSlot || node.parentElement;
    	  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;
    	}
    	function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
    	  const doc = rootElement.ownerDocument;
    	  const defaultView = doc.defaultView;

    	  if (defaultView === null) {
    	    return;
    	  }

    	  let {
    	    top: currentTop,
    	    bottom: currentBottom
    	  } = selectionRect;
    	  let targetTop = 0;
    	  let targetBottom = 0;
    	  let element = rootElement;

    	  while (element !== null) {
    	    const isBodyElement = element === doc.body;

    	    if (isBodyElement) {
    	      targetTop = 0;
    	      targetBottom = getWindow(editor).innerHeight;
    	    } else {
    	      const targetRect = element.getBoundingClientRect();
    	      targetTop = targetRect.top;
    	      targetBottom = targetRect.bottom;
    	    }

    	    let diff = 0;

    	    if (currentTop < targetTop) {
    	      diff = -(targetTop - currentTop);
    	    } else if (currentBottom > targetBottom) {
    	      diff = currentBottom - targetBottom;
    	    }

    	    if (diff !== 0) {
    	      if (isBodyElement) {
    	        // Only handles scrolling of Y axis
    	        defaultView.scrollBy(0, diff);
    	      } else {
    	        const scrollTop = element.scrollTop;
    	        element.scrollTop += diff;
    	        const yOffset = element.scrollTop - scrollTop;
    	        currentTop -= yOffset;
    	        currentBottom -= yOffset;
    	      }
    	    }

    	    if (isBodyElement) {
    	      break;
    	    }

    	    element = getParentElement(element);
    	  }
    	}
    	function $addUpdateTag(tag) {
    	  errorOnReadOnly();
    	  const editor = getActiveEditor();

    	  editor._updateTags.add(tag);
    	}
    	function $maybeMoveChildrenSelectionToParent(parentNode, offset = 0) {
    	  if (offset !== 0) {
    	    {
    	      throw Error(`TODO`);
    	    }
    	  }

    	  const selection = $getSelection();

    	  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
    	    return selection;
    	  }

    	  const {
    	    anchor,
    	    focus
    	  } = selection;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();

    	  if ($hasAncestor(anchorNode, parentNode)) {
    	    anchor.set(parentNode.__key, 0, 'element');
    	  }

    	  if ($hasAncestor(focusNode, parentNode)) {
    	    focus.set(parentNode.__key, 0, 'element');
    	  }

    	  return selection;
    	}
    	function $hasAncestor(child, targetNode) {
    	  let parent = child.getParent();

    	  while (parent !== null) {
    	    if (parent.is(targetNode)) {
    	      return true;
    	    }

    	    parent = parent.getParent();
    	  }

    	  return false;
    	}
    	function getDefaultView(domElem) {
    	  const ownerDoc = domElem.ownerDocument;
    	  return ownerDoc && ownerDoc.defaultView || null;
    	}
    	function getWindow(editor) {
    	  const windowObj = editor._window;

    	  if (windowObj === null) {
    	    {
    	      throw Error(`window object not found`);
    	    }
    	  }

    	  return windowObj;
    	}
    	function $isInlineElementOrDecoratorNode(node) {
    	  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
    	}
    	function $getNearestRootOrShadowRoot(node) {
    	  let parent = node.getParentOrThrow();

    	  while (parent !== null) {
    	    if ($isRootOrShadowRoot(parent)) {
    	      return parent;
    	    }

    	    parent = parent.getParentOrThrow();
    	  }

    	  return parent;
    	}
    	function $isRootOrShadowRoot(node) {
    	  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
    	}
    	function $copyNode(node) {
    	  // @ts-ignore
    	  const copy = node.constructor.clone(node);
    	  $setNodeKey(copy, null);
    	  return copy;
    	}
    	function $applyNodeReplacement(node) {
    	  const editor = getActiveEditor();
    	  const nodeType = node.constructor.getType();

    	  const registeredNode = editor._nodes.get(nodeType);

    	  if (registeredNode === undefined) {
    	    {
    	      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
    	    }
    	  }

    	  const replaceFunc = registeredNode.replace;

    	  if (replaceFunc !== null) {
    	    const replacementNode = replaceFunc(node);

    	    if (!(replacementNode instanceof node.constructor)) {
    	      {
    	        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);
    	      }
    	    }

    	    return replacementNode;
    	  }

    	  return node;
    	}
    	function errorOnInsertTextNodeOnRoot(node, insertNode) {
    	  const parentNode = node.getParent();

    	  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    	    {
    	      throw Error(`Only element or decorator nodes can be inserted in to the root node`);
    	    }
    	  }
    	}

    	function createBlockCursorElement(editorConfig) {
    	  const theme = editorConfig.theme;
    	  const element = document.createElement('div');
    	  element.contentEditable = 'false';
    	  element.setAttribute('data-lexical-cursor', 'true');
    	  let blockCursorTheme = theme.blockCursor;

    	  if (blockCursorTheme !== undefined) {
    	    if (typeof blockCursorTheme === 'string') {
    	      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional

    	      blockCursorTheme = theme.blockCursor = classNamesArr;
    	    }

    	    if (blockCursorTheme !== undefined) {
    	      element.classList.add(...blockCursorTheme);
    	    }
    	  }

    	  return element;
    	}

    	function needsBlockCursor(node) {
    	  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
    	}

    	function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
    	  rootElement.style.removeProperty('caret-color');
    	  editor._blockCursorElement = null;
    	  const parentElement = blockCursorElement.parentElement;

    	  if (parentElement !== null) {
    	    parentElement.removeChild(blockCursorElement);
    	  }
    	}
    	function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
    	  let blockCursorElement = editor._blockCursorElement;

    	  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {
    	    const anchor = nextSelection.anchor;
    	    const elementNode = anchor.getNode();
    	    const offset = anchor.offset;
    	    const elementNodeSize = elementNode.getChildrenSize();
    	    let isBlockCursor = false;
    	    let insertBeforeElement = null;

    	    if (offset === elementNodeSize) {
    	      const child = elementNode.getChildAtIndex(offset - 1);

    	      if (needsBlockCursor(child)) {
    	        isBlockCursor = true;
    	      }
    	    } else {
    	      const child = elementNode.getChildAtIndex(offset);

    	      if (needsBlockCursor(child)) {
    	        const sibling = child.getPreviousSibling();

    	        if (sibling === null || needsBlockCursor(sibling)) {
    	          isBlockCursor = true;
    	          insertBeforeElement = editor.getElementByKey(child.__key);
    	        }
    	      }
    	    }

    	    if (isBlockCursor) {
    	      const elementDOM = editor.getElementByKey(elementNode.__key);

    	      if (blockCursorElement === null) {
    	        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
    	      }

    	      rootElement.style.caretColor = 'transparent';

    	      if (insertBeforeElement === null) {
    	        elementDOM.appendChild(blockCursorElement);
    	      } else {
    	        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
    	      }

    	      return;
    	    }
    	  } // Remove cursor


    	  if (blockCursorElement !== null) {
    	    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    	  }
    	}
    	function getDOMSelection(targetWindow) {
    	  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
    	  const currentDecorators = editor._decorators;
    	  const pendingDecorators = editor._pendingDecorators;
    	  let decorators = pendingDecorators || currentDecorators;
    	  const nodeMap = pendingEditorState._nodeMap;
    	  let key;

    	  for (key in decorators) {
    	    if (!nodeMap.has(key)) {
    	      if (decorators === currentDecorators) {
    	        decorators = cloneDecorators(editor);
    	      }

    	      delete decorators[key];
    	    }
    	  }
    	}

    	function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {
    	  let child = node.getFirstChild();

    	  while (child !== null) {
    	    const childKey = child.__key;

    	    if (child !== undefined && child.__parent === parentKey) {
    	      if ($isElementNode(child)) {
    	        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);
    	      } // If we have created a node and it was dereferenced, then also
    	      // remove it from out dirty nodes Set.


    	      if (!prevNodeMap.has(childKey)) {
    	        dirtyNodes.delete(childKey);
    	      }

    	      nodeMap.delete(childKey);
    	    }

    	    child = child.isAttached() ? child.getNextSibling() : null;
    	  }
    	}

    	function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
    	  const prevNodeMap = prevEditorState._nodeMap;
    	  const nodeMap = editorState._nodeMap;

    	  for (const nodeKey of dirtyLeaves) {
    	    const node = nodeMap.get(nodeKey);

    	    if (node !== undefined && !node.isAttached()) {
    	      if (!prevNodeMap.has(nodeKey)) {
    	        dirtyLeaves.delete(nodeKey);
    	      }

    	      nodeMap.delete(nodeKey);
    	    }
    	  }

    	  for (const [nodeKey] of dirtyElements) {
    	    const node = nodeMap.get(nodeKey);

    	    if (node !== undefined) {
    	      // Garbage collect node and its children if they exist
    	      if (!node.isAttached()) {
    	        if ($isElementNode(node)) {
    	          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);
    	        } // If we have created a node and it was dereferenced, then also
    	        // remove it from out dirty nodes Set.


    	        if (!prevNodeMap.has(nodeKey)) {
    	          dirtyElements.delete(nodeKey);
    	        }

    	        nodeMap.delete(nodeKey);
    	      }
    	    }
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	function $canSimpleTextNodesBeMerged(node1, node2) {
    	  const node1Mode = node1.__mode;
    	  const node1Format = node1.__format;
    	  const node1Style = node1.__style;
    	  const node2Mode = node2.__mode;
    	  const node2Format = node2.__format;
    	  const node2Style = node2.__style;
    	  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
    	}

    	function $mergeTextNodes(node1, node2) {
    	  const writableNode1 = node1.mergeWithSibling(node2);

    	  const normalizedNodes = getActiveEditor()._normalizedNodes;

    	  normalizedNodes.add(node1.__key);
    	  normalizedNodes.add(node2.__key);
    	  return writableNode1;
    	}

    	function $normalizeTextNode(textNode) {
    	  let node = textNode;

    	  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {
    	    node.remove();
    	    return;
    	  } // Backward


    	  let previousNode;

    	  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    	    if (previousNode.__text === '') {
    	      previousNode.remove();
    	    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
    	      node = $mergeTextNodes(previousNode, node);
    	      break;
    	    } else {
    	      break;
    	    }
    	  } // Forward


    	  let nextNode;

    	  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    	    if (nextNode.__text === '') {
    	      nextNode.remove();
    	    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
    	      node = $mergeTextNodes(node, nextNode);
    	      break;
    	    } else {
    	      break;
    	    }
    	  }
    	}
    	function $normalizeSelection(selection) {
    	  $normalizePoint(selection.anchor);
    	  $normalizePoint(selection.focus);
    	  return selection;
    	}

    	function $normalizePoint(point) {
    	  while (point.type === 'element') {
    	    const node = point.getNode();
    	    const offset = point.offset;
    	    let nextNode;
    	    let nextOffsetAtEnd;

    	    if (offset === node.getChildrenSize()) {
    	      nextNode = node.getChildAtIndex(offset - 1);
    	      nextOffsetAtEnd = true;
    	    } else {
    	      nextNode = node.getChildAtIndex(offset);
    	      nextOffsetAtEnd = false;
    	    }

    	    if ($isTextNode(nextNode)) {
    	      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');
    	      break;
    	    } else if (!$isElementNode(nextNode)) {
    	      break;
    	    }

    	    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	let subTreeTextContent = '';
    	let subTreeDirectionedTextContent = '';
    	let editorTextContent = '';
    	let activeEditorConfig;
    	let activeEditor$1;
    	let activeEditorNodes;
    	let treatAllNodesAsDirty = false;
    	let activeEditorStateReadOnly = false;
    	let activeMutationListeners;
    	let activeTextDirection = null;
    	let activeDirtyElements;
    	let activeDirtyLeaves;
    	let activePrevNodeMap;
    	let activeNextNodeMap;
    	let activePrevKeyToDOMMap;
    	let mutatedNodes;

    	function destroyNode(key, parentDOM) {
    	  const node = activePrevNodeMap.get(key);

    	  if (parentDOM !== null) {
    	    const dom = getPrevElementByKeyOrThrow(key);

    	    if (dom.parentNode === parentDOM) {
    	      parentDOM.removeChild(dom);
    	    }
    	  } // This logic is really important, otherwise we will leak DOM nodes
    	  // when their corresponding LexicalNodes are removed from the editor state.


    	  if (!activeNextNodeMap.has(key)) {
    	    activeEditor$1._keyToDOMMap.delete(key);
    	  }

    	  if ($isElementNode(node)) {
    	    const children = createChildrenArray(node, activePrevNodeMap);
    	    destroyChildren(children, 0, children.length - 1, null);
    	  }

    	  if (node !== undefined) {
    	    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');
    	  }
    	}

    	function destroyChildren(children, _startIndex, endIndex, dom) {
    	  let startIndex = _startIndex;

    	  for (; startIndex <= endIndex; ++startIndex) {
    	    const child = children[startIndex];

    	    if (child !== undefined) {
    	      destroyNode(child, dom);
    	    }
    	  }
    	}

    	function setTextAlign(domStyle, value) {
    	  domStyle.setProperty('text-align', value);
    	}

    	function setElementIndent(dom, indent) {
    	  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : indent * 20 + 'px');
    	}

    	function setElementFormat(dom, format) {
    	  const domStyle = dom.style;

    	  if (format === 0) {
    	    setTextAlign(domStyle, '');
    	  } else if (format === IS_ALIGN_LEFT) {
    	    setTextAlign(domStyle, 'left');
    	  } else if (format === IS_ALIGN_CENTER) {
    	    setTextAlign(domStyle, 'center');
    	  } else if (format === IS_ALIGN_RIGHT) {
    	    setTextAlign(domStyle, 'right');
    	  } else if (format === IS_ALIGN_JUSTIFY) {
    	    setTextAlign(domStyle, 'justify');
    	  } else if (format === IS_ALIGN_START) {
    	    setTextAlign(domStyle, 'start');
    	  } else if (format === IS_ALIGN_END) {
    	    setTextAlign(domStyle, 'end');
    	  }
    	}

    	function createNode(key, parentDOM, insertDOM) {
    	  const node = activeNextNodeMap.get(key);

    	  if (node === undefined) {
    	    {
    	      throw Error(`createNode: node does not exist in nodeMap`);
    	    }
    	  }

    	  const dom = node.createDOM(activeEditorConfig, activeEditor$1);
    	  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from
    	  // merging or break the spans (which happens if they are missing
    	  // this attribute).

    	  if ($isTextNode(node)) {
    	    dom.setAttribute('data-lexical-text', 'true');
    	  } else if ($isDecoratorNode(node)) {
    	    dom.setAttribute('data-lexical-decorator', 'true');
    	  }

    	  if ($isElementNode(node)) {
    	    const indent = node.__indent;
    	    const childrenSize = node.__size;

    	    if (indent !== 0) {
    	      setElementIndent(dom, indent);
    	    }

    	    if (childrenSize !== 0) {
    	      const endIndex = childrenSize - 1;
    	      const children = createChildrenArray(node, activeNextNodeMap);
    	      createChildrenWithDirection(children, endIndex, node, dom);

    	      if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
    	        subTreeTextContent += DOUBLE_LINE_BREAK; // @ts-expect-error: internal field

    	        dom.__lexicalTextContent = subTreeTextContent;
    	      }
    	    }

    	    const format = node.__format;

    	    if (format !== 0) {
    	      setElementFormat(dom, format);
    	    }

    	    if (!node.isInline()) {
    	      reconcileElementTerminatingLineBreak(null, node, dom);
    	    }

    	    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
    	      subTreeTextContent += DOUBLE_LINE_BREAK;
    	      editorTextContent += DOUBLE_LINE_BREAK;
    	    }
    	  } else {
    	    const text = node.getTextContent();

    	    if ($isDecoratorNode(node)) {
    	      const decorator = node.decorate(activeEditor$1, activeEditorConfig);

    	      if (decorator !== null) {
    	        reconcileDecorator(key, decorator);
    	      } // Decorators are always non editable


    	      dom.contentEditable = 'false';
    	    } else if ($isTextNode(node)) {
    	      if (!node.isDirectionless()) {
    	        subTreeDirectionedTextContent += text;
    	      }
    	    }

    	    subTreeTextContent += text;
    	    editorTextContent += text;
    	  }

    	  if (parentDOM !== null) {
    	    if (insertDOM != null) {
    	      parentDOM.insertBefore(dom, insertDOM);
    	    } else {
    	      // @ts-expect-error: internal field
    	      const possibleLineBreak = parentDOM.__lexicalLineBreak;

    	      if (possibleLineBreak != null) {
    	        parentDOM.insertBefore(dom, possibleLineBreak);
    	      } else {
    	        parentDOM.appendChild(dom);
    	      }
    	    }
    	  }

    	  {
    	    // Freeze the node in DEV to prevent accidental mutations
    	    Object.freeze(node);
    	  }

    	  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');
    	  return dom;
    	}

    	function createChildrenWithDirection(children, endIndex, element, dom) {
    	  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
    	  subTreeDirectionedTextContent = '';
    	  createChildren(children, 0, endIndex, dom, null);
    	  reconcileBlockDirection(element, dom);
    	  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
    	}

    	function createChildren(children, _startIndex, endIndex, dom, insertDOM) {
    	  const previousSubTreeTextContent = subTreeTextContent;
    	  subTreeTextContent = '';
    	  let startIndex = _startIndex;

    	  for (; startIndex <= endIndex; ++startIndex) {
    	    createNode(children[startIndex], dom, insertDOM);
    	  } // @ts-expect-error: internal field


    	  dom.__lexicalTextContent = subTreeTextContent;
    	  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    	}

    	function isLastChildLineBreakOrDecorator(childKey, nodeMap) {
    	  const node = nodeMap.get(childKey);
    	  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();
    	} // If we end an element with a LineBreakNode, then we need to add an additional <br>


    	function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
    	  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));
    	  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);

    	  if (prevLineBreak) {
    	    if (!nextLineBreak) {
    	      // @ts-expect-error: internal field
    	      const element = dom.__lexicalLineBreak;

    	      if (element != null) {
    	        dom.removeChild(element);
    	      } // @ts-expect-error: internal field


    	      dom.__lexicalLineBreak = null;
    	    }
    	  } else if (nextLineBreak) {
    	    const element = document.createElement('br'); // @ts-expect-error: internal field

    	    dom.__lexicalLineBreak = element;
    	    dom.appendChild(element);
    	  }
    	}

    	function reconcileBlockDirection(element, dom) {
    	  const previousSubTreeDirectionTextContent = // @ts-expect-error: internal field
    	  dom.__lexicalDirTextContent; // @ts-expect-error: internal field

    	  const previousDirection = dom.__lexicalDir;

    	  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
    	    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';
    	    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);

    	    if (direction !== previousDirection) {
    	      const classList = dom.classList;
    	      const theme = activeEditorConfig.theme;
    	      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;
    	      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist

    	      if (previousDirectionTheme !== undefined) {
    	        if (typeof previousDirectionTheme === 'string') {
    	          const classNamesArr = previousDirectionTheme.split(' ');
    	          previousDirectionTheme = theme[previousDirection] = classNamesArr;
    	        } // @ts-ignore: intentional


    	        classList.remove(...previousDirectionTheme);
    	      }

    	      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {
    	        // Remove direction
    	        dom.removeAttribute('dir');
    	      } else {
    	        // Apply the new theme classes if they exist
    	        if (nextDirectionTheme !== undefined) {
    	          if (typeof nextDirectionTheme === 'string') {
    	            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional

    	            nextDirectionTheme = theme[direction] = classNamesArr;
    	          }

    	          if (nextDirectionTheme !== undefined) {
    	            classList.add(...nextDirectionTheme);
    	          }
    	        } // Update direction


    	        dom.dir = direction;
    	      }

    	      if (!activeEditorStateReadOnly) {
    	        const writableNode = element.getWritable();
    	        writableNode.__dir = direction;
    	      }
    	    }

    	    activeTextDirection = direction; // @ts-expect-error: internal field

    	    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field

    	    dom.__lexicalDir = direction;
    	  }
    	}

    	function reconcileChildrenWithDirection(prevElement, nextElement, dom) {
    	  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
    	  subTreeDirectionedTextContent = '';
    	  reconcileChildren(prevElement, nextElement, dom);
    	  reconcileBlockDirection(nextElement, dom);
    	  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
    	}

    	function createChildrenArray(element, nodeMap) {
    	  const children = [];
    	  let nodeKey = element.__first;

    	  while (nodeKey !== null) {
    	    const node = nodeMap.get(nodeKey);

    	    if (node === undefined) {
    	      {
    	        throw Error(`createChildrenArray: node does not exist in nodeMap`);
    	      }
    	    }

    	    children.push(nodeKey);
    	    nodeKey = node.__next;
    	  }

    	  return children;
    	}

    	function reconcileChildren(prevElement, nextElement, dom) {
    	  const previousSubTreeTextContent = subTreeTextContent;
    	  const prevChildrenSize = prevElement.__size;
    	  const nextChildrenSize = nextElement.__size;
    	  subTreeTextContent = '';

    	  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    	    const prevFirstChildKey = prevElement.__first;
    	    const nextFrstChildKey = nextElement.__first;

    	    if (prevFirstChildKey === nextFrstChildKey) {
    	      reconcileNode(prevFirstChildKey, dom);
    	    } else {
    	      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
    	      const replacementDOM = createNode(nextFrstChildKey, null, null);
    	      dom.replaceChild(replacementDOM, lastDOM);
    	      destroyNode(prevFirstChildKey, null);
    	    }
    	  } else {
    	    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    	    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);

    	    if (prevChildrenSize === 0) {
    	      if (nextChildrenSize !== 0) {
    	        createChildren(nextChildren, 0, nextChildrenSize - 1, dom, null);
    	      }
    	    } else if (nextChildrenSize === 0) {
    	      if (prevChildrenSize !== 0) {
    	        // @ts-expect-error: internal field
    	        const lexicalLineBreak = dom.__lexicalLineBreak;
    	        const canUseFastPath = lexicalLineBreak == null;
    	        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);

    	        if (canUseFastPath) {
    	          // Fast path for removing DOM nodes
    	          dom.textContent = '';
    	        }
    	      }
    	    } else {
    	      reconcileNodeChildren(prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);
    	    }
    	  }

    	  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    	    subTreeTextContent += DOUBLE_LINE_BREAK;
    	  } // @ts-expect-error: internal field


    	  dom.__lexicalTextContent = subTreeTextContent;
    	  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    	}

    	function reconcileNode(key, parentDOM) {
    	  const prevNode = activePrevNodeMap.get(key);
    	  let nextNode = activeNextNodeMap.get(key);

    	  if (prevNode === undefined || nextNode === undefined) {
    	    {
    	      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    	    }
    	  }

    	  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
    	  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states
    	  // and isn't dirty, we just update the text content cache
    	  // and return the existing DOM Node.

    	  if (prevNode === nextNode && !isDirty) {
    	    if ($isElementNode(prevNode)) {
    	      // @ts-expect-error: internal field
    	      const previousSubTreeTextContent = dom.__lexicalTextContent;

    	      if (previousSubTreeTextContent !== undefined) {
    	        subTreeTextContent += previousSubTreeTextContent;
    	        editorTextContent += previousSubTreeTextContent;
    	      } // @ts-expect-error: internal field


    	      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;

    	      if (previousSubTreeDirectionTextContent !== undefined) {
    	        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
    	      }
    	    } else {
    	      const text = prevNode.getTextContent();

    	      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
    	        subTreeDirectionedTextContent += text;
    	      }

    	      editorTextContent += text;
    	      subTreeTextContent += text;
    	    }

    	    return dom;
    	  } // If the node key doesn't point to the same instance in both maps,
    	  // it means it were cloned. If they're also dirty, we mark them as mutated.


    	  if (prevNode !== nextNode && isDirty) {
    	    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');
    	  } // Update node. If it returns true, we need to unmount and re-create the node


    	  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
    	    const replacementDOM = createNode(key, null, null);

    	    if (parentDOM === null) {
    	      {
    	        throw Error(`reconcileNode: parentDOM is null`);
    	      }
    	    }

    	    parentDOM.replaceChild(replacementDOM, dom);
    	    destroyNode(key, null);
    	    return replacementDOM;
    	  }

    	  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    	    // Reconcile element children
    	    const nextIndent = nextNode.__indent;

    	    if (nextIndent !== prevNode.__indent) {
    	      setElementIndent(dom, nextIndent);
    	    }

    	    const nextFormat = nextNode.__format;

    	    if (nextFormat !== prevNode.__format) {
    	      setElementFormat(dom, nextFormat);
    	    }

    	    if (isDirty) {
    	      reconcileChildrenWithDirection(prevNode, nextNode, dom);

    	      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
    	        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
    	      }
    	    }

    	    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
    	      subTreeTextContent += DOUBLE_LINE_BREAK;
    	      editorTextContent += DOUBLE_LINE_BREAK;
    	    }
    	  } else {
    	    const text = nextNode.getTextContent();

    	    if ($isDecoratorNode(nextNode)) {
    	      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);

    	      if (decorator !== null) {
    	        reconcileDecorator(key, decorator);
    	      }
    	    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
    	      // Handle text content, for LTR, LTR cases.
    	      subTreeDirectionedTextContent += text;
    	    }

    	    subTreeTextContent += text;
    	    editorTextContent += text;
    	  }

    	  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    	    // Cache the latest text content.
    	    nextNode = nextNode.getWritable();
    	    nextNode.__cachedText = editorTextContent;
    	  }

    	  {
    	    // Freeze the node in DEV to prevent accidental mutations
    	    Object.freeze(nextNode);
    	  }

    	  return dom;
    	}

    	function reconcileDecorator(key, decorator) {
    	  let pendingDecorators = activeEditor$1._pendingDecorators;
    	  const currentDecorators = activeEditor$1._decorators;

    	  if (pendingDecorators === null) {
    	    if (currentDecorators[key] === decorator) {
    	      return;
    	    }

    	    pendingDecorators = cloneDecorators(activeEditor$1);
    	  }

    	  pendingDecorators[key] = decorator;
    	}

    	function getFirstChild(element) {
    	  return element.firstChild;
    	}

    	function getNextSibling(element) {
    	  let nextSibling = element.nextSibling;

    	  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
    	    nextSibling = nextSibling.nextSibling;
    	  }

    	  return nextSibling;
    	}

    	function reconcileNodeChildren(prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {
    	  const prevEndIndex = prevChildrenLength - 1;
    	  const nextEndIndex = nextChildrenLength - 1;
    	  let prevChildrenSet;
    	  let nextChildrenSet;
    	  let siblingDOM = getFirstChild(dom);
    	  let prevIndex = 0;
    	  let nextIndex = 0;

    	  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
    	    const prevKey = prevChildren[prevIndex];
    	    const nextKey = nextChildren[nextIndex];

    	    if (prevKey === nextKey) {
    	      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
    	      prevIndex++;
    	      nextIndex++;
    	    } else {
    	      if (prevChildrenSet === undefined) {
    	        prevChildrenSet = new Set(prevChildren);
    	      }

    	      if (nextChildrenSet === undefined) {
    	        nextChildrenSet = new Set(nextChildren);
    	      }

    	      const nextHasPrevKey = nextChildrenSet.has(prevKey);
    	      const prevHasNextKey = prevChildrenSet.has(nextKey);

    	      if (!nextHasPrevKey) {
    	        // Remove prev
    	        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
    	        destroyNode(prevKey, dom);
    	        prevIndex++;
    	      } else if (!prevHasNextKey) {
    	        // Create next
    	        createNode(nextKey, dom, siblingDOM);
    	        nextIndex++;
    	      } else {
    	        // Move next
    	        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);

    	        if (childDOM === siblingDOM) {
    	          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
    	        } else {
    	          if (siblingDOM != null) {
    	            dom.insertBefore(childDOM, siblingDOM);
    	          } else {
    	            dom.appendChild(childDOM);
    	          }

    	          reconcileNode(nextKey, dom);
    	        }

    	        prevIndex++;
    	        nextIndex++;
    	      }
    	    }
    	  }

    	  const appendNewChildren = prevIndex > prevEndIndex;
    	  const removeOldChildren = nextIndex > nextEndIndex;

    	  if (appendNewChildren && !removeOldChildren) {
    	    const previousNode = nextChildren[nextEndIndex + 1];
    	    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);
    	    createChildren(nextChildren, nextIndex, nextEndIndex, dom, insertDOM);
    	  } else if (removeOldChildren && !appendNewChildren) {
    	    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);
    	  }
    	}

    	function reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
    	  // We cache text content to make retrieval more efficient.
    	  // The cache must be rebuilt during reconciliation to account for any changes.
    	  subTreeTextContent = '';
    	  editorTextContent = '';
    	  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively
    	  // we instead set them as bindings within the scope of the module.

    	  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
    	  activeTextDirection = null;
    	  activeEditor$1 = editor;
    	  activeEditorConfig = editor._config;
    	  activeEditorNodes = editor._nodes;
    	  activeMutationListeners = activeEditor$1._listeners.mutation;
    	  activeDirtyElements = dirtyElements;
    	  activeDirtyLeaves = dirtyLeaves;
    	  activePrevNodeMap = prevEditorState._nodeMap;
    	  activeNextNodeMap = nextEditorState._nodeMap;
    	  activeEditorStateReadOnly = nextEditorState._readOnly;
    	  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation
    	  // listeners later in the update cycle.

    	  const currentMutatedNodes = new Map();
    	  mutatedNodes = currentMutatedNodes;
    	  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope
    	  // so instead we make it seem that these values are always set.
    	  // We also want to make sure we clear them down, otherwise we
    	  // can leak memory.
    	  // @ts-ignore

    	  activeEditor$1 = undefined; // @ts-ignore

    	  activeEditorNodes = undefined; // @ts-ignore

    	  activeDirtyElements = undefined; // @ts-ignore

    	  activeDirtyLeaves = undefined; // @ts-ignore

    	  activePrevNodeMap = undefined; // @ts-ignore

    	  activeNextNodeMap = undefined; // @ts-ignore

    	  activeEditorConfig = undefined; // @ts-ignore

    	  activePrevKeyToDOMMap = undefined; // @ts-ignore

    	  mutatedNodes = undefined;
    	  return currentMutatedNodes;
    	}
    	function storeDOMWithKey(key, dom, editor) {
    	  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.

    	  dom['__lexicalKey_' + editor._key] = key;
    	  keyToDOMMap.set(key, dom);
    	}

    	function getPrevElementByKeyOrThrow(key) {
    	  const element = activePrevKeyToDOMMap.get(key);

    	  if (element === undefined) {
    	    {
    	      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    	    }
    	  }

    	  return element;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const PASS_THROUGH_COMMAND = Object.freeze({});
    	const ANDROID_COMPOSITION_LATENCY = 30;
    	const rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];

    	if (CAN_USE_BEFORE_INPUT) {
    	  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);
    	}

    	let lastKeyDownTimeStamp = 0;
    	let lastKeyCode = 0;
    	let lastBeforeInputInsertTextTimeStamp = 0;
    	let rootElementsRegistered = 0;
    	let isSelectionChangeFromDOMUpdate = false;
    	let isSelectionChangeFromMouseDown = false;
    	let isInsertLineBreak = false;
    	let isFirefoxEndingComposition = false;
    	let collapsedSelectionFormat = [0, 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override
    	// the default browser behavior for insertion of text and use its own internal
    	// heuristics. This is an extremely important function, and makes much of Lexical
    	// work as intended between different browsers and across word, line and character
    	// boundary/formats. It also is important for text replacement, node schemas and
    	// composition mechanics.

    	function $shouldPreventDefaultAndInsertText(selection, text, timeStamp, isBeforeInput) {
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const anchorNode = anchor.getNode();
    	  const editor = getActiveEditor();
    	  const domSelection = getDOMSelection(editor._window);
    	  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
    	  const anchorKey = anchor.key;
    	  const backingAnchorElement = editor.getElementByKey(anchorKey);
    	  const textLength = text.length;
    	  return anchorKey !== focus.key || // If we're working with a non-text node.
    	  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
    	  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
    	  // a recent beforeinput event for "textInput". If there has been one in the last
    	  // 50ms then we proceed as normal. However, if there is not, then this is likely
    	  // a dangling `input` event caused by execCommand('insertText').
    	  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
    	  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
    	  // dealing with this in "beforeinput" or where the node has already recently
    	  // been changed (thus is dirty).
    	  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    	  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // Check if we're changing from bold to italics, or some other format.
    	  anchorNode.getFormat() !== selection.format || // One last set of heuristics to check against.
    	  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
    	}

    	function shouldSkipSelectionChange(domNode, offset) {
    	  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;
    	}

    	function onSelectionChange(domSelection, editor, isActive) {
    	  const {
    	    anchorNode: anchorDOM,
    	    anchorOffset,
    	    focusNode: focusDOM,
    	    focusOffset
    	  } = domSelection;

    	  if (isSelectionChangeFromDOMUpdate) {
    	    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then
    	    // we should continue as usual, as Lexical's selection
    	    // may have normalized to a better child. If the DOM
    	    // element is a text node, we can safely apply this
    	    // optimization and skip the selection change entirely.
    	    // We also need to check if the offset is at the boundary,
    	    // because in this case, we might need to normalize to a
    	    // sibling instead.

    	    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
    	      return;
    	    }
    	  }

    	  updateEditor(editor, () => {
    	    // Non-active editor don't need any extra logic for selection, it only needs update
    	    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.
    	    if (!isActive) {
    	      $setSelection(null);
    	      return;
    	    }

    	    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    	      return;
    	    }

    	    const selection = $getSelection(); // Update the selection format

    	    if ($isRangeSelection(selection)) {
    	      const anchor = selection.anchor;
    	      const anchorNode = anchor.getNode();

    	      if (selection.isCollapsed()) {
    	        // Badly interpreted range selection when collapsed - #1482
    	        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {
    	          selection.dirty = true;
    	        } // If we have marked a collapsed selection format, and we're
    	        // within the given time range – then attempt to use that format
    	        // instead of getting the format from the anchor node.


    	        const windowEvent = getWindow(editor).event;
    	        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
    	        const [lastFormat, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;

    	        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
    	          selection.format = lastFormat;
    	        } else {
    	          if (anchor.type === 'text') {
    	            selection.format = anchorNode.getFormat();
    	          } else if (anchor.type === 'element') {
    	            selection.format = 0;
    	          }
    	        }
    	      } else {
    	        let combinedFormat = IS_ALL_FORMATTING;
    	        let hasTextNodes = false;
    	        const nodes = selection.getNodes();
    	        const nodesLength = nodes.length;

    	        for (let i = 0; i < nodesLength; i++) {
    	          const node = nodes[i];

    	          if ($isTextNode(node)) {
    	            hasTextNodes = true;
    	            combinedFormat &= node.getFormat();

    	            if (combinedFormat === 0) {
    	              break;
    	            }
    	          }
    	        }

    	        selection.format = hasTextNodes ? combinedFormat : 0;
    	      }
    	    }

    	    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);
    	  });
    	} // This is a work-around is mainly Chrome specific bug where if you select
    	// the contents of an empty block, you cannot easily unselect anything.
    	// This results in a tiny selection box that looks buggy/broken. This can
    	// also help other browsers when selection might "appear" lost, when it
    	// really isn't.


    	function onClick(event, editor) {
    	  updateEditor(editor, () => {
    	    const selection = $getSelection();
    	    const domSelection = getDOMSelection(editor._window);
    	    const lastSelection = $getPreviousSelection();

    	    if ($isRangeSelection(selection)) {
    	      const anchor = selection.anchor;
    	      const anchorNode = anchor.getNode();

    	      if (domSelection && anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
    	        domSelection.removeAllRanges();
    	        selection.dirty = true;
    	      }
    	    }

    	    dispatchCommand(editor, CLICK_COMMAND, event);
    	  });
    	}

    	function onPointerDown(event, editor) {
    	  // TODO implement text drag & drop
    	  const target = event.target;
    	  const pointerType = event.pointerType;

    	  if (target instanceof Node && pointerType !== 'touch') {
    	    updateEditor(editor, () => {
    	      // Drag & drop should not recompute selection until mouse up; otherwise the initially
    	      // selected content is lost.
    	      if (!$isSelectionCapturedInDecorator(target)) {
    	        isSelectionChangeFromMouseDown = true;
    	      }
    	    });
    	  }
    	}

    	function $applyTargetRange(selection, event) {
    	  if (event.getTargetRanges) {
    	    const targetRange = event.getTargetRanges()[0];

    	    if (targetRange) {
    	      selection.applyDOMRange(targetRange);
    	    }
    	  }
    	}

    	function $canRemoveText(anchorNode, focusNode) {
    	  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
    	}

    	function isPossiblyAndroidKeyPress(timeStamp) {
    	  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
    	}

    	function onBeforeInput(event, editor) {
    	  const inputType = event.inputType; // We let the browser do its own thing for composition.

    	  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event
    	  // as the `paste` event should have triggered, unless the
    	  // user has dom.event.clipboardevents.enabled disabled in
    	  // about:config. In that case, we need to process the
    	  // pasted content in the DOM mutation phase.
    	  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    	    return;
    	  } else if (inputType === 'insertCompositionText') {
    	    return;
    	  }

    	  updateEditor(editor, () => {
    	    const selection = $getSelection();

    	    if (inputType === 'deleteContentBackward') {
    	      if (selection === null) {
    	        // Use previous selection
    	        const prevSelection = $getPreviousSelection();

    	        if (!$isRangeSelection(prevSelection)) {
    	          return;
    	        }

    	        $setSelection(prevSelection.clone());
    	      }

    	      if ($isRangeSelection(selection)) {
    	        // Used for handling backspace in Android.
    	        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {
    	          $setCompositionKey(null);
    	          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing

    	          setTimeout(() => {
    	            updateEditor(editor, () => {
    	              $setCompositionKey(null);
    	            });
    	          }, ANDROID_COMPOSITION_LATENCY);

    	          if ($isRangeSelection(selection)) {
    	            const anchorNode = selection.anchor.getNode();
    	            anchorNode.markDirty();
    	            selection.format = anchorNode.getFormat();
    	          }
    	        } else {
    	          event.preventDefault();
    	          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    	        }

    	        return;
    	      }
    	    }

    	    if (!$isRangeSelection(selection)) {
    	      return;
    	    }

    	    const data = event.data;

    	    if (!selection.dirty && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {
    	      $applyTargetRange(selection, event);
    	    }

    	    const anchor = selection.anchor;
    	    const focus = selection.focus;
    	    const anchorNode = anchor.getNode();
    	    const focusNode = focus.getNode();

    	    if (inputType === 'insertText' || inputType === 'insertTranspose') {
    	      if (data === '\n') {
    	        event.preventDefault();
    	        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
    	      } else if (data === DOUBLE_LINE_BREAK) {
    	        event.preventDefault();
    	        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);
    	      } else if (data == null && event.dataTransfer) {
    	        // Gets around a Safari text replacement bug.
    	        const text = event.dataTransfer.getData('text/plain');
    	        event.preventDefault();
    	        selection.insertRawText(text);
    	      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, true)) {
    	        event.preventDefault();
    	        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
    	      }

    	      lastBeforeInputInsertTextTimeStamp = event.timeStamp;
    	      return;
    	    } // Prevent the browser from carrying out
    	    // the input event, so we can control the
    	    // output.


    	    event.preventDefault();

    	    switch (inputType) {
    	      case 'insertFromYank':
    	      case 'insertFromDrop':
    	      case 'insertReplacementText':
    	        {
    	          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
    	          break;
    	        }

    	      case 'insertFromComposition':
    	        {
    	          // This is the end of composition
    	          $setCompositionKey(null);
    	          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
    	          break;
    	        }

    	      case 'insertLineBreak':
    	        {
    	          // Used for Android
    	          $setCompositionKey(null);
    	          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
    	          break;
    	        }

    	      case 'insertParagraph':
    	        {
    	          // Used for Android
    	          $setCompositionKey(null); // Some browsers do not provide the type "insertLineBreak".
    	          // So instead, we need to infer it from the keyboard event.

    	          if (isInsertLineBreak) {
    	            isInsertLineBreak = false;
    	            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
    	          } else {
    	            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);
    	          }

    	          break;
    	        }

    	      case 'insertFromPaste':
    	      case 'insertFromPasteAsQuotation':
    	        {
    	          dispatchCommand(editor, PASTE_COMMAND, event);
    	          break;
    	        }

    	      case 'deleteByComposition':
    	        {
    	          if ($canRemoveText(anchorNode, focusNode)) {
    	            dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);
    	          }

    	          break;
    	        }

    	      case 'deleteByDrag':
    	      case 'deleteByCut':
    	        {
    	          dispatchCommand(editor, REMOVE_TEXT_COMMAND, undefined);
    	          break;
    	        }

    	      case 'deleteContent':
    	        {
    	          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    	          break;
    	        }

    	      case 'deleteWordBackward':
    	        {
    	          dispatchCommand(editor, DELETE_WORD_COMMAND, true);
    	          break;
    	        }

    	      case 'deleteWordForward':
    	        {
    	          dispatchCommand(editor, DELETE_WORD_COMMAND, false);
    	          break;
    	        }

    	      case 'deleteHardLineBackward':
    	      case 'deleteSoftLineBackward':
    	        {
    	          dispatchCommand(editor, DELETE_LINE_COMMAND, true);
    	          break;
    	        }

    	      case 'deleteContentForward':
    	      case 'deleteHardLineForward':
    	      case 'deleteSoftLineForward':
    	        {
    	          dispatchCommand(editor, DELETE_LINE_COMMAND, false);
    	          break;
    	        }

    	      case 'formatStrikeThrough':
    	        {
    	          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');
    	          break;
    	        }

    	      case 'formatBold':
    	        {
    	          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');
    	          break;
    	        }

    	      case 'formatItalic':
    	        {
    	          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');
    	          break;
    	        }

    	      case 'formatUnderline':
    	        {
    	          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');
    	          break;
    	        }

    	      case 'historyUndo':
    	        {
    	          dispatchCommand(editor, UNDO_COMMAND, undefined);
    	          break;
    	        }

    	      case 'historyRedo':
    	        {
    	          dispatchCommand(editor, REDO_COMMAND, undefined);
    	          break;
    	        }

    	    }
    	  });
    	}

    	function onInput(event, editor) {
    	  // We don't want the onInput to bubble, in the case of nested editors.
    	  event.stopPropagation();
    	  updateEditor(editor, () => {
    	    const selection = $getSelection();
    	    const data = event.data;

    	    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, event.timeStamp, false)) {
    	      // Given we're over-riding the default behavior, we will need
    	      // to ensure to disable composition before dispatching the
    	      // insertText command for when changing the sequence for FF.
    	      if (isFirefoxEndingComposition) {
    	        onCompositionEndImpl(editor, data);
    	        isFirefoxEndingComposition = false;
    	      }

    	      const anchor = selection.anchor;
    	      const anchorNode = anchor.getNode();
    	      const domSelection = getDOMSelection(editor._window);

    	      if (domSelection === null) {
    	        return;
    	      }

    	      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.
    	      // Given onInput doesn't take the current selection (it uses the previous)
    	      // we can compare that against what the DOM currently says.

    	      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
    	        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
    	      }

    	      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still
    	      // open, even though compositionend has already fired (sigh).

    	      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {
    	        selection.anchor.offset -= textLength;
    	      } // This ensures consistency on Android.


    	      if (!IS_SAFARI && !IS_IOS && editor.isComposing()) {
    	        lastKeyDownTimeStamp = 0;
    	        $setCompositionKey(null);
    	      }
    	    } else {
    	      $updateSelectedTextFromDOM(false, editor); // onInput always fires after onCompositionEnd for FF.

    	      if (isFirefoxEndingComposition) {
    	        onCompositionEndImpl(editor, data || undefined);
    	        isFirefoxEndingComposition = false;
    	      }
    	    } // Also flush any other mutations that might have occurred
    	    // since the change.


    	    $flushMutations();
    	  });
    	}

    	function onCompositionStart(event, editor) {
    	  updateEditor(editor, () => {
    	    const selection = $getSelection();

    	    if ($isRangeSelection(selection) && !editor.isComposing()) {
    	      const anchor = selection.anchor;
    	      $setCompositionKey(anchor.key);

    	      if ( // If it has been 30ms since the last keydown, then we should
    	      // apply the empty space heuristic. We can't do this for Safari,
    	      // as the keydown fires after composition start.
    	      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
    	      // need to invoke the empty space heuristic below.
    	      anchor.type === 'element' || !selection.isCollapsed() || selection.anchor.getNode().getFormat() !== selection.format) {
    	        // We insert a zero width character, ready for the composition
    	        // to get inserted into the new node we create. If
    	        // we don't do this, Safari will fail on us because
    	        // there is no text node matching the selection.
    	        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
    	      }
    	    }
    	  });
    	}

    	function onCompositionEndImpl(editor, data) {
    	  const compositionKey = editor._compositionKey;
    	  $setCompositionKey(null); // Handle termination of composition.

    	  if (compositionKey !== null && data != null) {
    	    // Composition can sometimes move to an adjacent DOM node when backspacing.
    	    // So check for the empty case.
    	    if (data === '') {
    	      const node = $getNodeByKey(compositionKey);
    	      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));

    	      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
    	        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
    	      }

    	      return;
    	    } // Composition can sometimes be that of a new line. In which case, we need to
    	    // handle that accordingly.


    	    if (data[data.length - 1] === '\n') {
    	      const selection = $getSelection();

    	      if ($isRangeSelection(selection)) {
    	        // If the last character is a line break, we also need to insert
    	        // a line break.
    	        const focus = selection.focus;
    	        selection.anchor.set(focus.key, focus.offset, focus.type);
    	        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
    	        return;
    	      }
    	    }
    	  }

    	  $updateSelectedTextFromDOM(true, editor, data);
    	}

    	function onCompositionEnd(event, editor) {
    	  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,
    	  // fire onInput before onCompositionEnd. To ensure the sequence works
    	  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to
    	  // defer handling of onCompositionEnd in Firefox till we have processed
    	  // the logic in onInput.
    	  if (IS_FIREFOX) {
    	    isFirefoxEndingComposition = true;
    	  } else {
    	    updateEditor(editor, () => {
    	      onCompositionEndImpl(editor, event.data);
    	    });
    	  }
    	}

    	function onKeyDown(event, editor) {
    	  lastKeyDownTimeStamp = event.timeStamp;
    	  lastKeyCode = event.keyCode;

    	  if (editor.isComposing()) {
    	    return;
    	  }

    	  const {
    	    keyCode,
    	    shiftKey,
    	    ctrlKey,
    	    metaKey,
    	    altKey
    	  } = event;

    	  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {
    	    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
    	  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    	    dispatchCommand(editor, MOVE_TO_END, event);
    	  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {
    	    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
    	  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    	    dispatchCommand(editor, MOVE_TO_START, event);
    	  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {
    	    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
    	  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {
    	    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
    	  } else if (isLineBreak(keyCode, shiftKey)) {
    	    isInsertLineBreak = true;
    	    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
    	  } else if (isSpace(keyCode)) {
    	    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
    	  } else if (isOpenLineBreak(keyCode, ctrlKey)) {
    	    event.preventDefault();
    	    isInsertLineBreak = true;
    	    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
    	  } else if (isParagraph(keyCode, shiftKey)) {
    	    isInsertLineBreak = false;
    	    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
    	  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {
    	    if (isBackspace(keyCode)) {
    	      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    	    } else {
    	      event.preventDefault();
    	      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    	    }
    	  } else if (isEscape(keyCode)) {
    	    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
    	  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    	    if (isDelete(keyCode)) {
    	      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    	    } else {
    	      event.preventDefault();
    	      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    	    }
    	  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
    	  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
    	  } else if (isDeleteLineBackward(keyCode, metaKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
    	  } else if (isDeleteLineForward(keyCode, metaKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
    	  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');
    	  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');
    	  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');
    	  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {
    	    dispatchCommand(editor, KEY_TAB_COMMAND, event);
    	  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, UNDO_COMMAND, undefined);
    	  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {
    	    event.preventDefault();
    	    dispatchCommand(editor, REDO_COMMAND, undefined);
    	  } else {
    	    const prevSelection = editor._editorState._selection;

    	    if ($isNodeSelection(prevSelection)) {
    	      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {
    	        event.preventDefault();
    	        dispatchCommand(editor, COPY_COMMAND, event);
    	      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {
    	        event.preventDefault();
    	        dispatchCommand(editor, CUT_COMMAND, event);
    	      }
    	    }
    	  }

    	  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
    	    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
    	  }
    	}

    	function getRootElementRemoveHandles(rootElement) {
    	  // @ts-expect-error: internal field
    	  let eventHandles = rootElement.__lexicalEventHandles;

    	  if (eventHandles === undefined) {
    	    eventHandles = []; // @ts-expect-error: internal field

    	    rootElement.__lexicalEventHandles = eventHandles;
    	  }

    	  return eventHandles;
    	} // Mapping root editors to their active nested editors, contains nested editors
    	// mapping only, so if root editor is selected map will have no reference to free up memory


    	const activeNestedEditorsMap = new Map();

    	function onDocumentSelectionChange(event) {
    	  const target = event.target;
    	  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
    	  const domSelection = getDOMSelection(targetWindow);

    	  if (domSelection === null) {
    	    return;
    	  }

    	  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);

    	  if (nextActiveEditor === null) {
    	    return;
    	  }

    	  if (isSelectionChangeFromMouseDown) {
    	    isSelectionChangeFromMouseDown = false;
    	    updateEditor(nextActiveEditor, () => {
    	      const lastSelection = $getPreviousSelection();
    	      const domAnchorNode = domSelection.anchorNode;

    	      if (domAnchorNode === null) {
    	        return;
    	      }

    	      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then
    	      // we should attempt create a range selection.
    	      // When we click on an empty paragraph node or the end of a paragraph that ends
    	      // with an image/poll, the nodeType will be ELEMENT_NODE

    	      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {
    	        return;
    	      }

    	      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);
    	      $setSelection(newSelection);
    	    });
    	  } // When editor receives selection change event, we're checking if
    	  // it has any sibling editors (within same parent editor) that were active
    	  // before, and trigger selection change on it to nullify selection.


    	  const editors = getEditorsToPropagate(nextActiveEditor);
    	  const rootEditor = editors[editors.length - 1];
    	  const rootEditorKey = rootEditor._key;
    	  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
    	  const prevActiveEditor = activeNestedEditor || rootEditor;

    	  if (prevActiveEditor !== nextActiveEditor) {
    	    onSelectionChange(domSelection, prevActiveEditor, false);
    	  }

    	  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise

    	  if (nextActiveEditor !== rootEditor) {
    	    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
    	  } else if (activeNestedEditor) {
    	    activeNestedEditorsMap.delete(rootEditorKey);
    	  }
    	}

    	function stopLexicalPropagation(event) {
    	  // We attach a special property to ensure the same event doesn't re-fire
    	  // for parent editors.
    	  // @ts-ignore
    	  event._lexicalHandled = true;
    	}

    	function hasStoppedLexicalPropagation(event) {
    	  // @ts-ignore
    	  const stopped = event._lexicalHandled === true;
    	  return stopped;
    	}

    	function addRootElementEvents(rootElement, editor) {
    	  // We only want to have a single global selectionchange event handler, shared
    	  // between all editor instances.
    	  if (rootElementsRegistered === 0) {
    	    const doc = rootElement.ownerDocument;
    	    doc.addEventListener('selectionchange', onDocumentSelectionChange);
    	  }

    	  rootElementsRegistered++; // @ts-expect-error: internal field

    	  rootElement.__lexicalEditor = editor;
    	  const removeHandles = getRootElementRemoveHandles(rootElement);

    	  for (let i = 0; i < rootElementEvents.length; i++) {
    	    const [eventName, onEvent] = rootElementEvents[i];
    	    const eventHandler = typeof onEvent === 'function' ? event => {
    	      if (hasStoppedLexicalPropagation(event)) {
    	        return;
    	      }

    	      stopLexicalPropagation(event);

    	      if (editor.isEditable()) {
    	        onEvent(event, editor);
    	      }
    	    } : event => {
    	      if (hasStoppedLexicalPropagation(event)) {
    	        return;
    	      }

    	      stopLexicalPropagation(event);

    	      if (editor.isEditable()) {
    	        switch (eventName) {
    	          case 'cut':
    	            return dispatchCommand(editor, CUT_COMMAND, event);

    	          case 'copy':
    	            return dispatchCommand(editor, COPY_COMMAND, event);

    	          case 'paste':
    	            return dispatchCommand(editor, PASTE_COMMAND, event);

    	          case 'dragstart':
    	            return dispatchCommand(editor, DRAGSTART_COMMAND, event);

    	          case 'dragover':
    	            return dispatchCommand(editor, DRAGOVER_COMMAND, event);

    	          case 'dragend':
    	            return dispatchCommand(editor, DRAGEND_COMMAND, event);

    	          case 'focus':
    	            return dispatchCommand(editor, FOCUS_COMMAND, event);

    	          case 'blur':
    	            {
    	              return dispatchCommand(editor, BLUR_COMMAND, event);
    	            }

    	          case 'drop':
    	            return dispatchCommand(editor, DROP_COMMAND, event);
    	        }
    	      }
    	    };
    	    rootElement.addEventListener(eventName, eventHandler);
    	    removeHandles.push(() => {
    	      rootElement.removeEventListener(eventName, eventHandler);
    	    });
    	  }
    	}
    	function removeRootElementEvents(rootElement) {
    	  if (rootElementsRegistered !== 0) {
    	    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared
    	    // between all editor instances.

    	    if (rootElementsRegistered === 0) {
    	      const doc = rootElement.ownerDocument;
    	      doc.removeEventListener('selectionchange', onDocumentSelectionChange);
    	    }
    	  } // @ts-expect-error: internal field


    	  const editor = rootElement.__lexicalEditor;

    	  if (editor !== null && editor !== undefined) {
    	    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field

    	    rootElement.__lexicalEditor = null;
    	  }

    	  const removeHandles = getRootElementRemoveHandles(rootElement);

    	  for (let i = 0; i < removeHandles.length; i++) {
    	    removeHandles[i]();
    	  } // @ts-expect-error: internal field


    	  rootElement.__lexicalEventHandles = [];
    	}

    	function cleanActiveNestedEditorsMap(editor) {
    	  if (editor._parentEditor !== null) {
    	    // For nested editor cleanup map if this editor was marked as active
    	    const editors = getEditorsToPropagate(editor);
    	    const rootEditor = editors[editors.length - 1];
    	    const rootEditorKey = rootEditor._key;

    	    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
    	      activeNestedEditorsMap.delete(rootEditorKey);
    	    }
    	  } else {
    	    // For top-level editors cleanup map
    	    activeNestedEditorsMap.delete(editor._key);
    	  }
    	}

    	function markSelectionChangeFromDOMUpdate() {
    	  isSelectionChangeFromDOMUpdate = true;
    	}
    	function markCollapsedSelectionFormat(format, offset, key, timeStamp) {
    	  collapsedSelectionFormat = [format, offset, key, timeStamp];
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	class Point {
    	  constructor(key, offset, type) {
    	    this._selection = null;
    	    this.key = key;
    	    this.offset = offset;
    	    this.type = type;
    	  }

    	  is(point) {
    	    return this.key === point.key && this.offset === point.offset && this.type === point.type;
    	  }

    	  isBefore(b) {
    	    let aNode = this.getNode();
    	    let bNode = b.getNode();
    	    const aOffset = this.offset;
    	    const bOffset = b.offset;

    	    if ($isElementNode(aNode)) {
    	      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
    	      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
    	    }

    	    if ($isElementNode(bNode)) {
    	      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
    	      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
    	    }

    	    if (aNode === bNode) {
    	      return aOffset < bOffset;
    	    }

    	    return aNode.isBefore(bNode);
    	  }

    	  getNode() {
    	    const key = this.key;
    	    const node = $getNodeByKey(key);

    	    if (node === null) {
    	      {
    	        throw Error(`Point.getNode: node not found`);
    	      }
    	    }

    	    return node;
    	  }

    	  set(key, offset, type) {
    	    const selection = this._selection;
    	    const oldKey = this.key;
    	    this.key = key;
    	    this.offset = offset;
    	    this.type = type;

    	    if (!isCurrentlyReadOnlyMode()) {
    	      if ($getCompositionKey() === oldKey) {
    	        $setCompositionKey(key);
    	      }

    	      if (selection !== null) {
    	        selection._cachedNodes = null;
    	        selection.dirty = true;
    	      }
    	    }
    	  }

    	}

    	function $createPoint(key, offset, type) {
    	  // @ts-expect-error: intentionally cast as we use a class for perf reasons
    	  return new Point(key, offset, type);
    	}

    	function selectPointOnNode(point, node) {
    	  let key = node.__key;
    	  let offset = point.offset;
    	  let type = 'element';

    	  if ($isTextNode(node)) {
    	    type = 'text';
    	    const textContentLength = node.getTextContentSize();

    	    if (offset > textContentLength) {
    	      offset = textContentLength;
    	    }
    	  } else if (!$isElementNode(node)) {
    	    const nextSibling = node.getNextSibling();

    	    if ($isTextNode(nextSibling)) {
    	      key = nextSibling.__key;
    	      offset = 0;
    	      type = 'text';
    	    } else {
    	      const parentNode = node.getParent();

    	      if (parentNode) {
    	        key = parentNode.__key;
    	        offset = node.getIndexWithinParent() + 1;
    	      }
    	    }
    	  }

    	  point.set(key, offset, type);
    	}

    	function $moveSelectionPointToEnd(point, node) {
    	  if ($isElementNode(node)) {
    	    const lastNode = node.getLastDescendant();

    	    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
    	      selectPointOnNode(point, lastNode);
    	    } else {
    	      selectPointOnNode(point, node);
    	    }
    	  } else {
    	    selectPointOnNode(point, node);
    	  }
    	}

    	function $transferStartingElementPointToTextPoint(start, end, format) {
    	  const element = start.getNode();
    	  const placementNode = element.getChildAtIndex(start.offset);
    	  const textNode = $createTextNode();
    	  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
    	  textNode.setFormat(format);

    	  if (placementNode === null) {
    	    element.append(target);
    	  } else {
    	    placementNode.insertBefore(target);
    	  } // Transfer the element point to a text point.


    	  if (start.is(end)) {
    	    end.set(textNode.__key, 0, 'text');
    	  }

    	  start.set(textNode.__key, 0, 'text');
    	}

    	function $setPointValues(point, key, offset, type) {
    	  point.key = key;
    	  point.offset = offset;
    	  point.type = type;
    	}

    	class NodeSelection {
    	  constructor(objects) {
    	    this.dirty = false;
    	    this._nodes = objects;
    	    this._cachedNodes = null;
    	  }

    	  is(selection) {
    	    if (!$isNodeSelection(selection)) {
    	      return false;
    	    }

    	    const a = this._nodes;
    	    const b = selection._nodes;
    	    return a.size === b.size && Array.from(a).every(key => b.has(key));
    	  }

    	  add(key) {
    	    this.dirty = true;

    	    this._nodes.add(key);

    	    this._cachedNodes = null;
    	  }

    	  delete(key) {
    	    this.dirty = true;

    	    this._nodes.delete(key);

    	    this._cachedNodes = null;
    	  }

    	  clear() {
    	    this.dirty = true;

    	    this._nodes.clear();

    	    this._cachedNodes = null;
    	  }

    	  has(key) {
    	    return this._nodes.has(key);
    	  }

    	  clone() {
    	    return new NodeSelection(new Set(this._nodes));
    	  }

    	  extract() {
    	    return this.getNodes();
    	  }

    	  insertRawText(text) {// Do nothing?
    	  }

    	  insertText() {// Do nothing?
    	  }

    	  insertNodes(nodes, selectStart) {
    	    const selectedNodes = this.getNodes();
    	    const selectedNodesLength = selectedNodes.length;
    	    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
    	    let selectionAtEnd; // Insert nodes

    	    if ($isTextNode(lastSelectedNode)) {
    	      selectionAtEnd = lastSelectedNode.select();
    	    } else {
    	      const index = lastSelectedNode.getIndexWithinParent() + 1;
    	      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
    	    }

    	    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes

    	    for (let i = 0; i < selectedNodesLength; i++) {
    	      selectedNodes[i].remove();
    	    }

    	    return true;
    	  }

    	  getNodes() {
    	    const cachedNodes = this._cachedNodes;

    	    if (cachedNodes !== null) {
    	      return cachedNodes;
    	    }

    	    const objects = this._nodes;
    	    const nodes = [];

    	    for (const object of objects) {
    	      const node = $getNodeByKey(object);

    	      if (node !== null) {
    	        nodes.push(node);
    	      }
    	    }

    	    if (!isCurrentlyReadOnlyMode()) {
    	      this._cachedNodes = nodes;
    	    }

    	    return nodes;
    	  }

    	  getTextContent() {
    	    const nodes = this.getNodes();
    	    let textContent = '';

    	    for (let i = 0; i < nodes.length; i++) {
    	      textContent += nodes[i].getTextContent();
    	    }

    	    return textContent;
    	  }

    	}
    	function $isRangeSelection(x) {
    	  return x instanceof RangeSelection;
    	}
    	class GridSelection {
    	  constructor(gridKey, anchor, focus) {
    	    this.gridKey = gridKey;
    	    this.anchor = anchor;
    	    this.focus = focus;
    	    this.dirty = false;
    	    this._cachedNodes = null;
    	    anchor._selection = this;
    	    focus._selection = this;
    	  }

    	  is(selection) {
    	    if (!DEPRECATED_$isGridSelection(selection)) {
    	      return false;
    	    }

    	    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
    	  }

    	  set(gridKey, anchorCellKey, focusCellKey) {
    	    this.dirty = true;
    	    this.gridKey = gridKey;
    	    this.anchor.key = anchorCellKey;
    	    this.focus.key = focusCellKey;
    	    this._cachedNodes = null;
    	  }

    	  clone() {
    	    return new GridSelection(this.gridKey, this.anchor, this.focus);
    	  }

    	  isCollapsed() {
    	    return false;
    	  }

    	  isBackward() {
    	    return this.focus.isBefore(this.anchor);
    	  }

    	  getCharacterOffsets() {
    	    return getCharacterOffsets(this);
    	  }

    	  extract() {
    	    return this.getNodes();
    	  }

    	  insertRawText(text) {// Do nothing?
    	  }

    	  insertText() {// Do nothing?
    	  }

    	  insertNodes(nodes, selectStart) {
    	    const focusNode = this.focus.getNode();
    	    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));
    	    return selection.insertNodes(nodes, selectStart);
    	  }

    	  getShape() {
    	    const anchorCellNode = $getNodeByKey(this.anchor.key);

    	    if (!(anchorCellNode !== null)) {
    	      throw Error(`getNodes: expected to find AnchorNode`);
    	    }

    	    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();
    	    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();
    	    const focusCellNode = $getNodeByKey(this.focus.key);

    	    if (!(focusCellNode !== null)) {
    	      throw Error(`getNodes: expected to find FocusNode`);
    	    }

    	    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();
    	    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();
    	    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);
    	    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);
    	    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);
    	    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);
    	    return {
    	      fromX: Math.min(startX, stopX),
    	      fromY: Math.min(startY, stopY),
    	      toX: Math.max(startX, stopX),
    	      toY: Math.max(startY, stopY)
    	    };
    	  }

    	  getNodes() {
    	    const cachedNodes = this._cachedNodes;

    	    if (cachedNodes !== null) {
    	      return cachedNodes;
    	    }

    	    const nodesSet = new Set();
    	    const {
    	      fromX,
    	      fromY,
    	      toX,
    	      toY
    	    } = this.getShape();
    	    const gridNode = $getNodeByKey(this.gridKey);

    	    if (!DEPRECATED_$isGridNode(gridNode)) {
    	      {
    	        throw Error(`getNodes: expected to find GridNode`);
    	      }
    	    }

    	    nodesSet.add(gridNode);
    	    const gridRowNodes = gridNode.getChildren();

    	    for (let r = fromY; r <= toY; r++) {
    	      const gridRowNode = gridRowNodes[r];
    	      nodesSet.add(gridRowNode);

    	      if (!DEPRECATED_$isGridRowNode(gridRowNode)) {
    	        {
    	          throw Error(`getNodes: expected to find GridRowNode`);
    	        }
    	      }

    	      const gridCellNodes = gridRowNode.getChildren();

    	      for (let c = fromX; c <= toX; c++) {
    	        const gridCellNode = gridCellNodes[c];

    	        if (!DEPRECATED_$isGridCellNode(gridCellNode)) {
    	          {
    	            throw Error(`getNodes: expected to find GridCellNode`);
    	          }
    	        }

    	        nodesSet.add(gridCellNode);
    	        const children = gridCellNode.getChildren();

    	        while (children.length > 0) {
    	          const child = children.shift();
    	          nodesSet.add(child);

    	          if ($isElementNode(child)) {
    	            children.unshift(...child.getChildren());
    	          }
    	        }
    	      }
    	    }

    	    const nodes = Array.from(nodesSet);

    	    if (!isCurrentlyReadOnlyMode()) {
    	      this._cachedNodes = nodes;
    	    }

    	    return nodes;
    	  }

    	  getTextContent() {
    	    const nodes = this.getNodes();
    	    let textContent = '';

    	    for (let i = 0; i < nodes.length; i++) {
    	      textContent += nodes[i].getTextContent();
    	    }

    	    return textContent;
    	  }

    	}
    	function DEPRECATED_$isGridSelection(x) {
    	  return x instanceof GridSelection;
    	}
    	class RangeSelection {
    	  constructor(anchor, focus, format) {
    	    this.anchor = anchor;
    	    this.focus = focus;
    	    this.dirty = false;
    	    this.format = format;
    	    this._cachedNodes = null;
    	    anchor._selection = this;
    	    focus._selection = this;
    	  }

    	  is(selection) {
    	    if (!$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format;
    	  }

    	  isBackward() {
    	    return this.focus.isBefore(this.anchor);
    	  }

    	  isCollapsed() {
    	    return this.anchor.is(this.focus);
    	  }

    	  getNodes() {
    	    const cachedNodes = this._cachedNodes;

    	    if (cachedNodes !== null) {
    	      return cachedNodes;
    	    }

    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    let firstNode = anchor.getNode();
    	    let lastNode = focus.getNode();

    	    if ($isElementNode(firstNode)) {
    	      const firstNodeDescendant = firstNode.getDescendantByIndex(anchor.offset);
    	      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
    	    }

    	    if ($isElementNode(lastNode)) {
    	      const lastNodeDescendant = lastNode.getDescendantByIndex(focus.offset);
    	      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
    	    }

    	    let nodes;

    	    if (firstNode.is(lastNode)) {
    	      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {
    	        nodes = [];
    	      } else {
    	        nodes = [firstNode];
    	      }
    	    } else {
    	      nodes = firstNode.getNodesBetween(lastNode);
    	    }

    	    if (!isCurrentlyReadOnlyMode()) {
    	      this._cachedNodes = nodes;
    	    }

    	    return nodes;
    	  }

    	  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
    	    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');
    	    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');
    	    this._cachedNodes = null;
    	    this.dirty = true;
    	  }

    	  getTextContent() {
    	    const nodes = this.getNodes();

    	    if (nodes.length === 0) {
    	      return '';
    	    }

    	    const firstNode = nodes[0];
    	    const lastNode = nodes[nodes.length - 1];
    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    const isBefore = anchor.isBefore(focus);
    	    const [anchorOffset, focusOffset] = getCharacterOffsets(this);
    	    let textContent = '';
    	    let prevWasElement = true;

    	    for (let i = 0; i < nodes.length; i++) {
    	      const node = nodes[i];

    	      if ($isElementNode(node) && !node.isInline()) {
    	        if (!prevWasElement) {
    	          textContent += '\n';
    	        }

    	        if (node.isEmpty()) {
    	          prevWasElement = false;
    	        } else {
    	          prevWasElement = true;
    	        }
    	      } else {
    	        prevWasElement = false;

    	        if ($isTextNode(node)) {
    	          let text = node.getTextContent();

    	          if (node === firstNode) {
    	            if (node === lastNode) {
    	              text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
    	            } else {
    	              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
    	            }
    	          } else if (node === lastNode) {
    	            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
    	          }

    	          textContent += text;
    	        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
    	          textContent += node.getTextContent();
    	        }
    	      }
    	    }

    	    return textContent;
    	  }

    	  applyDOMRange(range) {
    	    const editor = getActiveEditor();
    	    const currentEditorState = editor.getEditorState();
    	    const lastSelection = currentEditorState._selection;
    	    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);

    	    if (resolvedSelectionPoints === null) {
    	      return;
    	    }

    	    const [anchorPoint, focusPoint] = resolvedSelectionPoints;
    	    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
    	    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
    	    this._cachedNodes = null;
    	  }

    	  clone() {
    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format);
    	    return selection;
    	  }

    	  toggleFormat(format) {
    	    this.format = toggleTextFormatType(this.format, format, null);
    	    this.dirty = true;
    	  }

    	  hasFormat(type) {
    	    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    	    return (this.format & formatFlag) !== 0;
    	  }

    	  insertRawText(text) {
    	    const parts = text.split(/\r?\n/);

    	    if (parts.length === 1) {
    	      this.insertText(text);
    	    } else {
    	      const nodes = [];
    	      const length = parts.length;

    	      for (let i = 0; i < length; i++) {
    	        const part = parts[i];

    	        if (part !== '') {
    	          nodes.push($createTextNode(part));
    	        }

    	        if (i !== length - 1) {
    	          nodes.push($createLineBreakNode());
    	        }
    	      }

    	      this.insertNodes(nodes);
    	    }
    	  }

    	  insertText(text) {
    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    const isBefore = this.isCollapsed() || anchor.isBefore(focus);
    	    const format = this.format;

    	    if (isBefore && anchor.type === 'element') {
    	      $transferStartingElementPointToTextPoint(anchor, focus, format);
    	    } else if (!isBefore && focus.type === 'element') {
    	      $transferStartingElementPointToTextPoint(focus, anchor, format);
    	    }

    	    const selectedNodes = this.getNodes();
    	    const selectedNodesLength = selectedNodes.length;
    	    const firstPoint = isBefore ? anchor : focus;
    	    const endPoint = isBefore ? focus : anchor;
    	    const startOffset = firstPoint.offset;
    	    const endOffset = endPoint.offset;
    	    let firstNode = selectedNodes[0];

    	    if (!$isTextNode(firstNode)) {
    	      {
    	        throw Error(`insertText: first node is not a text node`);
    	      }
    	    }

    	    const firstNodeText = firstNode.getTextContent();
    	    const firstNodeTextLength = firstNodeText.length;
    	    const firstNodeParent = firstNode.getParentOrThrow();
    	    const lastIndex = selectedNodesLength - 1;
    	    let lastNode = selectedNodes[lastIndex];

    	    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
    	      let nextSibling = firstNode.getNextSibling();

    	      if (!$isTextNode(nextSibling) || $isTokenOrSegmented(nextSibling)) {
    	        nextSibling = $createTextNode();
    	        nextSibling.setFormat(format);

    	        if (!firstNodeParent.canInsertTextAfter()) {
    	          firstNodeParent.insertAfter(nextSibling);
    	        } else {
    	          firstNode.insertAfter(nextSibling);
    	        }
    	      }

    	      nextSibling.select(0, 0);
    	      firstNode = nextSibling;

    	      if (text !== '') {
    	        this.insertText(text);
    	        return;
    	      }
    	    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
    	      let prevSibling = firstNode.getPreviousSibling();

    	      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
    	        prevSibling = $createTextNode();
    	        prevSibling.setFormat(format);

    	        if (!firstNodeParent.canInsertTextBefore()) {
    	          firstNodeParent.insertBefore(prevSibling);
    	        } else {
    	          firstNode.insertBefore(prevSibling);
    	        }
    	      }

    	      prevSibling.select();
    	      firstNode = prevSibling;

    	      if (text !== '') {
    	        this.insertText(text);
    	        return;
    	      }
    	    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
    	      const textNode = $createTextNode(firstNode.getTextContent());
    	      textNode.setFormat(format);
    	      firstNode.replace(textNode);
    	      firstNode = textNode;
    	    } else if (!this.isCollapsed() && text !== '') {
    	      // When the firstNode or lastNode parents are elements that
    	      // do not allow text to be inserted before or after, we first
    	      // clear the content. Then we normalize selection, then insert
    	      // the new content.
    	      const lastNodeParent = lastNode.getParent();

    	      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
    	        this.insertText('');
    	        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
    	        this.insertText(text);
    	        return;
    	      }
    	    }

    	    if (selectedNodesLength === 1) {
    	      if (firstNode.isToken()) {
    	        const textNode = $createTextNode(text);
    	        textNode.select();
    	        firstNode.replace(textNode);
    	        return;
    	      }

    	      const firstNodeFormat = firstNode.getFormat();

    	      if (startOffset === endOffset && firstNodeFormat !== format) {
    	        if (firstNode.getTextContent() === '') {
    	          firstNode.setFormat(format);
    	        } else {
    	          const textNode = $createTextNode(text);
    	          textNode.setFormat(format);
    	          textNode.select();

    	          if (startOffset === 0) {
    	            firstNode.insertBefore(textNode, false);
    	          } else {
    	            const [targetNode] = firstNode.splitText(startOffset);
    	            targetNode.insertAfter(textNode, false);
    	          } // When composing, we need to adjust the anchor offset so that
    	          // we correctly replace that right range.


    	          if (textNode.isComposing() && this.anchor.type === 'text') {
    	            this.anchor.offset -= text.length;
    	          }

    	          return;
    	        }
    	      }

    	      const delCount = endOffset - startOffset;
    	      firstNode = firstNode.spliceText(startOffset, delCount, text, true);

    	      if (firstNode.getTextContent() === '') {
    	        firstNode.remove();
    	      } else if (this.anchor.type === 'text') {
    	        if (firstNode.isComposing()) {
    	          // When composing, we need to adjust the anchor offset so that
    	          // we correctly replace that right range.
    	          this.anchor.offset -= text.length;
    	        } else {
    	          this.format = firstNodeFormat;
    	        }
    	      }
    	    } else {
    	      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,
    	      // as in that section we might mutate the lastNode.

    	      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
    	      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
    	      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting
    	      // the nodes of its parent, rather than itself. This behavior will
    	      // then better match how text node insertions work. We will need to
    	      // also update the last element's child accordingly as we do this.

    	      if (!firstElement.is(lastElement) && lastElement.isInline()) {
    	        // Keep traversing till we have a non-inline element parent.
    	        do {
    	          lastElementChild = lastElement;
    	          lastElement = lastElement.getParentOrThrow();
    	        } while (lastElement.isInline());
    	      } // Handle mutations to the last node.


    	      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {
    	        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
    	          if (lastNode.isSegmented()) {
    	            const textNode = $createTextNode(lastNode.getTextContent());
    	            lastNode.replace(textNode);
    	            lastNode = textNode;
    	          }

    	          lastNode = lastNode.spliceText(0, endOffset, '');
    	          markedNodeKeysForKeep.add(lastNode.__key);
    	        } else {
    	          const lastNodeParent = lastNode.getParentOrThrow();

    	          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
    	            lastNodeParent.remove();
    	          } else {
    	            lastNode.remove();
    	          }
    	        }
    	      } else {
    	        markedNodeKeysForKeep.add(lastNode.__key);
    	      } // Either move the remaining nodes of the last parent to after
    	      // the first child, or remove them entirely. If the last parent
    	      // is the same as the first parent, this logic also works.


    	      const lastNodeChildren = lastElement.getChildren();
    	      const selectedNodesSet = new Set(selectedNodes);
    	      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having
    	      // and inline starting parent element with a starting node that has no
    	      // siblings, we should insert after the starting parent element, otherwise
    	      // we will incorrectly merge into the starting parent element.
    	      // TODO: should we keep on traversing parents if we're inside another
    	      // nested inline element?

    	      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;

    	      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {
    	        const lastNodeChild = lastNodeChildren[i];

    	        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
    	          break;
    	        }

    	        if (lastNodeChild.isAttached()) {
    	          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
    	            if (!firstAndLastElementsAreEqual) {
    	              insertionTarget.insertAfter(lastNodeChild, false);
    	            }
    	          } else {
    	            lastNodeChild.remove();
    	          }
    	        }
    	      }

    	      if (!firstAndLastElementsAreEqual) {
    	        // Check if we have already moved out all the nodes of the
    	        // last parent, and if so, traverse the parent tree and mark
    	        // them all as being able to deleted too.
    	        let parent = lastElement;
    	        let lastRemovedParent = null;

    	        while (parent !== null) {
    	          const children = parent.getChildren();
    	          const childrenLength = children.length;

    	          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
    	            markedNodeKeysForKeep.delete(parent.__key);
    	            lastRemovedParent = parent;
    	          }

    	          parent = parent.getParent();
    	        }
    	      } // Ensure we do splicing after moving of nodes, as splicing
    	      // can have side-effects (in the case of hashtags).


    	      if (!firstNode.isToken()) {
    	        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);

    	        if (firstNode.getTextContent() === '') {
    	          firstNode.remove();
    	        } else if (firstNode.isComposing() && this.anchor.type === 'text') {
    	          // When composing, we need to adjust the anchor offset so that
    	          // we correctly replace that right range.
    	          this.anchor.offset -= text.length;
    	        }
    	      } else if (startOffset === firstNodeTextLength) {
    	        firstNode.select();
    	      } else {
    	        const textNode = $createTextNode(text);
    	        textNode.select();
    	        firstNode.replace(textNode);
    	      } // Remove all selected nodes that haven't already been removed.


    	      for (let i = 1; i < selectedNodesLength; i++) {
    	        const selectedNode = selectedNodes[i];
    	        const key = selectedNode.__key;

    	        if (!markedNodeKeysForKeep.has(key)) {
    	          selectedNode.remove();
    	        }
    	      }
    	    }
    	  }

    	  removeText() {
    	    this.insertText('');
    	  }

    	  formatText(formatType) {
    	    if (this.isCollapsed()) {
    	      this.toggleFormat(formatType); // When changing format, we should stop composition

    	      $setCompositionKey(null);
    	      return;
    	    }

    	    const selectedNodes = this.getNodes();
    	    const selectedTextNodes = [];

    	    for (const selectedNode of selectedNodes) {
    	      if ($isTextNode(selectedNode)) {
    	        selectedTextNodes.push(selectedNode);
    	      }
    	    }

    	    const selectedTextNodesLength = selectedTextNodes.length;

    	    if (selectedTextNodesLength === 0) {
    	      this.toggleFormat(formatType); // When changing format, we should stop composition

    	      $setCompositionKey(null);
    	      return;
    	    }

    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    const isBackward = this.isBackward();
    	    const startPoint = isBackward ? focus : anchor;
    	    const endPoint = isBackward ? anchor : focus;
    	    let firstIndex = 0;
    	    let firstNode = selectedTextNodes[0];
    	    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node

    	    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {
    	      firstIndex = 1;
    	      firstNode = selectedTextNodes[1];
    	      startOffset = 0;
    	    }

    	    if (firstNode == null) {
    	      return;
    	    }

    	    const firstNextFormat = firstNode.getFormatFlags(formatType, null);
    	    const lastIndex = selectedTextNodesLength - 1;
    	    let lastNode = selectedTextNodes[lastIndex];
    	    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected

    	    if (firstNode.is(lastNode)) {
    	      // No actual text is selected, so do nothing.
    	      if (startOffset === endOffset) {
    	        return;
    	      } // The entire node is selected, so just format it


    	      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
    	        firstNode.setFormat(firstNextFormat);
    	      } else {
    	        // Node is partially selected, so split it into two nodes
    	        // add style the selected one.
    	        const splitNodes = firstNode.splitText(startOffset, endOffset);
    	        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
    	        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node

    	        if (startPoint.type === 'text') {
    	          startPoint.set(replacement.__key, 0, 'text');
    	        }

    	        if (endPoint.type === 'text') {
    	          endPoint.set(replacement.__key, endOffset - startOffset, 'text');
    	        }
    	      }

    	      this.format = firstNextFormat;
    	      return;
    	    } // Multiple nodes selected
    	    // The entire first node isn't selected, so split it


    	    if (startOffset !== 0) {
    	      [, firstNode] = firstNode.splitText(startOffset);
    	      startOffset = 0;
    	    }

    	    firstNode.setFormat(firstNextFormat);
    	    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,
    	    // so we skip formatting the last node altogether.

    	    if (endOffset > 0) {
    	      if (endOffset !== lastNode.getTextContentSize()) {
    	        [lastNode] = lastNode.splitText(endOffset);
    	      }

    	      lastNode.setFormat(lastNextFormat);
    	    } // Process all text nodes in between


    	    for (let i = firstIndex + 1; i < lastIndex; i++) {
    	      const textNode = selectedTextNodes[i];

    	      if (!textNode.isToken()) {
    	        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
    	        textNode.setFormat(nextFormat);
    	      }
    	    } // Update selection only if starts/ends on text node


    	    if (startPoint.type === 'text') {
    	      startPoint.set(firstNode.__key, startOffset, 'text');
    	    }

    	    if (endPoint.type === 'text') {
    	      endPoint.set(lastNode.__key, endOffset, 'text');
    	    }

    	    this.format = firstNextFormat | lastNextFormat;
    	  }

    	  insertNodes(nodes, selectStart) {
    	    // If there is a range selected remove the text in it
    	    if (!this.isCollapsed()) {
    	      const selectionEnd = this.isBackward() ? this.anchor : this.focus;
    	      const nextSibling = selectionEnd.getNode().getNextSibling();
    	      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;
    	      const prevSibling = selectionEnd.getNode().getPreviousSibling();
    	      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;
    	      this.removeText(); // If the selection has been moved to an adjacent inline element, create
    	      // a temporary text node that we can insert the nodes after.

    	      if (this.isCollapsed() && this.focus.type === 'element') {
    	        let textNode;

    	        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {
    	          textNode = $createTextNode();
    	          this.focus.getNode().insertBefore(textNode);
    	        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {
    	          textNode = $createTextNode();
    	          this.focus.getNode().insertAfter(textNode);
    	        }

    	        if (textNode) {
    	          this.focus.set(textNode.__key, 0, 'text');
    	          this.anchor.set(textNode.__key, 0, 'text');
    	        }
    	      }
    	    }

    	    const anchor = this.anchor;
    	    const anchorOffset = anchor.offset;
    	    const anchorNode = anchor.getNode();
    	    let target = anchorNode;

    	    if (anchor.type === 'element') {
    	      const element = anchor.getNode();
    	      const placementNode = element.getChildAtIndex(anchorOffset - 1);

    	      if (placementNode === null) {
    	        target = element;
    	      } else {
    	        target = placementNode;
    	      }
    	    }

    	    const siblings = []; // Get all remaining text node siblings in this element so we can
    	    // append them after the last node we're inserting.

    	    const nextSiblings = anchorNode.getNextSiblings();
    	    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();

    	    if ($isTextNode(anchorNode)) {
    	      const textContent = anchorNode.getTextContent();
    	      const textContentLength = textContent.length;

    	      if (anchorOffset === 0 && textContentLength !== 0) {
    	        const prevSibling = anchorNode.getPreviousSibling();

    	        if (prevSibling !== null) {
    	          target = prevSibling;
    	        } else {
    	          target = anchorNode.getParentOrThrow();
    	        }

    	        siblings.push(anchorNode);
    	      } else if (anchorOffset === textContentLength) {
    	        target = anchorNode;
    	      } else if (anchorNode.isToken()) {
    	        // Do nothing if we're inside a token node
    	        return false;
    	      } else {
    	        // If we started with a range selected grab the danglingText after the
    	        // end of the selection and put it on our siblings array so we can
    	        // append it after the last node we're inserting
    	        let danglingText;
    	        [target, danglingText] = anchorNode.splitText(anchorOffset);
    	        siblings.push(danglingText);
    	      }
    	    }

    	    const startingNode = target;
    	    siblings.push(...nextSiblings);
    	    const firstNode = nodes[0];
    	    let didReplaceOrMerge = false;
    	    let lastNode = null; // Time to insert the nodes!

    	    for (let i = 0; i < nodes.length; i++) {
    	      const node = nodes[i];

    	      if (!$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {
    	        // -----
    	        // Heuristics for the replacement or merging of elements
    	        // -----
    	        // If we have an incoming element node as the first node, then we'll need
    	        // see if we can merge any descendant leaf nodes into our existing target.
    	        // We can do this by finding the first descendant in our node and then we can
    	        // pluck it and its parent (siblings included) out and insert them directly
    	        // into our target. We only do this for the first node, as we are only
    	        // interested in merging with the anchor, which is our target.
    	        //
    	        // If we apply either the replacement or merging heuristics, we need to be
    	        // careful that we're not trying to insert a non-element node into a root node,
    	        // so we check if the target's parent after this logic is the root node and if
    	        // so we trigger an invariant to ensure this problem is caught in development
    	        // and fixed accordingly.
    	        if (node.is(firstNode)) {
    	          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {
    	            target.replace(node);
    	            target = node;
    	            didReplaceOrMerge = true;
    	            continue;
    	          } // We may have a node tree where there are many levels, for example with
    	          // lists and tables. So let's find the first descendant to try and merge
    	          // with. So if we have the target:
    	          //
    	          // Paragraph (1)
    	          //   Text (2)
    	          //
    	          // and we are trying to insert:
    	          //
    	          // ListNode (3)
    	          //   ListItemNode (4)
    	          //     Text (5)
    	          //   ListItemNode (6)
    	          //
    	          // The result would be:
    	          //
    	          // Paragraph (1)
    	          //   Text (2)
    	          //   Text (5)
    	          //


    	          const firstDescendant = node.getFirstDescendant();

    	          if ($isLeafNode(firstDescendant)) {
    	            let element = firstDescendant.getParentOrThrow();

    	            while (element.isInline()) {
    	              element = element.getParentOrThrow();
    	            }

    	            const children = element.getChildren();
    	            const childrenLength = children.length;

    	            if ($isElementNode(target)) {
    	              let firstChild = target.getFirstChild();

    	              for (let s = 0; s < childrenLength; s++) {
    	                const child = children[s];

    	                if (firstChild === null) {
    	                  target.append(child);
    	                } else {
    	                  firstChild.insertAfter(child);
    	                }

    	                firstChild = child;
    	              }
    	            } else {
    	              for (let s = childrenLength - 1; s >= 0; s--) {
    	                target.insertAfter(children[s]);
    	              }

    	              target = target.getParentOrThrow();
    	            }

    	            lastNode = children[childrenLength - 1];
    	            element.remove();
    	            didReplaceOrMerge = true;

    	            if (element.is(node)) {
    	              continue;
    	            }
    	          }
    	        }

    	        if ($isTextNode(target)) {
    	          if (topLevelElement === null) {
    	            {
    	              throw Error(`insertNode: topLevelElement is root node`);
    	            }
    	          }

    	          target = topLevelElement;
    	        }
    	      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {
    	        {
    	          throw Error(`insertNodes: cannot insert a non-element into a root node`);
    	        }
    	      }

    	      didReplaceOrMerge = false;

    	      if ($isElementNode(target) && !target.isInline()) {
    	        lastNode = node;

    	        if ($isDecoratorNode(node) && !node.isInline()) {
    	          target = target.insertAfter(node, false);
    	        } else if (!$isElementNode(node)) {
    	          const firstChild = target.getFirstChild();

    	          if (firstChild !== null) {
    	            firstChild.insertBefore(node);
    	          } else {
    	            target.append(node);
    	          }

    	          target = node;
    	        } else {
    	          if (!node.canBeEmpty() && node.isEmpty()) {
    	            continue;
    	          }

    	          if ($isRootNode(target)) {
    	            const placementNode = target.getChildAtIndex(anchorOffset);

    	            if (placementNode !== null) {
    	              placementNode.insertBefore(node);
    	            } else {
    	              target.append(node);
    	            }

    	            target = node;
    	          } else {
    	            target = target.insertAfter(node, false);
    	          }
    	        }
    	      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {
    	        lastNode = node;
    	        target = target.insertAfter(node, false);
    	      } else {
    	        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent
    	        // and remove the LineBreak so we don't have empty space.

    	        if ($isLineBreakNode(target)) {
    	          target.remove();
    	        }

    	        target = nextTarget; // Re-try again with the target being the parent

    	        i--;
    	        continue;
    	      }
    	    }

    	    if (selectStart) {
    	      // Handle moving selection to start for all nodes
    	      if ($isTextNode(startingNode)) {
    	        startingNode.select();
    	      } else {
    	        const prevSibling = target.getPreviousSibling();

    	        if ($isTextNode(prevSibling)) {
    	          prevSibling.select();
    	        } else {
    	          const index = target.getIndexWithinParent();
    	          target.getParentOrThrow().select(index, index);
    	        }
    	      }
    	    }

    	    if ($isElementNode(target)) {
    	      // If the last node to be inserted was a text node,
    	      // then we should attempt to move selection to that.
    	      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();

    	      if (!selectStart) {
    	        // Handle moving selection to end for elements
    	        if (lastChild === null) {
    	          target.select();
    	        } else if ($isTextNode(lastChild)) {
    	          if (lastChild.getTextContent() === '') {
    	            lastChild.selectPrevious();
    	          } else {
    	            lastChild.select();
    	          }
    	        } else {
    	          lastChild.selectNext();
    	        }
    	      }

    	      if (siblings.length !== 0) {
    	        const originalTarget = target;

    	        for (let i = siblings.length - 1; i >= 0; i--) {
    	          const sibling = siblings[i];
    	          const prevParent = sibling.getParentOrThrow();

    	          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && ( // Note: We are only looking for decorators that are inline and not isolated.
    	          !sibling.isInline() || sibling.isIsolated()))) {
    	            if (originalTarget === target) {
    	              target.append(sibling);
    	            } else {
    	              target.insertBefore(sibling);
    	            }

    	            target = sibling;
    	          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {
    	            target.insertBefore(sibling);
    	            target = sibling;
    	          } else {
    	            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {
    	              // @ts-ignore The clone method does exist on the constructor.
    	              const prevParentClone = prevParent.constructor.clone(prevParent);

    	              if (!$isElementNode(prevParentClone)) {
    	                {
    	                  throw Error(`insertNodes: cloned parent clone is not an element`);
    	                }
    	              }

    	              prevParentClone.append(sibling);
    	              target.insertAfter(prevParentClone);
    	            } else {
    	              target.insertAfter(sibling);
    	            }
    	          } // Check if the prev parent is empty, as it might need
    	          // removing.


    	          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {
    	            prevParent.remove();
    	          }
    	        }
    	      }
    	    } else if (!selectStart) {
    	      // Handle moving selection to end for other nodes
    	      if ($isTextNode(target)) {
    	        target.select();
    	      } else {
    	        const element = target.getParentOrThrow();
    	        const index = target.getIndexWithinParent() + 1;
    	        element.select(index, index);
    	      }
    	    }

    	    return true;
    	  }

    	  insertParagraph() {
    	    if (!this.isCollapsed()) {
    	      this.removeText();
    	    }

    	    const anchor = this.anchor;
    	    const anchorOffset = anchor.offset;
    	    let currentElement;
    	    let nodesToMove = [];
    	    let siblingsToMove = [];

    	    if (anchor.type === 'text') {
    	      const anchorNode = anchor.getNode();
    	      nodesToMove = anchorNode.getNextSiblings().reverse();
    	      currentElement = anchorNode.getParentOrThrow();
    	      const isInline = currentElement.isInline();
    	      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();

    	      if (anchorOffset === 0) {
    	        nodesToMove.push(anchorNode);
    	      } else {
    	        if (isInline) {
    	          // For inline nodes, we want to move all the siblings to the new paragraph
    	          // if selection is at the end, we just move the siblings. Otherwise, we also
    	          // split the text node and add that and it's siblings below.
    	          siblingsToMove = currentElement.getNextSiblings();
    	        }

    	        if (anchorOffset !== textContentLength) {
    	          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {
    	            const [, splitNode] = anchorNode.splitText(anchorOffset);
    	            nodesToMove.push(splitNode);
    	          }
    	        }
    	      }
    	    } else {
    	      currentElement = anchor.getNode();

    	      if ($isRootOrShadowRoot(currentElement)) {
    	        const paragraph = $createParagraphNode();
    	        const child = currentElement.getChildAtIndex(anchorOffset);
    	        paragraph.select();

    	        if (child !== null) {
    	          child.insertBefore(paragraph, false);
    	        } else {
    	          currentElement.append(paragraph);
    	        }

    	        return;
    	      }

    	      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();
    	    }

    	    const nodesToMoveLength = nodesToMove.length;

    	    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {
    	      const parent = currentElement.getParentOrThrow();
    	      const newElement = parent.insertNewAfter(this, false);

    	      if ($isElementNode(newElement)) {
    	        const children = parent.getChildren();

    	        for (let i = 0; i < children.length; i++) {
    	          newElement.append(children[i]);
    	        }
    	      }

    	      return;
    	    }

    	    const newElement = currentElement.insertNewAfter(this, false);

    	    if (newElement === null) {
    	      // Handle as a line break insertion
    	      this.insertLineBreak();
    	    } else if ($isElementNode(newElement)) {
    	      // If we're at the beginning of the current element, move the new element to be before the current element
    	      const currentElementFirstChild = currentElement.getFirstChild();
    	      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));

    	      if (isBeginning && nodesToMoveLength > 0) {
    	        currentElement.insertBefore(newElement);
    	        return;
    	      }

    	      let firstChild = null;
    	      const siblingsToMoveLength = siblingsToMove.length;
    	      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.

    	      if (siblingsToMoveLength > 0) {
    	        for (let i = 0; i < siblingsToMoveLength; i++) {
    	          const siblingToMove = siblingsToMove[i];
    	          parent.append(siblingToMove);
    	        }
    	      }

    	      if (nodesToMoveLength !== 0) {
    	        for (let i = 0; i < nodesToMoveLength; i++) {
    	          const nodeToMove = nodesToMove[i];

    	          if (firstChild === null) {
    	            newElement.append(nodeToMove);
    	          } else {
    	            firstChild.insertBefore(nodeToMove);
    	          }

    	          firstChild = nodeToMove;
    	        }
    	      }

    	      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {
    	        newElement.selectPrevious();
    	        newElement.remove();
    	      } else {
    	        newElement.selectStart();
    	      }
    	    }
    	  }

    	  insertLineBreak(selectStart) {
    	    const lineBreakNode = $createLineBreakNode();
    	    const anchor = this.anchor;

    	    if (anchor.type === 'element') {
    	      const element = anchor.getNode();

    	      if ($isRootNode(element)) {
    	        this.insertParagraph();
    	      }
    	    }

    	    if (selectStart) {
    	      this.insertNodes([lineBreakNode], true);
    	    } else {
    	      if (this.insertNodes([lineBreakNode])) {
    	        lineBreakNode.selectNext(0, 0);
    	      }
    	    }
    	  }

    	  getCharacterOffsets() {
    	    return getCharacterOffsets(this);
    	  }

    	  extract() {
    	    const selectedNodes = this.getNodes();
    	    const selectedNodesLength = selectedNodes.length;
    	    const lastIndex = selectedNodesLength - 1;
    	    const anchor = this.anchor;
    	    const focus = this.focus;
    	    let firstNode = selectedNodes[0];
    	    let lastNode = selectedNodes[lastIndex];
    	    const [anchorOffset, focusOffset] = getCharacterOffsets(this);

    	    if (selectedNodesLength === 0) {
    	      return [];
    	    } else if (selectedNodesLength === 1) {
    	      if ($isTextNode(firstNode) && !this.isCollapsed()) {
    	        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
    	        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
    	        const splitNodes = firstNode.splitText(startOffset, endOffset);
    	        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
    	        return node != null ? [node] : [];
    	      }

    	      return [firstNode];
    	    }

    	    const isBefore = anchor.isBefore(focus);

    	    if ($isTextNode(firstNode)) {
    	      const startOffset = isBefore ? anchorOffset : focusOffset;

    	      if (startOffset === firstNode.getTextContentSize()) {
    	        selectedNodes.shift();
    	      } else if (startOffset !== 0) {
    	        [, firstNode] = firstNode.splitText(startOffset);
    	        selectedNodes[0] = firstNode;
    	      }
    	    }

    	    if ($isTextNode(lastNode)) {
    	      const lastNodeText = lastNode.getTextContent();
    	      const lastNodeTextLength = lastNodeText.length;
    	      const endOffset = isBefore ? focusOffset : anchorOffset;

    	      if (endOffset === 0) {
    	        selectedNodes.pop();
    	      } else if (endOffset !== lastNodeTextLength) {
    	        [lastNode] = lastNode.splitText(endOffset);
    	        selectedNodes[lastIndex] = lastNode;
    	      }
    	    }

    	    return selectedNodes;
    	  }

    	  modify(alter, isBackward, granularity) {
    	    const focus = this.focus;
    	    const anchor = this.anchor;
    	    const collapse = alter === 'move'; // Handle the selection movement around decorators.

    	    const possibleNode = $getAdjacentNode(focus, isBackward);

    	    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
    	      // Make it possible to move selection from range selection to
    	      // node selection on the node.
    	      if (collapse && possibleNode.isKeyboardSelectable()) {
    	        const nodeSelection = $createNodeSelection();
    	        nodeSelection.add(possibleNode.__key);
    	        $setSelection(nodeSelection);
    	        return;
    	      }

    	      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();

    	      if (!$isTextNode(sibling)) {
    	        const parent = possibleNode.getParentOrThrow();
    	        let offset;
    	        let elementKey;

    	        if ($isElementNode(sibling)) {
    	          elementKey = sibling.__key;
    	          offset = isBackward ? sibling.getChildrenSize() : 0;
    	        } else {
    	          offset = possibleNode.getIndexWithinParent();
    	          elementKey = parent.__key;

    	          if (!isBackward) {
    	            offset++;
    	          }
    	        }

    	        focus.set(elementKey, offset, 'element');

    	        if (collapse) {
    	          anchor.set(elementKey, offset, 'element');
    	        }

    	        return;
    	      } else {
    	        const siblingKey = sibling.__key;
    	        const offset = isBackward ? sibling.getTextContent().length : 0;
    	        focus.set(siblingKey, offset, 'text');

    	        if (collapse) {
    	          anchor.set(siblingKey, offset, 'text');
    	        }

    	        return;
    	      }
    	    }

    	    const editor = getActiveEditor();
    	    const domSelection = getDOMSelection(editor._window);

    	    if (!domSelection) {
    	      return;
    	    }

    	    const blockCursorElement = editor._blockCursorElement;
    	    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection
    	    // works as intended. If we leave it in the DOM all sorts of strange bugs
    	    // occur. :/

    	    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
    	      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    	    } // We use the DOM selection.modify API here to "tell" us what the selection
    	    // will be. We then use it to update the Lexical selection accordingly. This
    	    // is much more reliable than waiting for a beforeinput and using the ranges
    	    // from getTargetRanges(), and is also better than trying to do it ourselves
    	    // using Intl.Segmenter or other workarounds that struggle with word segments
    	    // and line segments (especially with word wrapping and non-Roman languages).


    	    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges

    	    if (domSelection.rangeCount > 0) {
    	      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.

    	      const anchorNode = this.anchor.getNode();
    	      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
    	      this.applyDOMRange(range);
    	      this.dirty = true;

    	      if (!collapse) {
    	        // Validate selection; make sure that the new extended selection respects shadow roots
    	        const nodes = this.getNodes();
    	        const validNodes = [];
    	        let shrinkSelection = false;

    	        for (let i = 0; i < nodes.length; i++) {
    	          const nextNode = nodes[i];

    	          if ($hasAncestor(nextNode, root)) {
    	            validNodes.push(nextNode);
    	          } else {
    	            shrinkSelection = true;
    	          }
    	        }

    	        if (shrinkSelection && validNodes.length > 0) {
    	          // validNodes length check is a safeguard against an invalid selection; as getNodes()
    	          // will return an empty array in this case
    	          if (isBackward) {
    	            const firstValidNode = validNodes[0];

    	            if ($isElementNode(firstValidNode)) {
    	              firstValidNode.selectStart();
    	            } else {
    	              firstValidNode.getParentOrThrow().selectStart();
    	            }
    	          } else {
    	            const lastValidNode = validNodes[validNodes.length - 1];

    	            if ($isElementNode(lastValidNode)) {
    	              lastValidNode.selectEnd();
    	            } else {
    	              lastValidNode.getParentOrThrow().selectEnd();
    	            }
    	          }
    	        } // Because a range works on start and end, we might need to flip
    	        // the anchor and focus points to match what the DOM has, not what
    	        // the range has specifically.


    	        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
    	          $swapPoints(this);
    	        }
    	      }
    	    }
    	  }

    	  deleteCharacter(isBackward) {
    	    if (this.isCollapsed()) {
    	      const anchor = this.anchor;
    	      const focus = this.focus;
    	      let anchorNode = anchor.getNode();

    	      if (!isBackward && ( // Delete forward handle case
    	      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {
    	        const parent = anchorNode.getParent();
    	        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());

    	        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {
    	          return;
    	        }
    	      } // Handle the deletion around decorators.


    	      const possibleNode = $getAdjacentNode(focus, isBackward);

    	      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
    	        // Make it possible to move selection from range selection to
    	        // node selection on the node.
    	        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {
    	          anchorNode.remove();
    	          const nodeSelection = $createNodeSelection();
    	          nodeSelection.add(possibleNode.__key);
    	          $setSelection(nodeSelection);
    	        } else {
    	          possibleNode.remove();
    	        }

    	        return;
    	      }

    	      this.modify('extend', isBackward, 'character');

    	      if (!this.isCollapsed()) {
    	        const focusNode = focus.type === 'text' ? focus.getNode() : null;
    	        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;

    	        if (focusNode !== null && focusNode.isSegmented()) {
    	          const offset = focus.offset;
    	          const textContentSize = focusNode.getTextContentSize();

    	          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
    	            $removeSegment(focusNode, isBackward, offset);
    	            return;
    	          }
    	        } else if (anchorNode !== null && anchorNode.isSegmented()) {
    	          const offset = anchor.offset;
    	          const textContentSize = anchorNode.getTextContentSize();

    	          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
    	            $removeSegment(anchorNode, isBackward, offset);
    	            return;
    	          }
    	        }

    	        $updateCaretSelectionForUnicodeCharacter(this, isBackward);
    	      } else if (isBackward && anchor.offset === 0) {
    	        // Special handling around rich text nodes
    	        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();

    	        if (element.collapseAtStart(this)) {
    	          return;
    	        }
    	      }
    	    }

    	    this.removeText();
    	  }

    	  deleteLine(isBackward) {
    	    if (this.isCollapsed()) {
    	      if (this.anchor.type === 'text') {
    	        this.modify('extend', isBackward, 'lineboundary');
    	      } // If selection is extended to cover text edge then extend it one character more
    	      // to delete its parent element. Otherwise text content will be deleted but empty
    	      // parent node will remain


    	      const endPoint = isBackward ? this.focus : this.anchor;

    	      if (endPoint.offset === 0) {
    	        this.modify('extend', isBackward, 'character');
    	      }
    	    }

    	    this.removeText();
    	  }

    	  deleteWord(isBackward) {
    	    if (this.isCollapsed()) {
    	      this.modify('extend', isBackward, 'word');
    	    }

    	    this.removeText();
    	  }

    	}
    	function $isNodeSelection(x) {
    	  return x instanceof NodeSelection;
    	}

    	function getCharacterOffset(point) {
    	  const offset = point.offset;

    	  if (point.type === 'text') {
    	    return offset;
    	  }

    	  const parent = point.getNode();
    	  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
    	}

    	function getCharacterOffsets(selection) {
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;

    	  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {
    	    return [0, 0];
    	  }

    	  return [getCharacterOffset(anchor), getCharacterOffset(focus)];
    	}

    	function $swapPoints(selection) {
    	  const focus = selection.focus;
    	  const anchor = selection.anchor;
    	  const anchorKey = anchor.key;
    	  const anchorOffset = anchor.offset;
    	  const anchorType = anchor.type;
    	  $setPointValues(anchor, focus.key, focus.offset, focus.type);
    	  $setPointValues(focus, anchorKey, anchorOffset, anchorType);
    	  selection._cachedNodes = null;
    	}

    	function moveNativeSelection(domSelection, alter, direction, granularity) {
    	  // @ts-expect-error Selection.modify() method applies a change to the current selection or cursor position,
    	  // but is still non-standard in some browsers.
    	  domSelection.modify(alter, direction, granularity);
    	}

    	function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();

    	  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {
    	    // Handling of multibyte characters
    	    const anchorOffset = anchor.offset;
    	    const focusOffset = focus.offset;
    	    const isBefore = anchorOffset < focusOffset;
    	    const startOffset = isBefore ? anchorOffset : focusOffset;
    	    const endOffset = isBefore ? focusOffset : anchorOffset;
    	    const characterOffset = endOffset - 1;

    	    if (startOffset !== characterOffset) {
    	      const text = anchorNode.getTextContent().slice(startOffset, endOffset);

    	      if (!doesContainGrapheme(text)) {
    	        if (isBackward) {
    	          focus.offset = characterOffset;
    	        } else {
    	          anchor.offset = characterOffset;
    	        }
    	      }
    	    }
    	  }
    	}

    	function $removeSegment(node, isBackward, offset) {
    	  const textNode = node;
    	  const textContent = textNode.getTextContent();
    	  const split = textContent.split(/(?=\s)/g);
    	  const splitLength = split.length;
    	  let segmentOffset = 0;
    	  let restoreOffset = 0;

    	  for (let i = 0; i < splitLength; i++) {
    	    const text = split[i];
    	    const isLast = i === splitLength - 1;
    	    restoreOffset = segmentOffset;
    	    segmentOffset += text.length;

    	    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
    	      split.splice(i, 1);

    	      if (isLast) {
    	        restoreOffset = undefined;
    	      }

    	      break;
    	    }
    	  }

    	  const nextTextContent = split.join('').trim();

    	  if (nextTextContent === '') {
    	    textNode.remove();
    	  } else {
    	    textNode.setTextContent(nextTextContent);
    	    textNode.select(restoreOffset, restoreOffset);
    	  }
    	}

    	function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
    	  const parent = resolvedElement.getParent();
    	  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
    	}

    	function internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
    	  let resolvedOffset = offset;
    	  let resolvedNode; // If we have selection on an element, we will
    	  // need to figure out (using the offset) what text
    	  // node should be selected.

    	  if (dom.nodeType === DOM_ELEMENT_TYPE) {
    	    // Resolve element to a ElementNode, or TextNode, or null
    	    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is
    	    // definitely dirty.
    	    // We use the anchor to find which child node to select

    	    const childNodes = dom.childNodes;
    	    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we
    	    // need to select the very last text node.

    	    if (resolvedOffset === childNodesLength) {
    	      moveSelectionToEnd = true;
    	      resolvedOffset = childNodesLength - 1;
    	    }

    	    let childDOM = childNodes[resolvedOffset];
    	    let hasBlockCursor = false;

    	    if (childDOM === editor._blockCursorElement) {
    	      childDOM = childNodes[resolvedOffset + 1];
    	      hasBlockCursor = true;
    	    } else if (editor._blockCursorElement !== null) {
    	      resolvedOffset--;
    	    }

    	    resolvedNode = getNodeFromDOM(childDOM);

    	    if ($isTextNode(resolvedNode)) {
    	      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
    	    } else {
    	      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.

    	      if (resolvedElement === null) {
    	        return null;
    	      }

    	      if ($isElementNode(resolvedElement)) {
    	        let child = resolvedElement.getChildAtIndex(resolvedOffset);

    	        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
    	          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();

    	          if (descendant === null) {
    	            resolvedElement = child;
    	            resolvedOffset = 0;
    	          } else {
    	            child = descendant;
    	            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
    	          }
    	        }

    	        if ($isTextNode(child)) {
    	          resolvedNode = child;
    	          resolvedElement = null;
    	          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
    	        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
    	          resolvedOffset++;
    	        }
    	      } else {
    	        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,
    	        // and instead we should be checking if we're using the offset

    	        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {
    	          resolvedOffset = index;
    	        } else {
    	          resolvedOffset = index + 1;
    	        }

    	        resolvedElement = resolvedElement.getParentOrThrow();
    	      }

    	      if ($isElementNode(resolvedElement)) {
    	        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');
    	      }
    	    }
    	  } else {
    	    // TextNode or null
    	    resolvedNode = getNodeFromDOM(dom);
    	  }

    	  if (!$isTextNode(resolvedNode)) {
    	    return null;
    	  }

    	  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');
    	}

    	function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
    	  const offset = point.offset;
    	  const node = point.getNode();

    	  if (offset === 0) {
    	    const prevSibling = node.getPreviousSibling();
    	    const parent = node.getParent();

    	    if (!isBackward) {
    	      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
    	        point.key = prevSibling.__key;
    	        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional

    	        point.type = 'element';
    	      } else if ($isTextNode(prevSibling)) {
    	        point.key = prevSibling.__key;
    	        point.offset = prevSibling.getTextContent().length;
    	      }
    	    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
    	      const parentSibling = parent.getPreviousSibling();

    	      if ($isTextNode(parentSibling)) {
    	        point.key = parentSibling.__key;
    	        point.offset = parentSibling.getTextContent().length;
    	      }
    	    }
    	  } else if (offset === node.getTextContent().length) {
    	    const nextSibling = node.getNextSibling();
    	    const parent = node.getParent();

    	    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
    	      point.key = nextSibling.__key;
    	      point.offset = 0; // @ts-expect-error: intentional

    	      point.type = 'element';
    	    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
    	      const parentSibling = parent.getNextSibling();

    	      if ($isTextNode(parentSibling)) {
    	        point.key = parentSibling.__key;
    	        point.offset = 0;
    	      }
    	    }
    	  }
    	}

    	function normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
    	  if (anchor.type === 'text' && focus.type === 'text') {
    	    const isBackward = anchor.isBefore(focus);
    	    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the
    	    // start of a text node and the sibling is a text node or inline element.

    	    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    	    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);

    	    if (isCollapsed) {
    	      focus.key = anchor.key;
    	      focus.offset = anchor.offset;
    	      focus.type = anchor.type;
    	    }

    	    const editor = getActiveEditor();

    	    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
    	      const lastAnchor = lastSelection.anchor;
    	      const lastFocus = lastSelection.focus;
    	      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
    	      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);
    	    }
    	  }
    	}

    	function internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
    	  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    	    return null;
    	  }

    	  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);

    	  if (resolvedAnchorPoint === null) {
    	    return null;
    	  }

    	  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);

    	  if (resolvedFocusPoint === null) {
    	    return null;
    	  }

    	  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {
    	    const anchorNode = getNodeFromDOM(anchorDOM);
    	    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we
    	    // return null for this point, as it's not in the controlled scope
    	    // of Lexical.

    	    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
    	      return null;
    	    }
    	  } // Handle normalization of selection when it is at the boundaries.


    	  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
    	  return [resolvedAnchorPoint, resolvedFocusPoint];
    	}

    	function $isBlockElementNode(node) {
    	  return $isElementNode(node) && !node.isInline();
    	} // This is used to make a selection when the existing
    	// selection is null, i.e. forcing selection on the editor
    	// when it current exists outside the editor.


    	function internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
    	  const editorState = getActiveEditorState();
    	  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0);
    	  selection.dirty = true;
    	  editorState._selection = selection;
    	  return selection;
    	}
    	function $createRangeSelection() {
    	  const anchor = $createPoint('root', 0, 'element');
    	  const focus = $createPoint('root', 0, 'element');
    	  return new RangeSelection(anchor, focus, 0);
    	}
    	function $createNodeSelection() {
    	  return new NodeSelection(new Set());
    	}
    	function DEPRECATED_$createGridSelection() {
    	  const anchor = $createPoint('root', 0, 'element');
    	  const focus = $createPoint('root', 0, 'element');
    	  return new GridSelection('root', anchor, focus);
    	}
    	function internalCreateSelection(editor) {
    	  const currentEditorState = editor.getEditorState();
    	  const lastSelection = currentEditorState._selection;
    	  const domSelection = getDOMSelection(editor._window);

    	  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {
    	    return lastSelection.clone();
    	  }

    	  return internalCreateRangeSelection(lastSelection, domSelection, editor);
    	}
    	function internalCreateRangeSelection(lastSelection, domSelection, editor) {
    	  const windowObj = editor._window;

    	  if (windowObj === null) {
    	    return null;
    	  } // When we create a selection, we try to use the previous
    	  // selection where possible, unless an actual user selection
    	  // change has occurred. When we do need to create a new selection
    	  // we validate we can have text nodes for both anchor and focus
    	  // nodes. If that holds true, we then return that selection
    	  // as a mutable object that we use for the editor state for this
    	  // update cycle. If a selection gets changed, and requires a
    	  // update to native DOM selection, it gets marked as "dirty".
    	  // If the selection changes, but matches with the existing
    	  // DOM selection, then we only need to sync it. Otherwise,
    	  // we generally bail out of doing an update to selection during
    	  // reconciliation unless there are dirty nodes that need
    	  // reconciling.


    	  const windowEvent = windowObj.event;
    	  const eventType = windowEvent ? windowEvent.type : undefined;
    	  const isSelectionChange = eventType === 'selectionchange';
    	  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);
    	  let anchorDOM, focusDOM, anchorOffset, focusOffset;

    	  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    	    if (domSelection === null) {
    	      return null;
    	    }

    	    anchorDOM = domSelection.anchorNode;
    	    focusDOM = domSelection.focusNode;
    	    anchorOffset = domSelection.anchorOffset;
    	    focusOffset = domSelection.focusOffset;

    	    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    	      return lastSelection.clone();
    	    }
    	  } else {
    	    return lastSelection.clone();
    	  } // Let's resolve the text nodes from the offsets and DOM nodes we have from
    	  // native selection.


    	  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);

    	  if (resolvedSelectionPoints === null) {
    	    return null;
    	  }

    	  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
    	  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format);
    	}
    	function $getSelection() {
    	  const editorState = getActiveEditorState();
    	  return editorState._selection;
    	}
    	function $getPreviousSelection() {
    	  const editor = getActiveEditor();
    	  return editor._editorState._selection;
    	}
    	function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();

    	  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    	    return;
    	  }

    	  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it

    	  if (selection.isCollapsed()) {
    	    const selectionOffset = anchor.offset;

    	    if (nodeOffset <= selectionOffset) {
    	      const newSelectionOffset = Math.max(0, selectionOffset + times);
    	      anchor.set(parentKey, newSelectionOffset, 'element');
    	      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them

    	      $updateSelectionResolveTextNodes(selection);
    	    }

    	    return;
    	  } // Multiple nodes selected. We shift or redimension selection


    	  const isBackward = selection.isBackward();
    	  const firstPoint = isBackward ? focus : anchor;
    	  const firstPointNode = firstPoint.getNode();
    	  const lastPoint = isBackward ? anchor : focus;
    	  const lastPointNode = lastPoint.getNode();

    	  if (parentNode.is(firstPointNode)) {
    	    const firstPointOffset = firstPoint.offset;

    	    if (nodeOffset <= firstPointOffset) {
    	      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');
    	    }
    	  }

    	  if (parentNode.is(lastPointNode)) {
    	    const lastPointOffset = lastPoint.offset;

    	    if (nodeOffset <= lastPointOffset) {
    	      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');
    	    }
    	  } // The new selection might point to text nodes, try to resolve them


    	  $updateSelectionResolveTextNodes(selection);
    	}

    	function $updateSelectionResolveTextNodes(selection) {
    	  const anchor = selection.anchor;
    	  const anchorOffset = anchor.offset;
    	  const focus = selection.focus;
    	  const focusOffset = focus.offset;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();

    	  if (selection.isCollapsed()) {
    	    if (!$isElementNode(anchorNode)) {
    	      return;
    	    }

    	    const childSize = anchorNode.getChildrenSize();
    	    const anchorOffsetAtEnd = anchorOffset >= childSize;
    	    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);

    	    if ($isTextNode(child)) {
    	      let newOffset = 0;

    	      if (anchorOffsetAtEnd) {
    	        newOffset = child.getTextContentSize();
    	      }

    	      anchor.set(child.__key, newOffset, 'text');
    	      focus.set(child.__key, newOffset, 'text');
    	    }

    	    return;
    	  }

    	  if ($isElementNode(anchorNode)) {
    	    const childSize = anchorNode.getChildrenSize();
    	    const anchorOffsetAtEnd = anchorOffset >= childSize;
    	    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);

    	    if ($isTextNode(child)) {
    	      let newOffset = 0;

    	      if (anchorOffsetAtEnd) {
    	        newOffset = child.getTextContentSize();
    	      }

    	      anchor.set(child.__key, newOffset, 'text');
    	    }
    	  }

    	  if ($isElementNode(focusNode)) {
    	    const childSize = focusNode.getChildrenSize();
    	    const focusOffsetAtEnd = focusOffset >= childSize;
    	    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);

    	    if ($isTextNode(child)) {
    	      let newOffset = 0;

    	      if (focusOffsetAtEnd) {
    	        newOffset = child.getTextContentSize();
    	      }

    	      focus.set(child.__key, newOffset, 'text');
    	    }
    	  }
    	}

    	function applySelectionTransforms(nextEditorState, editor) {
    	  const prevEditorState = editor.getEditorState();
    	  const prevSelection = prevEditorState._selection;
    	  const nextSelection = nextEditorState._selection;

    	  if ($isRangeSelection(nextSelection)) {
    	    const anchor = nextSelection.anchor;
    	    const focus = nextSelection.focus;
    	    let anchorNode;

    	    if (anchor.type === 'text') {
    	      anchorNode = anchor.getNode();
    	      anchorNode.selectionTransform(prevSelection, nextSelection);
    	    }

    	    if (focus.type === 'text') {
    	      const focusNode = focus.getNode();

    	      if (anchorNode !== focusNode) {
    	        focusNode.selectionTransform(prevSelection, nextSelection);
    	      }
    	    }
    	  }
    	}
    	function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
    	  let siblingKey = null;
    	  let offset = 0;
    	  let type = null;

    	  if (prevSibling !== null) {
    	    siblingKey = prevSibling.__key;

    	    if ($isTextNode(prevSibling)) {
    	      offset = prevSibling.getTextContentSize();
    	      type = 'text';
    	    } else if ($isElementNode(prevSibling)) {
    	      offset = prevSibling.getChildrenSize();
    	      type = 'element';
    	    }
    	  } else {
    	    if (nextSibling !== null) {
    	      siblingKey = nextSibling.__key;

    	      if ($isTextNode(nextSibling)) {
    	        type = 'text';
    	      } else if ($isElementNode(nextSibling)) {
    	        type = 'element';
    	      }
    	    }
    	  }

    	  if (siblingKey !== null && type !== null) {
    	    point.set(siblingKey, offset, type);
    	  } else {
    	    offset = node.getIndexWithinParent();

    	    if (offset === -1) {
    	      // Move selection to end of parent
    	      offset = parent.getChildrenSize();
    	    }

    	    point.set(parent.__key, offset, 'element');
    	  }
    	}
    	function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
    	  if (point.type === 'text') {
    	    point.key = key;

    	    if (!isBefore) {
    	      point.offset += textLength;
    	    }
    	  } else if (point.offset > target.getIndexWithinParent()) {
    	    point.offset -= 1;
    	  }
    	}
    	function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
    	  const anchorDOMNode = domSelection.anchorNode;
    	  const focusDOMNode = domSelection.focusNode;
    	  const anchorOffset = domSelection.anchorOffset;
    	  const focusOffset = domSelection.focusOffset;
    	  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option
    	  // that makes this configurable.

    	  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    	    return;
    	  }

    	  if (!$isRangeSelection(nextSelection)) {
    	    // We don't remove selection if the prevSelection is null because
    	    // of editor.setRootElement(). If this occurs on init when the
    	    // editor is already focused, then this can cause the editor to
    	    // lose focus.
    	    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
    	      domSelection.removeAllRanges();
    	    }

    	    return;
    	  }

    	  const anchor = nextSelection.anchor;
    	  const focus = nextSelection.focus;
    	  const anchorKey = anchor.key;
    	  const focusKey = focus.key;
    	  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
    	  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
    	  const nextAnchorOffset = anchor.offset;
    	  const nextFocusOffset = focus.offset;
    	  const nextFormat = nextSelection.format;
    	  const isCollapsed = nextSelection.isCollapsed();
    	  let nextAnchorNode = anchorDOM;
    	  let nextFocusNode = focusDOM;
    	  let anchorFormatChanged = false;

    	  if (anchor.type === 'text') {
    	    nextAnchorNode = getDOMTextNode(anchorDOM);
    	    anchorFormatChanged = anchor.getNode().getFormat() !== nextFormat;
    	  }

    	  if (focus.type === 'text') {
    	    nextFocusNode = getDOMTextNode(focusDOM);
    	  } // If we can't get an underlying text node for selection, then
    	  // we should avoid setting selection to something incorrect.


    	  if (nextAnchorNode === null || nextFocusNode === null) {
    	    return;
    	  }

    	  if (isCollapsed && (prevSelection === null || anchorFormatChanged || $isRangeSelection(prevSelection) && prevSelection.format !== nextFormat)) {
    	    markCollapsedSelectionFormat(nextFormat, nextAnchorOffset, anchorKey, performance.now());
    	  } // Diff against the native DOM selection to ensure we don't do
    	  // an unnecessary selection update. We also skip this check if
    	  // we're moving selection to within an element, as this can
    	  // sometimes be problematic around scrolling.


    	  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
    	  !(domSelection.type === 'Range' && isCollapsed)) {
    	    // If the root element does not have focus, ensure it has focus
    	    if (activeElement === null || !rootElement.contains(activeElement)) {
    	      rootElement.focus({
    	        preventScroll: true
    	      });
    	    }

    	    if (anchor.type !== 'element') {
    	      return;
    	    }
    	  } // Apply the updated selection to the DOM. Note: this will trigger
    	  // a "selectionchange" event, although it will be asynchronous.


    	  try {
    	    // When updating more than 1000 nodes on Chrome, it's actually better to defer
    	    // updating the selection till the next frame. This is because Chrome's
    	    // Blink engine has hard limit on how many DOM nodes it can redraw in
    	    // a single cycle, so keeping it to the next frame improves performance.
    	    // The downside is that is makes the computation within Lexical more
    	    // complex, as now, we've sync update the DOM, but selection no longer
    	    // matches.
    	    if (IS_CHROME && nodeCount > 1000) {
    	      window.requestAnimationFrame(() => domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset));
    	    } else {
    	      domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
    	    }
    	  } catch (error) {// If we encounter an error, continue. This can sometimes
    	    // occur with FF and there's no good reason as to why it
    	    // should happen.
    	  }

    	  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    	    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;

    	    if (selectionTarget !== null) {
    	      // @ts-ignore Text nodes do have getBoundingClientRect
    	      const selectionRect = selectionTarget.getBoundingClientRect();
    	      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    	    }
    	  }

    	  markSelectionChangeFromDOMUpdate();
    	}
    	function $insertNodes(nodes, selectStart) {
    	  let selection = $getSelection();

    	  if (selection === null) {
    	    selection = $getRoot().selectEnd();
    	  }

    	  return selection.insertNodes(nodes, selectStart);
    	}
    	function $getTextContent() {
    	  const selection = $getSelection();

    	  if (selection === null) {
    	    return '';
    	  }

    	  return selection.getTextContent();
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	let activeEditorState = null;
    	let activeEditor = null;
    	let isReadOnlyMode = false;
    	let isAttemptingToRecoverFromReconcilerError = false;
    	let infiniteTransformCount = 0;
    	const observerOptions = {
    	  characterData: true,
    	  childList: true,
    	  subtree: true
    	};
    	function isCurrentlyReadOnlyMode() {
    	  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
    	}
    	function errorOnReadOnly() {
    	  if (isReadOnlyMode) {
    	    {
    	      throw Error(`Cannot use method in read-only mode.`);
    	    }
    	  }
    	}
    	function errorOnInfiniteTransforms() {
    	  if (infiniteTransformCount > 99) {
    	    {
    	      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    	    }
    	  }
    	}
    	function getActiveEditorState() {
    	  if (activeEditorState === null) {
    	    {
    	      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);
    	    }
    	  }

    	  return activeEditorState;
    	}
    	function getActiveEditor() {
    	  if (activeEditor === null) {
    	    {
    	      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);
    	    }
    	  }

    	  return activeEditor;
    	}
    	function internalGetActiveEditor() {
    	  return activeEditor;
    	}
    	function $applyTransforms(editor, node, transformsCache) {
    	  const type = node.__type;
    	  const registeredNode = getRegisteredNodeOrThrow(editor, type);
    	  let transformsArr = transformsCache.get(type);

    	  if (transformsArr === undefined) {
    	    transformsArr = Array.from(registeredNode.transforms);
    	    transformsCache.set(type, transformsArr);
    	  }

    	  const transformsArrLength = transformsArr.length;

    	  for (let i = 0; i < transformsArrLength; i++) {
    	    transformsArr[i](node);

    	    if (!node.isAttached()) {
    	      break;
    	    }
    	  }
    	}

    	function $isNodeValidForTransform(node, compositionKey) {
    	  return node !== undefined && // We don't want to transform nodes being composed
    	  node.__key !== compositionKey && node.isAttached();
    	}

    	function $normalizeAllDirtyTextNodes(editorState, editor) {
    	  const dirtyLeaves = editor._dirtyLeaves;
    	  const nodeMap = editorState._nodeMap;

    	  for (const nodeKey of dirtyLeaves) {
    	    const node = nodeMap.get(nodeKey);

    	    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
    	      $normalizeTextNode(node);
    	    }
    	  }
    	}
    	/**
    	 * Transform heuristic:
    	 * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.
    	 * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.
    	 * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.
    	 * If element transforms only generate additional dirty elements we only repeat step 2.
    	 *
    	 * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and
    	 * editor._subtrees which we reset in every loop.
    	 */


    	function $applyAllTransforms(editorState, editor) {
    	  const dirtyLeaves = editor._dirtyLeaves;
    	  const dirtyElements = editor._dirtyElements;
    	  const nodeMap = editorState._nodeMap;
    	  const compositionKey = $getCompositionKey();
    	  const transformsCache = new Map();
    	  let untransformedDirtyLeaves = dirtyLeaves;
    	  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    	  let untransformedDirtyElements = dirtyElements;
    	  let untransformedDirtyElementsLength = untransformedDirtyElements.size;

    	  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    	    if (untransformedDirtyLeavesLength > 0) {
    	      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms
    	      editor._dirtyLeaves = new Set();

    	      for (const nodeKey of untransformedDirtyLeaves) {
    	        const node = nodeMap.get(nodeKey);

    	        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
    	          $normalizeTextNode(node);
    	        }

    	        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {
    	          $applyTransforms(editor, node, transformsCache);
    	        }

    	        dirtyLeaves.add(nodeKey);
    	      }

    	      untransformedDirtyLeaves = editor._dirtyLeaves;
    	      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms

    	      if (untransformedDirtyLeavesLength > 0) {
    	        infiniteTransformCount++;
    	        continue;
    	      }
    	    } // All dirty leaves have been processed. Let's do elements!
    	    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track
    	    // new ones caused by element transforms


    	    editor._dirtyLeaves = new Set();
    	    editor._dirtyElements = new Map();

    	    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
    	      const nodeKey = currentUntransformedDirtyElement[0];
    	      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];

    	      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {
    	        continue;
    	      }

    	      const node = nodeMap.get(nodeKey);

    	      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {
    	        $applyTransforms(editor, node, transformsCache);
    	      }

    	      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
    	    }

    	    untransformedDirtyLeaves = editor._dirtyLeaves;
    	    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    	    untransformedDirtyElements = editor._dirtyElements;
    	    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    	    infiniteTransformCount++;
    	  }

    	  editor._dirtyLeaves = dirtyLeaves;
    	  editor._dirtyElements = dirtyElements;
    	}

    	function $parseSerializedNode(serializedNode) {
    	  const internalSerializedNode = serializedNode;
    	  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
    	}

    	function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
    	  const type = serializedNode.type;
    	  const registeredNode = registeredNodes.get(type);

    	  if (registeredNode === undefined) {
    	    {
    	      throw Error(`parseEditorState: type "${type}" + not found`);
    	    }
    	  }

    	  const nodeClass = registeredNode.klass;

    	  if (serializedNode.type !== nodeClass.getType()) {
    	    {
    	      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    	    }
    	  }

    	  const node = nodeClass.importJSON(serializedNode);
    	  const children = serializedNode.children;

    	  if ($isElementNode(node) && Array.isArray(children)) {
    	    for (let i = 0; i < children.length; i++) {
    	      const serializedJSONChildNode = children[i];
    	      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
    	      node.append(childNode);
    	    }
    	  }

    	  return node;
    	}

    	function parseEditorState(serializedEditorState, editor, updateFn) {
    	  const editorState = createEmptyEditorState();
    	  const previousActiveEditorState = activeEditorState;
    	  const previousReadOnlyMode = isReadOnlyMode;
    	  const previousActiveEditor = activeEditor;
    	  const previousDirtyElements = editor._dirtyElements;
    	  const previousDirtyLeaves = editor._dirtyLeaves;
    	  const previousCloneNotNeeded = editor._cloneNotNeeded;
    	  const previousDirtyType = editor._dirtyType;
    	  editor._dirtyElements = new Map();
    	  editor._dirtyLeaves = new Set();
    	  editor._cloneNotNeeded = new Set();
    	  editor._dirtyType = 0;
    	  activeEditorState = editorState;
    	  isReadOnlyMode = false;
    	  activeEditor = editor;

    	  try {
    	    const registeredNodes = editor._nodes;
    	    const serializedNode = serializedEditorState.root;
    	    $parseSerializedNodeImpl(serializedNode, registeredNodes);

    	    if (updateFn) {
    	      updateFn();
    	    } // Make the editorState immutable


    	    editorState._readOnly = true;

    	    {
    	      handleDEVOnlyPendingUpdateGuarantees(editorState);
    	    }
    	  } finally {
    	    editor._dirtyElements = previousDirtyElements;
    	    editor._dirtyLeaves = previousDirtyLeaves;
    	    editor._cloneNotNeeded = previousCloneNotNeeded;
    	    editor._dirtyType = previousDirtyType;
    	    activeEditorState = previousActiveEditorState;
    	    isReadOnlyMode = previousReadOnlyMode;
    	    activeEditor = previousActiveEditor;
    	  }

    	  return editorState;
    	} // This technically isn't an update but given we need
    	// exposure to the module's active bindings, we have this
    	// function here

    	function readEditorState(editorState, callbackFn) {
    	  const previousActiveEditorState = activeEditorState;
    	  const previousReadOnlyMode = isReadOnlyMode;
    	  const previousActiveEditor = activeEditor;
    	  activeEditorState = editorState;
    	  isReadOnlyMode = true;
    	  activeEditor = null;

    	  try {
    	    return callbackFn();
    	  } finally {
    	    activeEditorState = previousActiveEditorState;
    	    isReadOnlyMode = previousReadOnlyMode;
    	    activeEditor = previousActiveEditor;
    	  }
    	}

    	function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
    	  // Given we can't Object.freeze the nodeMap as it's a Map,
    	  // we instead replace its set, clear and delete methods.
    	  const nodeMap = pendingEditorState._nodeMap;

    	  nodeMap.set = () => {
    	    throw new Error('Cannot call set() on a frozen Lexical node map');
    	  };

    	  nodeMap.clear = () => {
    	    throw new Error('Cannot call clear() on a frozen Lexical node map');
    	  };

    	  nodeMap.delete = () => {
    	    throw new Error('Cannot call delete() on a frozen Lexical node map');
    	  };
    	}

    	function commitPendingUpdates(editor) {
    	  const pendingEditorState = editor._pendingEditorState;
    	  const rootElement = editor._rootElement;
    	  const shouldSkipDOM = editor._headless || rootElement === null;

    	  if (pendingEditorState === null) {
    	    return;
    	  } // ======
    	  // Reconciliation has started.
    	  // ======


    	  const currentEditorState = editor._editorState;
    	  const currentSelection = currentEditorState._selection;
    	  const pendingSelection = pendingEditorState._selection;
    	  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
    	  const previousActiveEditorState = activeEditorState;
    	  const previousReadOnlyMode = isReadOnlyMode;
    	  const previousActiveEditor = activeEditor;
    	  const previouslyUpdating = editor._updating;
    	  const observer = editor._observer;
    	  let mutatedNodes = null;
    	  editor._pendingEditorState = null;
    	  editor._editorState = pendingEditorState;

    	  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    	    activeEditor = editor;
    	    activeEditorState = pendingEditorState;
    	    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.

    	    editor._updating = true;

    	    try {
    	      const dirtyType = editor._dirtyType;
    	      const dirtyElements = editor._dirtyElements;
    	      const dirtyLeaves = editor._dirtyLeaves;
    	      observer.disconnect();
    	      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);
    	    } catch (error) {
    	      // Report errors
    	      if (error instanceof Error) {
    	        editor._onError(error);
    	      } // Reset editor and restore incoming editor state to the DOM


    	      if (!isAttemptingToRecoverFromReconcilerError) {
    	        resetEditor(editor, null, rootElement, pendingEditorState);
    	        initMutationObserver(editor);
    	        editor._dirtyType = FULL_RECONCILE;
    	        isAttemptingToRecoverFromReconcilerError = true;
    	        commitPendingUpdates(editor);
    	        isAttemptingToRecoverFromReconcilerError = false;
    	      } else {
    	        // To avoid a possible situation of infinite loops, lets throw
    	        throw error;
    	      }

    	      return;
    	    } finally {
    	      observer.observe(rootElement, observerOptions);
    	      editor._updating = previouslyUpdating;
    	      activeEditorState = previousActiveEditorState;
    	      isReadOnlyMode = previousReadOnlyMode;
    	      activeEditor = previousActiveEditor;
    	    }
    	  }

    	  if (!pendingEditorState._readOnly) {
    	    pendingEditorState._readOnly = true;

    	    {
    	      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);

    	      if ($isRangeSelection(pendingSelection)) {
    	        Object.freeze(pendingSelection.anchor);
    	        Object.freeze(pendingSelection.focus);
    	      }

    	      Object.freeze(pendingSelection);
    	    }
    	  }

    	  const dirtyLeaves = editor._dirtyLeaves;
    	  const dirtyElements = editor._dirtyElements;
    	  const normalizedNodes = editor._normalizedNodes;
    	  const tags = editor._updateTags;
    	  const deferred = editor._deferred;
    	  const nodeCount = pendingEditorState._nodeMap.size;

    	  if (needsUpdate) {
    	    editor._dirtyType = NO_DIRTY_NODES;

    	    editor._cloneNotNeeded.clear();

    	    editor._dirtyLeaves = new Set();
    	    editor._dirtyElements = new Map();
    	    editor._normalizedNodes = new Set();
    	    editor._updateTags = new Set();
    	  }

    	  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======
    	  // Reconciliation has finished. Now update selection and trigger listeners.
    	  // ======

    	  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,
    	  // and scroll into view if needed.

    	  if (editor._editable && // domSelection will be null in headless
    	  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {
    	    activeEditor = editor;
    	    activeEditorState = pendingEditorState;

    	    try {
    	      if (observer !== null) {
    	        observer.disconnect();
    	      }

    	      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
    	        const blockCursorElement = editor._blockCursorElement;

    	        if (blockCursorElement !== null) {
    	          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    	        }

    	        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement, nodeCount);
    	      }

    	      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);

    	      if (observer !== null) {
    	        observer.observe(rootElement, observerOptions);
    	      }
    	    } finally {
    	      activeEditor = previousActiveEditor;
    	      activeEditorState = previousActiveEditorState;
    	    }
    	  }

    	  if (mutatedNodes !== null) {
    	    triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, tags, dirtyLeaves);
    	  }

    	  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    	    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);
    	  }
    	  /**
    	   * Capture pendingDecorators after garbage collecting detached decorators
    	   */


    	  const pendingDecorators = editor._pendingDecorators;

    	  if (pendingDecorators !== null) {
    	    editor._decorators = pendingDecorators;
    	    editor._pendingDecorators = null;
    	    triggerListeners('decorator', editor, true, pendingDecorators);
    	  }

    	  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);
    	  triggerListeners('update', editor, true, {
    	    dirtyElements,
    	    dirtyLeaves,
    	    editorState: pendingEditorState,
    	    normalizedNodes,
    	    prevEditorState: currentEditorState,
    	    tags
    	  });
    	  triggerDeferredUpdateCallbacks(editor, deferred);
    	  triggerEnqueuedUpdates(editor);
    	}

    	function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
    	  const currentTextContent = getEditorStateTextContent(currentEditorState);
    	  const latestTextContent = getEditorStateTextContent(pendingEditorState);

    	  if (currentTextContent !== latestTextContent) {
    	    triggerListeners('textcontent', editor, true, latestTextContent);
    	  }
    	}

    	function triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes, updateTags, dirtyLeaves) {
    	  const listeners = Array.from(editor._listeners.mutation);
    	  const listenersLength = listeners.length;

    	  for (let i = 0; i < listenersLength; i++) {
    	    const [listener, klass] = listeners[i];
    	    const mutatedNodesByType = mutatedNodes.get(klass);

    	    if (mutatedNodesByType !== undefined) {
    	      listener(mutatedNodesByType, {
    	        dirtyLeaves,
    	        updateTags
    	      });
    	    }
    	  }
    	}

    	function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
    	  const previouslyUpdating = editor._updating;
    	  editor._updating = isCurrentlyEnqueuingUpdates;

    	  try {
    	    const listeners = Array.from(editor._listeners[type]);

    	    for (let i = 0; i < listeners.length; i++) {
    	      // @ts-ignore
    	      listeners[i].apply(null, payload);
    	    }
    	  } finally {
    	    editor._updating = previouslyUpdating;
    	  }
    	}
    	function triggerCommandListeners(editor, type, payload) {
    	  if (editor._updating === false || activeEditor !== editor) {
    	    let returnVal = false;
    	    editor.update(() => {
    	      returnVal = triggerCommandListeners(editor, type, payload);
    	    });
    	    return returnVal;
    	  }

    	  const editors = getEditorsToPropagate(editor);

    	  for (let i = 4; i >= 0; i--) {
    	    for (let e = 0; e < editors.length; e++) {
    	      const currentEditor = editors[e];
    	      const commandListeners = currentEditor._commands;
    	      const listenerInPriorityOrder = commandListeners.get(type);

    	      if (listenerInPriorityOrder !== undefined) {
    	        const listenersSet = listenerInPriorityOrder[i];

    	        if (listenersSet !== undefined) {
    	          const listeners = Array.from(listenersSet);
    	          const listenersLength = listeners.length;

    	          for (let j = 0; j < listenersLength; j++) {
    	            if (listeners[j](payload, editor) === true) {
    	              return true;
    	            }
    	          }
    	        }
    	      }
    	    }
    	  }

    	  return false;
    	}

    	function triggerEnqueuedUpdates(editor) {
    	  const queuedUpdates = editor._updates;

    	  if (queuedUpdates.length !== 0) {
    	    const queuedUpdate = queuedUpdates.shift();

    	    if (queuedUpdate) {
    	      const [updateFn, options] = queuedUpdate;
    	      beginUpdate(editor, updateFn, options);
    	    }
    	  }
    	}

    	function triggerDeferredUpdateCallbacks(editor, deferred) {
    	  editor._deferred = [];

    	  if (deferred.length !== 0) {
    	    const previouslyUpdating = editor._updating;
    	    editor._updating = true;

    	    try {
    	      for (let i = 0; i < deferred.length; i++) {
    	        deferred[i]();
    	      }
    	    } finally {
    	      editor._updating = previouslyUpdating;
    	    }
    	  }
    	}

    	function processNestedUpdates(editor, initialSkipTransforms) {
    	  const queuedUpdates = editor._updates;
    	  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need
    	  // to handle each update as we go until the updates array is
    	  // empty.

    	  while (queuedUpdates.length !== 0) {
    	    const queuedUpdate = queuedUpdates.shift();

    	    if (queuedUpdate) {
    	      const [nextUpdateFn, options] = queuedUpdate;
    	      let onUpdate;
    	      let tag;

    	      if (options !== undefined) {
    	        onUpdate = options.onUpdate;
    	        tag = options.tag;

    	        if (options.skipTransforms) {
    	          skipTransforms = true;
    	        }

    	        if (onUpdate) {
    	          editor._deferred.push(onUpdate);
    	        }

    	        if (tag) {
    	          editor._updateTags.add(tag);
    	        }
    	      }

    	      nextUpdateFn();
    	    }
    	  }

    	  return skipTransforms;
    	}

    	function beginUpdate(editor, updateFn, options) {
    	  const updateTags = editor._updateTags;
    	  let onUpdate;
    	  let tag;
    	  let skipTransforms = false;
    	  let discrete = false;

    	  if (options !== undefined) {
    	    onUpdate = options.onUpdate;
    	    tag = options.tag;

    	    if (tag != null) {
    	      updateTags.add(tag);
    	    }

    	    skipTransforms = options.skipTransforms || false;
    	    discrete = options.discrete || false;
    	  }

    	  if (onUpdate) {
    	    editor._deferred.push(onUpdate);
    	  }

    	  const currentEditorState = editor._editorState;
    	  let pendingEditorState = editor._pendingEditorState;
    	  let editorStateWasCloned = false;

    	  if (pendingEditorState === null || pendingEditorState._readOnly) {
    	    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    	    editorStateWasCloned = true;
    	  }

    	  pendingEditorState._flushSync = discrete;
    	  const previousActiveEditorState = activeEditorState;
    	  const previousReadOnlyMode = isReadOnlyMode;
    	  const previousActiveEditor = activeEditor;
    	  const previouslyUpdating = editor._updating;
    	  activeEditorState = pendingEditorState;
    	  isReadOnlyMode = false;
    	  editor._updating = true;
    	  activeEditor = editor;

    	  try {
    	    if (editorStateWasCloned) {
    	      if (editor._headless) {
    	        if (currentEditorState._selection != null) {
    	          pendingEditorState._selection = currentEditorState._selection.clone();
    	        }
    	      } else {
    	        pendingEditorState._selection = internalCreateSelection(editor);
    	      }
    	    }

    	    const startingCompositionKey = editor._compositionKey;
    	    updateFn();
    	    skipTransforms = processNestedUpdates(editor, skipTransforms);
    	    applySelectionTransforms(pendingEditorState, editor);

    	    if (editor._dirtyType !== NO_DIRTY_NODES) {
    	      if (skipTransforms) {
    	        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
    	      } else {
    	        $applyAllTransforms(pendingEditorState, editor);
    	      }

    	      processNestedUpdates(editor);
    	      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    	    }

    	    const endingCompositionKey = editor._compositionKey;

    	    if (startingCompositionKey !== endingCompositionKey) {
    	      pendingEditorState._flushSync = true;
    	    }

    	    const pendingSelection = pendingEditorState._selection;

    	    if ($isRangeSelection(pendingSelection)) {
    	      const pendingNodeMap = pendingEditorState._nodeMap;
    	      const anchorKey = pendingSelection.anchor.key;
    	      const focusKey = pendingSelection.focus.key;

    	      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {
    	        {
    	          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
    	        }
    	      }
    	    } else if ($isNodeSelection(pendingSelection)) {
    	      // TODO: we should also validate node selection?
    	      if (pendingSelection._nodes.size === 0) {
    	        pendingEditorState._selection = null;
    	      }
    	    }
    	  } catch (error) {
    	    // Report errors
    	    if (error instanceof Error) {
    	      editor._onError(error);
    	    } // Restore existing editor state to the DOM


    	    editor._pendingEditorState = currentEditorState;
    	    editor._dirtyType = FULL_RECONCILE;

    	    editor._cloneNotNeeded.clear();

    	    editor._dirtyLeaves = new Set();

    	    editor._dirtyElements.clear();

    	    commitPendingUpdates(editor);
    	    return;
    	  } finally {
    	    activeEditorState = previousActiveEditorState;
    	    isReadOnlyMode = previousReadOnlyMode;
    	    activeEditor = previousActiveEditor;
    	    editor._updating = previouslyUpdating;
    	    infiniteTransformCount = 0;
    	  }

    	  const windowObj = editor._window;
    	  const windowEvent = windowObj !== null ? window.event : null;
    	  const eventType = windowEvent != null ? windowEvent.type : null;
    	  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor) || editor._blockCursorElement !== null && eventType === 'blur';

    	  if (shouldUpdate) {
    	    if (pendingEditorState._flushSync) {
    	      pendingEditorState._flushSync = false;
    	      commitPendingUpdates(editor);
    	    } else if (editorStateWasCloned) {
    	      scheduleMicroTask(() => {
    	        commitPendingUpdates(editor);
    	      });
    	    }
    	  } else {
    	    pendingEditorState._flushSync = false;

    	    if (editorStateWasCloned) {
    	      updateTags.clear();
    	      editor._deferred = [];
    	      editor._pendingEditorState = null;
    	    }
    	  }
    	}

    	function updateEditor(editor, updateFn, options) {
    	  if (editor._updating) {
    	    editor._updates.push([updateFn, options]);
    	  } else {
    	    beginUpdate(editor, updateFn, options);
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
    	  errorOnReadOnly();
    	  const key = nodeToRemove.__key;
    	  const parent = nodeToRemove.getParent();

    	  if (parent === null) {
    	    return;
    	  }

    	  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
    	  let selectionMoved = false;

    	  if ($isRangeSelection(selection) && restoreSelection) {
    	    const anchor = selection.anchor;
    	    const focus = selection.focus;

    	    if (anchor.key === key) {
    	      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
    	      selectionMoved = true;
    	    }

    	    if (focus.key === key) {
    	      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
    	      selectionMoved = true;
    	    }
    	  }

    	  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
    	    // Doing this is O(n) so lets avoid it unless we need to do it
    	    const index = nodeToRemove.getIndexWithinParent();
    	    removeFromParent(nodeToRemove);
    	    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
    	  } else {
    	    removeFromParent(nodeToRemove);
    	  }

    	  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    	    removeNode(parent, restoreSelection);
    	  }

    	  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {
    	    parent.selectEnd();
    	  }
    	}
    	class LexicalNode {
    	  // eslint-disable-next-line @typescript-eslint/no-explicit-any
    	  // Flow doesn't support abstract classes unfortunately, so we can't _force_
    	  // subclasses of Node to implement statics. All subclasses of Node should have
    	  // a static getType and clone method though. We define getType and clone here so we can call it
    	  // on any  Node, and we throw this error by default since the subclass should provide
    	  // their own implementation.
    	  static getType() {
    	    {
    	      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    	    }
    	  }

    	  static clone(_data) {
    	    {
    	      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    	    }
    	  }

    	  constructor(key) {
    	    // @ts-expect-error
    	    this.__type = this.constructor.getType();
    	    this.__parent = null;
    	    this.__prev = null;
    	    this.__next = null;
    	    $setNodeKey(this, key);

    	    {
    	      if (this.__type !== 'root') {
    	        errorOnReadOnly();
    	        errorOnTypeKlassMismatch(this.__type, // @ts-expect-error
    	        this.constructor);
    	      }
    	    }
    	  } // Getters and Traversers


    	  getType() {
    	    return this.__type;
    	  }

    	  isAttached() {
    	    let nodeKey = this.__key;

    	    while (nodeKey !== null) {
    	      if (nodeKey === 'root') {
    	        return true;
    	      }

    	      const node = $getNodeByKey(nodeKey);

    	      if (node === null) {
    	        break;
    	      }

    	      nodeKey = node.__parent;
    	    }

    	    return false;
    	  }

    	  isSelected() {
    	    const selection = $getSelection();

    	    if (selection == null) {
    	      return false;
    	    }

    	    const isSelected = selection.getNodes().some(n => n.__key === this.__key);

    	    if ($isTextNode(this)) {
    	      return isSelected;
    	    } // For inline images inside of element nodes.
    	    // Without this change the image will be selected if the cursor is before or after it.


    	    if ($isRangeSelection(selection) && selection.anchor.type === 'element' && selection.focus.type === 'element' && selection.anchor.key === selection.focus.key && selection.anchor.offset === selection.focus.offset) {
    	      return false;
    	    }

    	    return isSelected;
    	  }

    	  getKey() {
    	    // Key is stable between copies
    	    return this.__key;
    	  }

    	  getIndexWithinParent() {
    	    const parent = this.getParent();

    	    if (parent === null) {
    	      return -1;
    	    }

    	    let node = parent.getFirstChild();
    	    let index = 0;

    	    while (node !== null) {
    	      if (this.is(node)) {
    	        return index;
    	      }

    	      index++;
    	      node = node.getNextSibling();
    	    }

    	    return -1;
    	  }

    	  getParent() {
    	    const parent = this.getLatest().__parent;

    	    if (parent === null) {
    	      return null;
    	    }

    	    return $getNodeByKey(parent);
    	  }

    	  getParentOrThrow() {
    	    const parent = this.getParent();

    	    if (parent === null) {
    	      {
    	        throw Error(`Expected node ${this.__key} to have a parent.`);
    	      }
    	    }

    	    return parent;
    	  }

    	  getTopLevelElement() {
    	    let node = this;

    	    while (node !== null) {
    	      const parent = node.getParent();

    	      if ($isRootOrShadowRoot(parent)) {
    	        return node;
    	      }

    	      node = parent;
    	    }

    	    return null;
    	  }

    	  getTopLevelElementOrThrow() {
    	    const parent = this.getTopLevelElement();

    	    if (parent === null) {
    	      {
    	        throw Error(`Expected node ${this.__key} to have a top parent element.`);
    	      }
    	    }

    	    return parent;
    	  }

    	  getParents() {
    	    const parents = [];
    	    let node = this.getParent();

    	    while (node !== null) {
    	      parents.push(node);
    	      node = node.getParent();
    	    }

    	    return parents;
    	  }

    	  getParentKeys() {
    	    const parents = [];
    	    let node = this.getParent();

    	    while (node !== null) {
    	      parents.push(node.__key);
    	      node = node.getParent();
    	    }

    	    return parents;
    	  }

    	  getPreviousSibling() {
    	    const self = this.getLatest();
    	    const prevKey = self.__prev;
    	    return prevKey === null ? null : $getNodeByKey(prevKey);
    	  }

    	  getPreviousSiblings() {
    	    const siblings = [];
    	    const parent = this.getParent();

    	    if (parent === null) {
    	      return siblings;
    	    }

    	    let node = parent.getFirstChild();

    	    while (node !== null) {
    	      if (node.is(this)) {
    	        break;
    	      }

    	      siblings.push(node);
    	      node = node.getNextSibling();
    	    }

    	    return siblings;
    	  }

    	  getNextSibling() {
    	    const self = this.getLatest();
    	    const nextKey = self.__next;
    	    return nextKey === null ? null : $getNodeByKey(nextKey);
    	  }

    	  getNextSiblings() {
    	    const siblings = [];
    	    let node = this.getNextSibling();

    	    while (node !== null) {
    	      siblings.push(node);
    	      node = node.getNextSibling();
    	    }

    	    return siblings;
    	  }

    	  getCommonAncestor(node) {
    	    const a = this.getParents();
    	    const b = node.getParents();

    	    if ($isElementNode(this)) {
    	      a.unshift(this);
    	    }

    	    if ($isElementNode(node)) {
    	      b.unshift(node);
    	    }

    	    const aLength = a.length;
    	    const bLength = b.length;

    	    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {
    	      return null;
    	    }

    	    const bSet = new Set(b);

    	    for (let i = 0; i < aLength; i++) {
    	      const ancestor = a[i];

    	      if (bSet.has(ancestor)) {
    	        return ancestor;
    	      }
    	    }

    	    return null;
    	  }

    	  is(object) {
    	    if (object == null) {
    	      return false;
    	    }

    	    return this.__key === object.__key;
    	  }

    	  isBefore(targetNode) {
    	    if (targetNode.isParentOf(this)) {
    	      return true;
    	    }

    	    if (this.isParentOf(targetNode)) {
    	      return false;
    	    }

    	    const commonAncestor = this.getCommonAncestor(targetNode);
    	    let indexA = 0;
    	    let indexB = 0;
    	    let node = this;

    	    while (true) {
    	      const parent = node.getParentOrThrow();

    	      if (parent === commonAncestor) {
    	        indexA = node.getIndexWithinParent();
    	        break;
    	      }

    	      node = parent;
    	    }

    	    node = targetNode;

    	    while (true) {
    	      const parent = node.getParentOrThrow();

    	      if (parent === commonAncestor) {
    	        indexB = node.getIndexWithinParent();
    	        break;
    	      }

    	      node = parent;
    	    }

    	    return indexA < indexB;
    	  }

    	  isParentOf(targetNode) {
    	    const key = this.__key;

    	    if (key === targetNode.__key) {
    	      return false;
    	    }

    	    let node = targetNode;

    	    while (node !== null) {
    	      if (node.__key === key) {
    	        return true;
    	      }

    	      node = node.getParent();
    	    }

    	    return false;
    	  } // TO-DO: this function can be simplified a lot


    	  getNodesBetween(targetNode) {
    	    const isBefore = this.isBefore(targetNode);
    	    const nodes = [];
    	    const visited = new Set();
    	    let node = this;

    	    while (true) {
    	      const key = node.__key;

    	      if (!visited.has(key)) {
    	        visited.add(key);
    	        nodes.push(node);
    	      }

    	      if (node === targetNode) {
    	        break;
    	      }

    	      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;

    	      if (child !== null) {
    	        node = child;
    	        continue;
    	      }

    	      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();

    	      if (nextSibling !== null) {
    	        node = nextSibling;
    	        continue;
    	      }

    	      const parent = node.getParentOrThrow();

    	      if (!visited.has(parent.__key)) {
    	        nodes.push(parent);
    	      }

    	      if (parent === targetNode) {
    	        break;
    	      }

    	      let parentSibling = null;
    	      let ancestor = parent;

    	      do {
    	        if (ancestor === null) {
    	          {
    	            throw Error(`getNodesBetween: ancestor is null`);
    	          }
    	        }

    	        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
    	        ancestor = ancestor.getParent();

    	        if (ancestor !== null) {
    	          if (parentSibling === null && !visited.has(ancestor.__key)) {
    	            nodes.push(ancestor);
    	          }
    	        }
    	      } while (parentSibling === null);

    	      node = parentSibling;
    	    }

    	    if (!isBefore) {
    	      nodes.reverse();
    	    }

    	    return nodes;
    	  }

    	  isDirty() {
    	    const editor = getActiveEditor();
    	    const dirtyLeaves = editor._dirtyLeaves;
    	    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
    	  }

    	  getLatest() {
    	    const latest = $getNodeByKey(this.__key);

    	    if (latest === null) {
    	      {
    	        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
    	      }
    	    }

    	    return latest;
    	  }

    	  getWritable() {
    	    errorOnReadOnly();
    	    const editorState = getActiveEditorState();
    	    const editor = getActiveEditor();
    	    const nodeMap = editorState._nodeMap;
    	    const key = this.__key; // Ensure we get the latest node from pending state

    	    const latestNode = this.getLatest();
    	    const parent = latestNode.__parent;
    	    const cloneNotNeeded = editor._cloneNotNeeded;
    	    const selection = $getSelection();

    	    if (selection !== null) {
    	      selection._cachedNodes = null;
    	    }

    	    if (cloneNotNeeded.has(key)) {
    	      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes
    	      internalMarkNodeAsDirty(latestNode);
    	      return latestNode;
    	    }

    	    const constructor = latestNode.constructor; // @ts-expect-error

    	    const mutableNode = constructor.clone(latestNode);
    	    mutableNode.__parent = parent;
    	    mutableNode.__next = latestNode.__next;
    	    mutableNode.__prev = latestNode.__prev;

    	    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {
    	      mutableNode.__first = latestNode.__first;
    	      mutableNode.__last = latestNode.__last;
    	      mutableNode.__size = latestNode.__size;
    	      mutableNode.__indent = latestNode.__indent;
    	      mutableNode.__format = latestNode.__format;
    	      mutableNode.__dir = latestNode.__dir;
    	    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {
    	      mutableNode.__format = latestNode.__format;
    	      mutableNode.__style = latestNode.__style;
    	      mutableNode.__mode = latestNode.__mode;
    	      mutableNode.__detail = latestNode.__detail;
    	    }

    	    cloneNotNeeded.add(key);
    	    mutableNode.__key = key;
    	    internalMarkNodeAsDirty(mutableNode); // Update reference in node map

    	    nodeMap.set(key, mutableNode);
    	    return mutableNode;
    	  }

    	  getTextContent() {
    	    return '';
    	  }

    	  getTextContentSize() {
    	    return this.getTextContent().length;
    	  } // View


    	  createDOM(_config, _editor) {
    	    {
    	      throw Error(`createDOM: base method not extended`);
    	    }
    	  }
    	  /*
    	   * This method is called when a node changes and should update the DOM
    	   * in whatever way is necessary to make it align with any changes that might
    	   * have happened during the update.
    	   *
    	   * Returning "true" here will cause lexical to unmount and recreate the DOM node
    	   * (by calling createDOM). You would need to do this if the element tag changes,
    	   * for instance.
    	   *
    	   * */


    	  updateDOM(_prevNode, _dom, _config) {
    	    {
    	      throw Error(`updateDOM: base method not extended`);
    	    }
    	  }

    	  exportDOM(editor) {
    	    const element = this.createDOM(editor._config, editor);
    	    return {
    	      element
    	    };
    	  }

    	  exportJSON() {
    	    {
    	      throw Error(`exportJSON: base method not extended`);
    	    }
    	  }

    	  static importJSON(_serializedNode) {
    	    {
    	      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    	    }
    	  } // Setters and mutators


    	  remove(preserveEmptyParent) {
    	    removeNode(this, true, preserveEmptyParent);
    	  }

    	  replace(replaceWith, includeChildren) {
    	    errorOnReadOnly();
    	    let selection = $getSelection();
    	    if (selection !== null) selection = selection.clone();
    	    errorOnInsertTextNodeOnRoot(this, replaceWith);
    	    const self = this.getLatest();
    	    const toReplaceKey = this.__key;
    	    const key = replaceWith.__key;
    	    const writableReplaceWith = replaceWith.getWritable();
    	    const writableParent = this.getParentOrThrow().getWritable();
    	    const size = writableParent.__size;
    	    removeFromParent(writableReplaceWith);
    	    const prevSibling = self.getPreviousSibling();
    	    const nextSibling = self.getNextSibling();
    	    const prevKey = self.__prev;
    	    const nextKey = self.__next;
    	    const parentKey = self.__parent;
    	    removeNode(self, false, true);

    	    if (prevSibling === null) {
    	      writableParent.__first = key;
    	    } else {
    	      const writablePrevSibling = prevSibling.getWritable();
    	      writablePrevSibling.__next = key;
    	    }

    	    writableReplaceWith.__prev = prevKey;

    	    if (nextSibling === null) {
    	      writableParent.__last = key;
    	    } else {
    	      const writableNextSibling = nextSibling.getWritable();
    	      writableNextSibling.__prev = key;
    	    }

    	    writableReplaceWith.__next = nextKey;
    	    writableReplaceWith.__parent = parentKey;
    	    writableParent.__size = size;

    	    if (includeChildren) {
    	      this.getChildren().forEach(child => {
    	        writableReplaceWith.append(child);
    	      });
    	    }

    	    if ($isRangeSelection(selection)) {
    	      $setSelection(selection);
    	      const anchor = selection.anchor;
    	      const focus = selection.focus;

    	      if (anchor.key === toReplaceKey) {
    	        $moveSelectionPointToEnd(anchor, writableReplaceWith);
    	      }

    	      if (focus.key === toReplaceKey) {
    	        $moveSelectionPointToEnd(focus, writableReplaceWith);
    	      }
    	    }

    	    if ($getCompositionKey() === toReplaceKey) {
    	      $setCompositionKey(key);
    	    }

    	    return writableReplaceWith;
    	  }

    	  insertAfter(nodeToInsert, restoreSelection = true) {
    	    errorOnReadOnly();
    	    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    	    const writableSelf = this.getWritable();
    	    const writableNodeToInsert = nodeToInsert.getWritable();
    	    const oldParent = writableNodeToInsert.getParent();
    	    const selection = $getSelection();
    	    let elementAnchorSelectionOnNode = false;
    	    let elementFocusSelectionOnNode = false;

    	    if (oldParent !== null) {
    	      // TODO: this is O(n), can we improve?
    	      const oldIndex = nodeToInsert.getIndexWithinParent();
    	      removeFromParent(writableNodeToInsert);

    	      if ($isRangeSelection(selection)) {
    	        const oldParentKey = oldParent.__key;
    	        const anchor = selection.anchor;
    	        const focus = selection.focus;
    	        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
    	        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;
    	      }
    	    }

    	    const nextSibling = this.getNextSibling();
    	    const writableParent = this.getParentOrThrow().getWritable();
    	    const insertKey = writableNodeToInsert.__key;
    	    const nextKey = writableSelf.__next;

    	    if (nextSibling === null) {
    	      writableParent.__last = insertKey;
    	    } else {
    	      const writableNextSibling = nextSibling.getWritable();
    	      writableNextSibling.__prev = insertKey;
    	    }

    	    writableParent.__size++;
    	    writableSelf.__next = insertKey;
    	    writableNodeToInsert.__next = nextKey;
    	    writableNodeToInsert.__prev = writableSelf.__key;
    	    writableNodeToInsert.__parent = writableSelf.__parent;

    	    if (restoreSelection && $isRangeSelection(selection)) {
    	      const index = this.getIndexWithinParent();
    	      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
    	      const writableParentKey = writableParent.__key;

    	      if (elementAnchorSelectionOnNode) {
    	        selection.anchor.set(writableParentKey, index + 2, 'element');
    	      }

    	      if (elementFocusSelectionOnNode) {
    	        selection.focus.set(writableParentKey, index + 2, 'element');
    	      }
    	    }

    	    return nodeToInsert;
    	  }

    	  insertBefore(nodeToInsert, restoreSelection = true) {
    	    errorOnReadOnly();
    	    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    	    const writableSelf = this.getWritable();
    	    const writableNodeToInsert = nodeToInsert.getWritable();
    	    const insertKey = writableNodeToInsert.__key;
    	    removeFromParent(writableNodeToInsert);
    	    const prevSibling = this.getPreviousSibling();
    	    const writableParent = this.getParentOrThrow().getWritable();
    	    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?

    	    const index = this.getIndexWithinParent();

    	    if (prevSibling === null) {
    	      writableParent.__first = insertKey;
    	    } else {
    	      const writablePrevSibling = prevSibling.getWritable();
    	      writablePrevSibling.__next = insertKey;
    	    }

    	    writableParent.__size++;
    	    writableSelf.__prev = insertKey;
    	    writableNodeToInsert.__prev = prevKey;
    	    writableNodeToInsert.__next = writableSelf.__key;
    	    writableNodeToInsert.__parent = writableSelf.__parent;
    	    const selection = $getSelection();

    	    if (restoreSelection && $isRangeSelection(selection)) {
    	      const parent = this.getParentOrThrow();
    	      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
    	    }

    	    return nodeToInsert;
    	  }

    	  selectPrevious(anchorOffset, focusOffset) {
    	    errorOnReadOnly();
    	    const prevSibling = this.getPreviousSibling();
    	    const parent = this.getParentOrThrow();

    	    if (prevSibling === null) {
    	      return parent.select(0, 0);
    	    }

    	    if ($isElementNode(prevSibling)) {
    	      return prevSibling.select();
    	    } else if (!$isTextNode(prevSibling)) {
    	      const index = prevSibling.getIndexWithinParent() + 1;
    	      return parent.select(index, index);
    	    }

    	    return prevSibling.select(anchorOffset, focusOffset);
    	  }

    	  selectNext(anchorOffset, focusOffset) {
    	    errorOnReadOnly();
    	    const nextSibling = this.getNextSibling();
    	    const parent = this.getParentOrThrow();

    	    if (nextSibling === null) {
    	      return parent.select();
    	    }

    	    if ($isElementNode(nextSibling)) {
    	      return nextSibling.select(0, 0);
    	    } else if (!$isTextNode(nextSibling)) {
    	      const index = nextSibling.getIndexWithinParent();
    	      return parent.select(index, index);
    	    }

    	    return nextSibling.select(anchorOffset, focusOffset);
    	  } // Proxy to mark something as dirty


    	  markDirty() {
    	    this.getWritable();
    	  }

    	}

    	function errorOnTypeKlassMismatch(type, klass) {
    	  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant


    	  if (registeredNode === undefined) {
    	    {
    	      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    	    }
    	  }

    	  const editorKlass = registeredNode.klass;

    	  if (editorKlass !== klass) {
    	    {
    	      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    	    }
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	/** @noInheritDoc */

    	class DecoratorNode extends LexicalNode {
    	  constructor(key) {
    	    super(key);
    	  }

    	  decorate(editor, config) {
    	    {
    	      throw Error(`decorate: base method not extended`);
    	    }
    	  }

    	  isIsolated() {
    	    return false;
    	  }

    	  isInline() {
    	    return true;
    	  }

    	  isKeyboardSelectable() {
    	    return true;
    	  }

    	}
    	function $isDecoratorNode(node) {
    	  return node instanceof DecoratorNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class ElementNode extends LexicalNode {
    	  /** @internal */

    	  /** @internal */

    	  /** @internal */

    	  /** @internal */

    	  /** @internal */

    	  /** @internal */
    	  constructor(key) {
    	    super(key);
    	    this.__first = null;
    	    this.__last = null;
    	    this.__size = 0;
    	    this.__format = 0;
    	    this.__indent = 0;
    	    this.__dir = null;
    	  }

    	  getFormat() {
    	    const self = this.getLatest();
    	    return self.__format;
    	  }

    	  getFormatType() {
    	    const format = this.getFormat();
    	    return ELEMENT_FORMAT_TO_TYPE[format] || '';
    	  }

    	  getIndent() {
    	    const self = this.getLatest();
    	    return self.__indent;
    	  }

    	  getChildren() {
    	    const children = [];
    	    let child = this.getFirstChild();

    	    while (child !== null) {
    	      children.push(child);
    	      child = child.getNextSibling();
    	    }

    	    return children;
    	  }

    	  getChildrenKeys() {
    	    const children = [];
    	    let child = this.getFirstChild();

    	    while (child !== null) {
    	      children.push(child.__key);
    	      child = child.getNextSibling();
    	    }

    	    return children;
    	  }

    	  getChildrenSize() {
    	    const self = this.getLatest();
    	    return self.__size;
    	  }

    	  isEmpty() {
    	    return this.getChildrenSize() === 0;
    	  }

    	  isDirty() {
    	    const editor = getActiveEditor();
    	    const dirtyElements = editor._dirtyElements;
    	    return dirtyElements !== null && dirtyElements.has(this.__key);
    	  }

    	  isLastChild() {
    	    const self = this.getLatest();
    	    const parentLastChild = this.getParentOrThrow().getLastChild();
    	    return parentLastChild !== null && parentLastChild.is(self);
    	  }

    	  getAllTextNodes() {
    	    const textNodes = [];
    	    let child = this.getFirstChild();

    	    while (child !== null) {
    	      if ($isTextNode(child)) {
    	        textNodes.push(child);
    	      }

    	      if ($isElementNode(child)) {
    	        const subChildrenNodes = child.getAllTextNodes();
    	        textNodes.push(...subChildrenNodes);
    	      }

    	      child = child.getNextSibling();
    	    }

    	    return textNodes;
    	  }

    	  getFirstDescendant() {
    	    let node = this.getFirstChild();

    	    while (node !== null) {
    	      if ($isElementNode(node)) {
    	        const child = node.getFirstChild();

    	        if (child !== null) {
    	          node = child;
    	          continue;
    	        }
    	      }

    	      break;
    	    }

    	    return node;
    	  }

    	  getLastDescendant() {
    	    let node = this.getLastChild();

    	    while (node !== null) {
    	      if ($isElementNode(node)) {
    	        const child = node.getLastChild();

    	        if (child !== null) {
    	          node = child;
    	          continue;
    	        }
    	      }

    	      break;
    	    }

    	    return node;
    	  }

    	  getDescendantByIndex(index) {
    	    const children = this.getChildren();
    	    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant
    	    // (either a leaf node or the bottom-most element)

    	    if (index >= childrenLength) {
    	      const resolvedNode = children[childrenLength - 1];
    	      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;
    	    }

    	    const resolvedNode = children[index];
    	    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
    	  }

    	  getFirstChild() {
    	    const self = this.getLatest();
    	    const firstKey = self.__first;
    	    return firstKey === null ? null : $getNodeByKey(firstKey);
    	  }

    	  getFirstChildOrThrow() {
    	    const firstChild = this.getFirstChild();

    	    if (firstChild === null) {
    	      {
    	        throw Error(`Expected node ${this.__key} to have a first child.`);
    	      }
    	    }

    	    return firstChild;
    	  }

    	  getLastChild() {
    	    const self = this.getLatest();
    	    const lastKey = self.__last;
    	    return lastKey === null ? null : $getNodeByKey(lastKey);
    	  }

    	  getLastChildOrThrow() {
    	    const lastChild = this.getLastChild();

    	    if (lastChild === null) {
    	      {
    	        throw Error(`Expected node ${this.__key} to have a last child.`);
    	      }
    	    }

    	    return lastChild;
    	  }

    	  getChildAtIndex(index) {
    	    const size = this.getChildrenSize();
    	    let node;
    	    let i;

    	    if (index < size / 2) {
    	      node = this.getFirstChild();
    	      i = 0;

    	      while (node !== null && i <= index) {
    	        if (i === index) {
    	          return node;
    	        }

    	        node = node.getNextSibling();
    	        i++;
    	      }

    	      return null;
    	    }

    	    node = this.getLastChild();
    	    i = size - 1;

    	    while (node !== null && i >= index) {
    	      if (i === index) {
    	        return node;
    	      }

    	      node = node.getPreviousSibling();
    	      i--;
    	    }

    	    return null;
    	  }

    	  getTextContent() {
    	    let textContent = '';
    	    const children = this.getChildren();
    	    const childrenLength = children.length;

    	    for (let i = 0; i < childrenLength; i++) {
    	      const child = children[i];
    	      textContent += child.getTextContent();

    	      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {
    	        textContent += DOUBLE_LINE_BREAK;
    	      }
    	    }

    	    return textContent;
    	  }

    	  getDirection() {
    	    const self = this.getLatest();
    	    return self.__dir;
    	  }

    	  hasFormat(type) {
    	    if (type !== '') {
    	      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
    	      return (this.getFormat() & formatFlag) !== 0;
    	    }

    	    return false;
    	  } // Mutators


    	  select(_anchorOffset, _focusOffset) {
    	    errorOnReadOnly();
    	    const selection = $getSelection();
    	    let anchorOffset = _anchorOffset;
    	    let focusOffset = _focusOffset;
    	    const childrenCount = this.getChildrenSize();

    	    if (!this.canBeEmpty()) {
    	      if (_anchorOffset === 0 && _focusOffset === 0) {
    	        const firstChild = this.getFirstChild();

    	        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
    	          return firstChild.select(0, 0);
    	        }
    	      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {
    	        const lastChild = this.getLastChild();

    	        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
    	          return lastChild.select();
    	        }
    	      }
    	    }

    	    if (anchorOffset === undefined) {
    	      anchorOffset = childrenCount;
    	    }

    	    if (focusOffset === undefined) {
    	      focusOffset = childrenCount;
    	    }

    	    const key = this.__key;

    	    if (!$isRangeSelection(selection)) {
    	      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');
    	    } else {
    	      selection.anchor.set(key, anchorOffset, 'element');
    	      selection.focus.set(key, focusOffset, 'element');
    	      selection.dirty = true;
    	    }

    	    return selection;
    	  }

    	  selectStart() {
    	    const firstNode = this.getFirstDescendant();

    	    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {
    	      return firstNode.select(0, 0);
    	    } // Decorator or LineBreak


    	    if (firstNode !== null) {
    	      return firstNode.selectPrevious();
    	    }

    	    return this.select(0, 0);
    	  }

    	  selectEnd() {
    	    const lastNode = this.getLastDescendant();

    	    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
    	      return lastNode.select();
    	    } // Decorator or LineBreak


    	    if (lastNode !== null) {
    	      return lastNode.selectNext();
    	    }

    	    return this.select();
    	  }

    	  clear() {
    	    const writableSelf = this.getWritable();
    	    const children = this.getChildren();
    	    children.forEach(child => child.remove());
    	    return writableSelf;
    	  }

    	  append(...nodesToAppend) {
    	    return this.splice(this.getChildrenSize(), 0, nodesToAppend);
    	  }

    	  setDirection(direction) {
    	    const self = this.getWritable();
    	    self.__dir = direction;
    	    return self;
    	  }

    	  setFormat(type) {
    	    const self = this.getWritable();
    	    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
    	    return this;
    	  }

    	  setIndent(indentLevel) {
    	    const self = this.getWritable();
    	    self.__indent = indentLevel;
    	    return this;
    	  }

    	  splice(start, deleteCount, nodesToInsert) {
    	    const nodesToInsertLength = nodesToInsert.length;
    	    const oldSize = this.getChildrenSize();
    	    const writableSelf = this.getWritable();
    	    const writableSelfKey = writableSelf.__key;
    	    const nodesToInsertKeys = [];
    	    const nodesToRemoveKeys = [];
    	    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
    	    let nodeBeforeRange = null;
    	    let newSize = oldSize - deleteCount + nodesToInsertLength;

    	    if (start !== 0) {
    	      if (start === oldSize) {
    	        nodeBeforeRange = this.getLastChild();
    	      } else {
    	        const node = this.getChildAtIndex(start);

    	        if (node !== null) {
    	          nodeBeforeRange = node.getPreviousSibling();
    	        }
    	      }
    	    }

    	    if (deleteCount > 0) {
    	      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();

    	      for (let i = 0; i < deleteCount; i++) {
    	        if (nodeToDelete === null) {
    	          {
    	            throw Error(`splice: sibling not found`);
    	          }
    	        }

    	        const nextSibling = nodeToDelete.getNextSibling();
    	        const nodeKeyToDelete = nodeToDelete.__key;
    	        const writableNodeToDelete = nodeToDelete.getWritable();
    	        removeFromParent(writableNodeToDelete);
    	        nodesToRemoveKeys.push(nodeKeyToDelete);
    	        nodeToDelete = nextSibling;
    	      }
    	    }

    	    let prevNode = nodeBeforeRange;

    	    for (let i = 0; i < nodesToInsertLength; i++) {
    	      const nodeToInsert = nodesToInsert[i];

    	      if (prevNode !== null && nodeToInsert.is(prevNode)) {
    	        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
    	      }

    	      const writableNodeToInsert = nodeToInsert.getWritable();

    	      if (writableNodeToInsert.__parent === writableSelfKey) {
    	        newSize--;
    	      }

    	      removeFromParent(writableNodeToInsert);
    	      const nodeKeyToInsert = nodeToInsert.__key;

    	      if (prevNode === null) {
    	        writableSelf.__first = nodeKeyToInsert;
    	        writableNodeToInsert.__prev = null;
    	      } else {
    	        const writablePrevNode = prevNode.getWritable();
    	        writablePrevNode.__next = nodeKeyToInsert;
    	        writableNodeToInsert.__prev = writablePrevNode.__key;
    	      }

    	      if (nodeToInsert.__key === writableSelfKey) {
    	        {
    	          throw Error(`append: attempting to append self`);
    	        }
    	      } // Set child parent to self


    	      writableNodeToInsert.__parent = writableSelfKey;
    	      nodesToInsertKeys.push(nodeKeyToInsert);
    	      prevNode = nodeToInsert;
    	    }

    	    if (start + deleteCount === oldSize) {
    	      if (prevNode !== null) {
    	        const writablePrevNode = prevNode.getWritable();
    	        writablePrevNode.__next = null;
    	        writableSelf.__last = prevNode.__key;
    	      }
    	    } else if (nodeAfterRange !== null) {
    	      const writableNodeAfterRange = nodeAfterRange.getWritable();

    	      if (prevNode !== null) {
    	        const writablePrevNode = prevNode.getWritable();
    	        writableNodeAfterRange.__prev = prevNode.__key;
    	        writablePrevNode.__next = nodeAfterRange.__key;
    	      } else {
    	        writableNodeAfterRange.__prev = null;
    	      }
    	    }

    	    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes
    	    // and clean up node itself if it becomes empty. None of these needed
    	    // for insertion-only cases

    	    if (nodesToRemoveKeys.length) {
    	      // Adjusting selection, in case node that was anchor/focus will be deleted
    	      const selection = $getSelection();

    	      if ($isRangeSelection(selection)) {
    	        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
    	        const nodesToInsertKeySet = new Set(nodesToInsertKeys);
    	        const {
    	          anchor,
    	          focus
    	        } = selection;

    	        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
    	          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
    	        }

    	        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
    	          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
    	        } // Cleanup if node can't be empty


    	        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
    	          this.remove();
    	        }
    	      }
    	    }

    	    return writableSelf;
    	  } // JSON serialization


    	  exportJSON() {
    	    return {
    	      children: [],
    	      direction: this.getDirection(),
    	      format: this.getFormatType(),
    	      indent: this.getIndent(),
    	      type: 'element',
    	      version: 1
    	    };
    	  } // These are intended to be extends for specific element heuristics.


    	  insertNewAfter(selection, restoreSelection) {
    	    return null;
    	  }

    	  canInsertTab() {
    	    return false;
    	  }

    	  canIndent() {
    	    return true;
    	  }
    	  /*
    	   * This method controls the behavior of a the node during backwards
    	   * deletion (i.e., backspace) when selection is at the beginning of
    	   * the node (offset 0)
    	   */


    	  collapseAtStart(selection) {
    	    return false;
    	  }

    	  excludeFromCopy(destination) {
    	    return false;
    	  }

    	  canExtractContents() {
    	    return true;
    	  }

    	  canReplaceWith(replacement) {
    	    return true;
    	  }

    	  canInsertAfter(node) {
    	    return true;
    	  }

    	  canBeEmpty() {
    	    return true;
    	  }

    	  canInsertTextBefore() {
    	    return true;
    	  }

    	  canInsertTextAfter() {
    	    return true;
    	  }

    	  isInline() {
    	    return false;
    	  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    	  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
    	  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    	  // will return the immediate first child underneath TableCellNode instead of RootNode.


    	  isShadowRoot() {
    	    return false;
    	  }

    	  canMergeWith(node) {
    	    return false;
    	  }

    	  extractWithChild(child, selection, destination) {
    	    return false;
    	  }

    	}
    	function $isElementNode(node) {
    	  return node instanceof ElementNode;
    	}

    	function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
    	  let node = point.getNode();

    	  while (node) {
    	    const nodeKey = node.__key;

    	    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
    	      return true;
    	    }

    	    node = node.getParent();
    	  }

    	  return false;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class RootNode extends ElementNode {
    	  /** @internal */
    	  static getType() {
    	    return 'root';
    	  }

    	  static clone() {
    	    return new RootNode();
    	  }

    	  constructor() {
    	    super('root');
    	    this.__cachedText = null;
    	  }

    	  getTopLevelElementOrThrow() {
    	    {
    	      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
    	    }
    	  }

    	  getTextContent() {
    	    const cachedText = this.__cachedText;

    	    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
    	      if (cachedText !== null) {
    	        return cachedText;
    	      }
    	    }

    	    return super.getTextContent();
    	  }

    	  remove() {
    	    {
    	      throw Error(`remove: cannot be called on root nodes`);
    	    }
    	  }

    	  replace(node) {
    	    {
    	      throw Error(`replace: cannot be called on root nodes`);
    	    }
    	  }

    	  insertBefore(nodeToInsert) {
    	    {
    	      throw Error(`insertBefore: cannot be called on root nodes`);
    	    }
    	  }

    	  insertAfter(nodeToInsert) {
    	    {
    	      throw Error(`insertAfter: cannot be called on root nodes`);
    	    }
    	  } // View


    	  updateDOM(prevNode, dom) {
    	    return false;
    	  } // Mutate


    	  append(...nodesToAppend) {
    	    for (let i = 0; i < nodesToAppend.length; i++) {
    	      const node = nodesToAppend[i];

    	      if (!$isElementNode(node) && !$isDecoratorNode(node)) {
    	        {
    	          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
    	        }
    	      }
    	    }

    	    return super.append(...nodesToAppend);
    	  }

    	  static importJSON(serializedNode) {
    	    // We don't create a root, and instead use the existing root.
    	    const node = $getRoot();
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return {
    	      children: [],
    	      direction: this.getDirection(),
    	      format: this.getFormatType(),
    	      indent: this.getIndent(),
    	      type: 'root',
    	      version: 1
    	    };
    	  }

    	  collapseAtStart() {
    	    return true;
    	  }

    	}
    	function $createRootNode() {
    	  return new RootNode();
    	}
    	function $isRootNode(node) {
    	  return node instanceof RootNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function editorStateHasDirtySelection(editorState, editor) {
    	  const currentSelection = editor.getEditorState()._selection;

    	  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection

    	  if (pendingSelection !== null) {
    	    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
    	      return true;
    	    }
    	  } else if (currentSelection !== null) {
    	    return true;
    	  }

    	  return false;
    	}
    	function cloneEditorState(current) {
    	  return new EditorState(new Map(current._nodeMap));
    	}
    	function createEmptyEditorState() {
    	  return new EditorState(new Map([['root', $createRootNode()]]));
    	}

    	function exportNodeToJSON(node) {
    	  const serializedNode = node.exportJSON();
    	  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType

    	  if (serializedNode.type !== nodeClass.getType()) {
    	    {
    	      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    	    }
    	  } // @ts-expect-error TODO Replace Class utility type with InstanceType


    	  const serializedChildren = serializedNode.children;

    	  if ($isElementNode(node)) {
    	    if (!Array.isArray(serializedChildren)) {
    	      {
    	        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
    	      }
    	    }

    	    const children = node.getChildren();

    	    for (let i = 0; i < children.length; i++) {
    	      const child = children[i];
    	      const serializedChildNode = exportNodeToJSON(child);
    	      serializedChildren.push(serializedChildNode);
    	    }
    	  } // @ts-expect-error


    	  return serializedNode;
    	}

    	class EditorState {
    	  constructor(nodeMap, selection) {
    	    this._nodeMap = nodeMap;
    	    this._selection = selection || null;
    	    this._flushSync = false;
    	    this._readOnly = false;
    	  }

    	  isEmpty() {
    	    return this._nodeMap.size === 1 && this._selection === null;
    	  }

    	  read(callbackFn) {
    	    return readEditorState(this, callbackFn);
    	  }

    	  clone(selection) {
    	    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);
    	    editorState._readOnly = true;
    	    return editorState;
    	  }

    	  toJSON() {
    	    return readEditorState(this, () => ({
    	      root: exportNodeToJSON($getRoot())
    	    }));
    	  }

    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class LineBreakNode extends LexicalNode {
    	  static getType() {
    	    return 'linebreak';
    	  }

    	  static clone(node) {
    	    return new LineBreakNode(node.__key);
    	  }

    	  constructor(key) {
    	    super(key);
    	  }

    	  getTextContent() {
    	    return '\n';
    	  }

    	  createDOM() {
    	    return document.createElement('br');
    	  }

    	  updateDOM() {
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      br: node => {
    	        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it

    	        if (parentElement != null && parentElement.firstChild === node && parentElement.lastChild === node) {
    	          return null;
    	        }

    	        return {
    	          conversion: convertLineBreakElement,
    	          priority: 0
    	        };
    	      }
    	    };
    	  }

    	  static importJSON(serializedLineBreakNode) {
    	    return $createLineBreakNode();
    	  }

    	  exportJSON() {
    	    return {
    	      type: 'linebreak',
    	      version: 1
    	    };
    	  }

    	}

    	function convertLineBreakElement(node) {
    	  return {
    	    node: $createLineBreakNode()
    	  };
    	}

    	function $createLineBreakNode() {
    	  return $applyNodeReplacement(new LineBreakNode());
    	}
    	function $isLineBreakNode(node) {
    	  return node instanceof LineBreakNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	function getElementOuterTag(node, format) {
    	  if (format & IS_CODE) {
    	    return 'code';
    	  }

    	  if (format & IS_SUBSCRIPT) {
    	    return 'sub';
    	  }

    	  if (format & IS_SUPERSCRIPT) {
    	    return 'sup';
    	  }

    	  return null;
    	}

    	function getElementInnerTag(node, format) {
    	  if (format & IS_BOLD) {
    	    return 'strong';
    	  }

    	  if (format & IS_ITALIC) {
    	    return 'em';
    	  }

    	  return 'span';
    	}

    	function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
    	  const domClassList = dom.classList; // Firstly we handle the base theme.

    	  let classNames = getCachedClassNameArray(textClassNames, 'base');

    	  if (classNames !== undefined) {
    	    domClassList.add(...classNames);
    	  } // Secondly we handle the special case: underline + strikethrough.
    	  // We have to do this as we need a way to compose the fact that
    	  // the same CSS property will need to be used: text-decoration.
    	  // In an ideal world we shouldn't have to do this, but there's no
    	  // easy workaround for many atomic CSS systems today.


    	  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');
    	  let hasUnderlineStrikethrough = false;
    	  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
    	  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;

    	  if (classNames !== undefined) {
    	    if (nextUnderlineStrikethrough) {
    	      hasUnderlineStrikethrough = true;

    	      if (!prevUnderlineStrikethrough) {
    	        domClassList.add(...classNames);
    	      }
    	    } else if (prevUnderlineStrikethrough) {
    	      domClassList.remove(...classNames);
    	    }
    	  }

    	  for (const key in TEXT_TYPE_TO_FORMAT) {
    	    const format = key;
    	    const flag = TEXT_TYPE_TO_FORMAT[format];
    	    classNames = getCachedClassNameArray(textClassNames, key);

    	    if (classNames !== undefined) {
    	      if (nextFormat & flag) {
    	        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {
    	          if (prevFormat & flag) {
    	            domClassList.remove(...classNames);
    	          }

    	          continue;
    	        }

    	        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {
    	          domClassList.add(...classNames);
    	        }
    	      } else if (prevFormat & flag) {
    	        domClassList.remove(...classNames);
    	      }
    	    }
    	  }
    	}

    	function diffComposedText(a, b) {
    	  const aLength = a.length;
    	  const bLength = b.length;
    	  let left = 0;
    	  let right = 0;

    	  while (left < aLength && left < bLength && a[left] === b[left]) {
    	    left++;
    	  }

    	  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {
    	    right++;
    	  }

    	  return [left, aLength - left - right, b.slice(left, bLength - right)];
    	}

    	function setTextContent(nextText, dom, node) {
    	  const firstChild = dom.firstChild;
    	  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node

    	  const suffix = isComposing ? COMPOSITION_SUFFIX : '';
    	  const text = nextText + suffix;

    	  if (firstChild == null) {
    	    dom.textContent = text;
    	  } else {
    	    const nodeValue = firstChild.nodeValue;

    	    if (nodeValue !== text) {
    	      if (isComposing || IS_FIREFOX) {
    	        // We also use the diff composed text for general text in FF to avoid
    	        // the spellcheck red line from flickering.
    	        const [index, remove, insert] = diffComposedText(nodeValue, text);

    	        if (remove !== 0) {
    	          // @ts-expect-error
    	          firstChild.deleteData(index, remove);
    	        } // @ts-expect-error


    	        firstChild.insertData(index, insert);
    	      } else {
    	        firstChild.nodeValue = text;
    	      }
    	    }
    	  }
    	}

    	function createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {
    	  setTextContent(text, innerDOM, node);
    	  const theme = config.theme; // Apply theme class names

    	  const textClassNames = theme.text;

    	  if (textClassNames !== undefined) {
    	    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
    	  }
    	}

    	function wrapElementWith(element, tag) {
    	  const el = document.createElement(tag);
    	  el.appendChild(element);
    	  return el;
    	}
    	/** @noInheritDoc */


    	class TextNode extends LexicalNode {
    	  /** @internal */

    	  /** @internal */

    	  /** @internal */

    	  /** @internal */
    	  static getType() {
    	    return 'text';
    	  }

    	  static clone(node) {
    	    return new TextNode(node.__text, node.__key);
    	  }

    	  constructor(text, key) {
    	    super(key);
    	    this.__text = text;
    	    this.__format = 0;
    	    this.__style = '';
    	    this.__mode = 0;
    	    this.__detail = 0;
    	  }

    	  getFormat() {
    	    const self = this.getLatest();
    	    return self.__format;
    	  }

    	  getDetail() {
    	    const self = this.getLatest();
    	    return self.__detail;
    	  }

    	  getMode() {
    	    const self = this.getLatest();
    	    return TEXT_TYPE_TO_MODE[self.__mode];
    	  }

    	  getStyle() {
    	    const self = this.getLatest();
    	    return self.__style;
    	  }

    	  isToken() {
    	    const self = this.getLatest();
    	    return self.__mode === IS_TOKEN;
    	  }

    	  isComposing() {
    	    return this.__key === $getCompositionKey();
    	  }

    	  isSegmented() {
    	    const self = this.getLatest();
    	    return self.__mode === IS_SEGMENTED;
    	  }

    	  isDirectionless() {
    	    const self = this.getLatest();
    	    return (self.__detail & IS_DIRECTIONLESS) !== 0;
    	  }

    	  isUnmergeable() {
    	    const self = this.getLatest();
    	    return (self.__detail & IS_UNMERGEABLE) !== 0;
    	  }

    	  hasFormat(type) {
    	    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    	    return (this.getFormat() & formatFlag) !== 0;
    	  }

    	  isSimpleText() {
    	    return this.__type === 'text' && this.__mode === 0;
    	  }

    	  getTextContent() {
    	    const self = this.getLatest();
    	    return self.__text;
    	  }

    	  getFormatFlags(type, alignWithFormat) {
    	    const self = this.getLatest();
    	    const format = self.__format;
    	    return toggleTextFormatType(format, type, alignWithFormat);
    	  } // View


    	  createDOM(config) {
    	    const format = this.__format;
    	    const outerTag = getElementOuterTag(this, format);
    	    const innerTag = getElementInnerTag(this, format);
    	    const tag = outerTag === null ? innerTag : outerTag;
    	    const dom = document.createElement(tag);
    	    let innerDOM = dom;

    	    if (outerTag !== null) {
    	      innerDOM = document.createElement(innerTag);
    	      dom.appendChild(innerDOM);
    	    }

    	    const text = this.__text;
    	    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);
    	    const style = this.__style;

    	    if (style !== '') {
    	      dom.style.cssText = style;
    	    }

    	    return dom;
    	  }

    	  updateDOM(prevNode, dom, config) {
    	    const nextText = this.__text;
    	    const prevFormat = prevNode.__format;
    	    const nextFormat = this.__format;
    	    const prevOuterTag = getElementOuterTag(this, prevFormat);
    	    const nextOuterTag = getElementOuterTag(this, nextFormat);
    	    const prevInnerTag = getElementInnerTag(this, prevFormat);
    	    const nextInnerTag = getElementInnerTag(this, nextFormat);
    	    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
    	    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;

    	    if (prevTag !== nextTag) {
    	      return true;
    	    }

    	    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
    	      // should always be an element
    	      const prevInnerDOM = dom.firstChild;

    	      if (prevInnerDOM == null) {
    	        {
    	          throw Error(`updateDOM: prevInnerDOM is null or undefined`);
    	        }
    	      }

    	      const nextInnerDOM = document.createElement(nextInnerTag);
    	      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
    	      dom.replaceChild(nextInnerDOM, prevInnerDOM);
    	      return false;
    	    }

    	    let innerDOM = dom;

    	    if (nextOuterTag !== null) {
    	      if (prevOuterTag !== null) {
    	        innerDOM = dom.firstChild;

    	        if (innerDOM == null) {
    	          {
    	            throw Error(`updateDOM: innerDOM is null or undefined`);
    	          }
    	        }
    	      }
    	    }

    	    setTextContent(nextText, innerDOM, this);
    	    const theme = config.theme; // Apply theme class names

    	    const textClassNames = theme.text;

    	    if (textClassNames !== undefined && prevFormat !== nextFormat) {
    	      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
    	    }

    	    const prevStyle = prevNode.__style;
    	    const nextStyle = this.__style;

    	    if (prevStyle !== nextStyle) {
    	      dom.style.cssText = nextStyle;
    	    }

    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      '#text': () => ({
    	        conversion: convertTextDOMNode,
    	        priority: 0
    	      }),
    	      b: () => ({
    	        conversion: convertBringAttentionToElement,
    	        priority: 0
    	      }),
    	      br: () => ({
    	        conversion: convertLineBreakToElement,
    	        priority: 0
    	      }),
    	      code: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      em: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      i: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      s: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      span: () => ({
    	        conversion: convertSpanElement,
    	        priority: 0
    	      }),
    	      strong: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      sub: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      sup: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      }),
    	      u: () => ({
    	        conversion: convertTextFormatElement,
    	        priority: 0
    	      })
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createTextNode(serializedNode.text);
    	    node.setFormat(serializedNode.format);
    	    node.setDetail(serializedNode.detail);
    	    node.setMode(serializedNode.mode);
    	    node.setStyle(serializedNode.style);
    	    return node;
    	  } // This improves Lexical's basic text output in copy+paste plus
    	  // for headless mode where people might use Lexical to generate
    	  // HTML content and not have the ability to use CSS classes.


    	  exportDOM(editor) {
    	    let {
    	      element
    	    } = super.exportDOM(editor); // This is the only way to properly add support for most clients,
    	    // even if it's semantically incorrect to have to resort to using
    	    // <b>, <u>, <s>, <i> elements.

    	    if (element !== null) {
    	      if (this.hasFormat('bold')) {
    	        element = wrapElementWith(element, 'b');
    	      }

    	      if (this.hasFormat('italic')) {
    	        element = wrapElementWith(element, 'i');
    	      }

    	      if (this.hasFormat('strikethrough')) {
    	        element = wrapElementWith(element, 's');
    	      }

    	      if (this.hasFormat('underline')) {
    	        element = wrapElementWith(element, 'u');
    	      }
    	    }

    	    return {
    	      element
    	    };
    	  }

    	  exportJSON() {
    	    return {
    	      detail: this.getDetail(),
    	      format: this.getFormat(),
    	      mode: this.getMode(),
    	      style: this.getStyle(),
    	      text: this.getTextContent(),
    	      type: 'text',
    	      version: 1
    	    };
    	  } // Mutators


    	  selectionTransform(prevSelection, nextSelection) {
    	    return;
    	  } // TODO 0.5 This should just be a `string`.


    	  setFormat(format) {
    	    const self = this.getWritable();
    	    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;
    	    return self;
    	  } // TODO 0.5 This should just be a `string`.


    	  setDetail(detail) {
    	    const self = this.getWritable();
    	    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
    	    return self;
    	  }

    	  setStyle(style) {
    	    const self = this.getWritable();
    	    self.__style = style;
    	    return self;
    	  }

    	  toggleFormat(type) {
    	    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    	    return this.setFormat(this.getFormat() ^ formatFlag);
    	  }

    	  toggleDirectionless() {
    	    const self = this.getWritable();
    	    self.__detail ^= IS_DIRECTIONLESS;
    	    return self;
    	  }

    	  toggleUnmergeable() {
    	    const self = this.getWritable();
    	    self.__detail ^= IS_UNMERGEABLE;
    	    return self;
    	  }

    	  setMode(type) {
    	    const mode = TEXT_MODE_TO_TYPE[type];

    	    if (this.__mode === mode) {
    	      return this;
    	    }

    	    const self = this.getWritable();
    	    self.__mode = mode;
    	    return self;
    	  }

    	  setTextContent(text) {
    	    if (this.__text === text) {
    	      return this;
    	    }

    	    const self = this.getWritable();
    	    self.__text = text;
    	    return self;
    	  }

    	  select(_anchorOffset, _focusOffset) {
    	    errorOnReadOnly();
    	    let anchorOffset = _anchorOffset;
    	    let focusOffset = _focusOffset;
    	    const selection = $getSelection();
    	    const text = this.getTextContent();
    	    const key = this.__key;

    	    if (typeof text === 'string') {
    	      const lastOffset = text.length;

    	      if (anchorOffset === undefined) {
    	        anchorOffset = lastOffset;
    	      }

    	      if (focusOffset === undefined) {
    	        focusOffset = lastOffset;
    	      }
    	    } else {
    	      anchorOffset = 0;
    	      focusOffset = 0;
    	    }

    	    if (!$isRangeSelection(selection)) {
    	      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');
    	    } else {
    	      const compositionKey = $getCompositionKey();

    	      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
    	        $setCompositionKey(key);
    	      }

    	      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
    	    }

    	    return selection;
    	  }

    	  spliceText(offset, delCount, newText, moveSelection) {
    	    const writableSelf = this.getWritable();
    	    const text = writableSelf.__text;
    	    const handledTextLength = newText.length;
    	    let index = offset;

    	    if (index < 0) {
    	      index = handledTextLength + index;

    	      if (index < 0) {
    	        index = 0;
    	      }
    	    }

    	    const selection = $getSelection();

    	    if (moveSelection && $isRangeSelection(selection)) {
    	      const newOffset = offset + handledTextLength;
    	      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
    	    }

    	    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);
    	    writableSelf.__text = updatedText;
    	    return writableSelf;
    	  }

    	  canInsertTextBefore() {
    	    return true;
    	  }

    	  canInsertTextAfter() {
    	    return true;
    	  }

    	  splitText(...splitOffsets) {
    	    errorOnReadOnly();
    	    const self = this.getLatest();
    	    const textContent = self.getTextContent();
    	    const key = self.__key;
    	    const compositionKey = $getCompositionKey();
    	    const offsetsSet = new Set(splitOffsets);
    	    const parts = [];
    	    const textLength = textContent.length;
    	    let string = '';

    	    for (let i = 0; i < textLength; i++) {
    	      if (string !== '' && offsetsSet.has(i)) {
    	        parts.push(string);
    	        string = '';
    	      }

    	      string += textContent[i];
    	    }

    	    if (string !== '') {
    	      parts.push(string);
    	    }

    	    const partsLength = parts.length;

    	    if (partsLength === 0) {
    	      return [];
    	    } else if (parts[0] === textContent) {
    	      return [self];
    	    }

    	    const firstPart = parts[0];
    	    const parent = self.getParentOrThrow();
    	    let writableNode;
    	    const format = self.getFormat();
    	    const style = self.getStyle();
    	    const detail = self.__detail;
    	    let hasReplacedSelf = false;

    	    if (self.isSegmented()) {
    	      // Create a new TextNode
    	      writableNode = $createTextNode(firstPart);
    	      writableNode.__format = format;
    	      writableNode.__style = style;
    	      writableNode.__detail = detail;
    	      hasReplacedSelf = true;
    	    } else {
    	      // For the first part, update the existing node
    	      writableNode = self.getWritable();
    	      writableNode.__text = firstPart;
    	    } // Handle selection


    	    const selection = $getSelection(); // Then handle all other parts

    	    const splitNodes = [writableNode];
    	    let textSize = firstPart.length;

    	    for (let i = 1; i < partsLength; i++) {
    	      const part = parts[i];
    	      const partSize = part.length;
    	      const sibling = $createTextNode(part).getWritable();
    	      sibling.__format = format;
    	      sibling.__style = style;
    	      sibling.__detail = detail;
    	      const siblingKey = sibling.__key;
    	      const nextTextSize = textSize + partSize;

    	      if ($isRangeSelection(selection)) {
    	        const anchor = selection.anchor;
    	        const focus = selection.focus;

    	        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {
    	          anchor.key = siblingKey;
    	          anchor.offset -= textSize;
    	          selection.dirty = true;
    	        }

    	        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {
    	          focus.key = siblingKey;
    	          focus.offset -= textSize;
    	          selection.dirty = true;
    	        }
    	      }

    	      if (compositionKey === key) {
    	        $setCompositionKey(siblingKey);
    	      }

    	      textSize = nextTextSize;
    	      splitNodes.push(sibling);
    	    } // Insert the nodes into the parent's children


    	    internalMarkSiblingsAsDirty(this);
    	    const writableParent = parent.getWritable();
    	    const insertionIndex = this.getIndexWithinParent();

    	    if (hasReplacedSelf) {
    	      writableParent.splice(insertionIndex, 0, splitNodes);
    	      this.remove();
    	    } else {
    	      writableParent.splice(insertionIndex, 1, splitNodes);
    	    }

    	    if ($isRangeSelection(selection)) {
    	      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
    	    }

    	    return splitNodes;
    	  }

    	  mergeWithSibling(target) {
    	    const isBefore = target === this.getPreviousSibling();

    	    if (!isBefore && target !== this.getNextSibling()) {
    	      {
    	        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
    	      }
    	    }

    	    const key = this.__key;
    	    const targetKey = target.__key;
    	    const text = this.__text;
    	    const textLength = text.length;
    	    const compositionKey = $getCompositionKey();

    	    if (compositionKey === targetKey) {
    	      $setCompositionKey(key);
    	    }

    	    const selection = $getSelection();

    	    if ($isRangeSelection(selection)) {
    	      const anchor = selection.anchor;
    	      const focus = selection.focus;

    	      if (anchor !== null && anchor.key === targetKey) {
    	        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
    	        selection.dirty = true;
    	      }

    	      if (focus !== null && focus.key === targetKey) {
    	        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
    	        selection.dirty = true;
    	      }
    	    }

    	    const targetText = target.__text;
    	    const newText = isBefore ? targetText + text : text + targetText;
    	    this.setTextContent(newText);
    	    const writableSelf = this.getWritable();
    	    target.remove();
    	    return writableSelf;
    	  }

    	  isTextEntity() {
    	    return false;
    	  }

    	}

    	function convertSpanElement(domNode) {
    	  // domNode is a <span> since we matched it by nodeName
    	  const span = domNode; // Google Docs uses span tags + font-weight for bold text

    	  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text

    	  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text

    	  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text

    	  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript

    	  const verticalAlign = span.style.verticalAlign;
    	  return {
    	    forChild: lexicalNode => {
    	      if (!$isTextNode(lexicalNode)) {
    	        return lexicalNode;
    	      }

    	      if (hasBoldFontWeight) {
    	        lexicalNode.toggleFormat('bold');
    	      }

    	      if (hasLinethroughTextDecoration) {
    	        lexicalNode.toggleFormat('strikethrough');
    	      }

    	      if (hasItalicFontStyle) {
    	        lexicalNode.toggleFormat('italic');
    	      }

    	      if (hasUnderlineTextDecoration) {
    	        lexicalNode.toggleFormat('underline');
    	      }

    	      if (verticalAlign === 'sub') {
    	        lexicalNode.toggleFormat('subscript');
    	      }

    	      if (verticalAlign === 'super') {
    	        lexicalNode.toggleFormat('superscript');
    	      }

    	      return lexicalNode;
    	    },
    	    node: null
    	  };
    	}

    	function convertLineBreakToElement() {
    	  return {
    	    node: $createLineBreakNode()
    	  };
    	}

    	function convertBringAttentionToElement(domNode) {
    	  // domNode is a <b> since we matched it by nodeName
    	  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal

    	  const hasNormalFontWeight = b.style.fontWeight === 'normal';
    	  return {
    	    forChild: lexicalNode => {
    	      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {
    	        lexicalNode.toggleFormat('bold');
    	      }

    	      return lexicalNode;
    	    },
    	    node: null
    	  };
    	}

    	function convertTextDOMNode(domNode, _parent, preformatted) {
    	  let textContent = domNode.textContent || '';

    	  if (!preformatted && /\n/.test(textContent)) {
    	    textContent = textContent.replace(/\r?\n/gm, ' ');

    	    if (textContent.trim().length === 0) {
    	      return {
    	        node: null
    	      };
    	    }
    	  }

    	  return {
    	    node: $createTextNode(textContent)
    	  };
    	}

    	const nodeNameToTextFormat = {
    	  code: 'code',
    	  em: 'italic',
    	  i: 'italic',
    	  s: 'strikethrough',
    	  strong: 'bold',
    	  sub: 'subscript',
    	  sup: 'superscript',
    	  u: 'underline'
    	};

    	function convertTextFormatElement(domNode) {
    	  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];

    	  if (format === undefined) {
    	    return {
    	      node: null
    	    };
    	  }

    	  return {
    	    forChild: lexicalNode => {
    	      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {
    	        lexicalNode.toggleFormat(format);
    	      }

    	      return lexicalNode;
    	    },
    	    node: null
    	  };
    	}

    	function $createTextNode(text = '') {
    	  return $applyNodeReplacement(new TextNode(text));
    	}
    	function $isTextNode(node) {
    	  return node instanceof TextNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class ParagraphNode extends ElementNode {
    	  static getType() {
    	    return 'paragraph';
    	  }

    	  static clone(node) {
    	    return new ParagraphNode(node.__key);
    	  } // View


    	  createDOM(config) {
    	    const dom = document.createElement('p');
    	    const classNames = getCachedClassNameArray(config.theme, 'paragraph');

    	    if (classNames !== undefined) {
    	      const domClassList = dom.classList;
    	      domClassList.add(...classNames);
    	    }

    	    return dom;
    	  }

    	  updateDOM(prevNode, dom) {
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      p: node => ({
    	        conversion: convertParagraphElement,
    	        priority: 0
    	      })
    	    };
    	  }

    	  exportDOM(editor) {
    	    const {
    	      element
    	    } = super.exportDOM(editor);

    	    if (element && this.isEmpty()) {
    	      element.append(document.createElement('br'));
    	    }

    	    if (element) {
    	      const formatType = this.getFormatType();
    	      element.style.textAlign = formatType;
    	      const direction = this.getDirection();

    	      if (direction) {
    	        element.dir = direction;
    	      }

    	      const indent = this.getIndent();

    	      if (indent > 0) {
    	        // padding-inline-start is not widely supported in email HTML, but
    	        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.
    	        element.style.textIndent = `${indent * 20}px`;
    	      }
    	    }

    	    return {
    	      element
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createParagraphNode();
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      type: 'paragraph',
    	      version: 1
    	    };
    	  } // Mutation


    	  insertNewAfter(_, restoreSelection) {
    	    const newElement = $createParagraphNode();
    	    const direction = this.getDirection();
    	    newElement.setDirection(direction);
    	    this.insertAfter(newElement, restoreSelection);
    	    return newElement;
    	  }

    	  collapseAtStart() {
    	    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,
    	    // delete the paragraph as long as we have another sibling to go to

    	    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {
    	      const nextSibling = this.getNextSibling();

    	      if (nextSibling !== null) {
    	        this.selectNext();
    	        this.remove();
    	        return true;
    	      }

    	      const prevSibling = this.getPreviousSibling();

    	      if (prevSibling !== null) {
    	        this.selectPrevious();
    	        this.remove();
    	        return true;
    	      }
    	    }

    	    return false;
    	  }

    	}

    	function convertParagraphElement() {
    	  return {
    	    node: $createParagraphNode()
    	  };
    	}

    	function $createParagraphNode() {
    	  return $applyNodeReplacement(new ParagraphNode());
    	}
    	function $isParagraphNode(node) {
    	  return node instanceof ParagraphNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const COMMAND_PRIORITY_EDITOR = 0;
    	const COMMAND_PRIORITY_LOW = 1;
    	const COMMAND_PRIORITY_NORMAL = 2;
    	const COMMAND_PRIORITY_HIGH = 3;
    	const COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars

    	function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
    	  const keyNodeMap = editor._keyToDOMMap;
    	  keyNodeMap.clear();
    	  editor._editorState = createEmptyEditorState();
    	  editor._pendingEditorState = pendingEditorState;
    	  editor._compositionKey = null;
    	  editor._dirtyType = NO_DIRTY_NODES;

    	  editor._cloneNotNeeded.clear();

    	  editor._dirtyLeaves = new Set();

    	  editor._dirtyElements.clear();

    	  editor._normalizedNodes = new Set();
    	  editor._updateTags = new Set();
    	  editor._updates = [];
    	  editor._blockCursorElement = null;
    	  const observer = editor._observer;

    	  if (observer !== null) {
    	    observer.disconnect();
    	    editor._observer = null;
    	  } // Remove all the DOM nodes from the root element


    	  if (prevRootElement !== null) {
    	    prevRootElement.textContent = '';
    	  }

    	  if (nextRootElement !== null) {
    	    nextRootElement.textContent = '';
    	    keyNodeMap.set('root', nextRootElement);
    	  }
    	}

    	function initializeConversionCache(nodes) {
    	  const conversionCache = new Map();
    	  const handledConversions = new Set();
    	  nodes.forEach(node => {
    	    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;

    	    if (importDOM == null || handledConversions.has(importDOM)) {
    	      return;
    	    }

    	    handledConversions.add(importDOM);
    	    const map = importDOM();

    	    if (map !== null) {
    	      Object.keys(map).forEach(key => {
    	        let currentCache = conversionCache.get(key);

    	        if (currentCache === undefined) {
    	          currentCache = [];
    	          conversionCache.set(key, currentCache);
    	        }

    	        currentCache.push(map[key]);
    	      });
    	    }
    	  });
    	  return conversionCache;
    	}

    	function createEditor(editorConfig) {
    	  const config = editorConfig || {};
    	  const activeEditor = internalGetActiveEditor();
    	  const theme = config.theme || {};
    	  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;
    	  const disableEvents = config.disableEvents || false;
    	  const editorState = createEmptyEditorState();
    	  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
    	  const initialEditorState = config.editorState;
    	  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];
    	  const onError = config.onError;
    	  const isEditable = config.editable !== undefined ? config.editable : true;
    	  let registeredNodes;

    	  if (editorConfig === undefined && activeEditor !== null) {
    	    registeredNodes = activeEditor._nodes;
    	  } else {
    	    registeredNodes = new Map();

    	    for (let i = 0; i < nodes.length; i++) {
    	      let klass = nodes[i];
    	      let replacementClass = null;

    	      if (typeof klass !== 'function') {
    	        const options = klass;
    	        klass = options.replace;
    	        replacementClass = options.with;
    	      } // Ensure custom nodes implement required methods.


    	      {
    	        const name = klass.name;

    	        if (name !== 'RootNode') {
    	          const proto = klass.prototype;
    	          ['getType', 'clone'].forEach(method => {
    	            // eslint-disable-next-line no-prototype-builtins
    	            if (!klass.hasOwnProperty(method)) {
    	              console.warn(`${name} must implement static "${method}" method`);
    	            }
    	          });

    	          if ( // eslint-disable-next-line no-prototype-builtins
    	          !klass.hasOwnProperty('importDOM') && // eslint-disable-next-line no-prototype-builtins
    	          klass.hasOwnProperty('exportDOM')) {
    	            console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
    	          }

    	          if (proto instanceof DecoratorNode) {
    	            // eslint-disable-next-line no-prototype-builtins
    	            if (!proto.hasOwnProperty('decorate')) {
    	              console.warn(`${proto.constructor.name} must implement "decorate" method`);
    	            }
    	          }

    	          if ( // eslint-disable-next-line no-prototype-builtins
    	          !klass.hasOwnProperty('importJSON')) {
    	            console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
    	          }

    	          if ( // eslint-disable-next-line no-prototype-builtins
    	          !proto.hasOwnProperty('exportJSON')) {
    	            console.warn(`${name} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
    	          }
    	        }
    	      }

    	      const type = klass.getType();
    	      registeredNodes.set(type, {
    	        klass,
    	        replace: replacementClass,
    	        transforms: new Set()
    	      });
    	    }
    	  }

    	  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    	    disableEvents,
    	    namespace,
    	    theme
    	  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);

    	  if (initialEditorState !== undefined) {
    	    editor._pendingEditorState = initialEditorState;
    	    editor._dirtyType = FULL_RECONCILE;
    	  }

    	  return editor;
    	}
    	class LexicalEditor {
    	  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {
    	    this._parentEditor = parentEditor; // The root element associated with this editor

    	    this._rootElement = null; // The current editor state

    	    this._editorState = editorState; // Handling of drafts and updates

    	    this._pendingEditorState = null; // Used to help co-ordinate selection and events

    	    this._compositionKey = null;
    	    this._deferred = []; // Used during reconciliation

    	    this._keyToDOMMap = new Map();
    	    this._updates = [];
    	    this._updating = false; // Listeners

    	    this._listeners = {
    	      decorator: new Set(),
    	      editable: new Set(),
    	      mutation: new Map(),
    	      root: new Set(),
    	      textcontent: new Set(),
    	      update: new Set()
    	    }; // Commands

    	    this._commands = new Map(); // Editor configuration for theme/context.

    	    this._config = config; // Mapping of types to their nodes

    	    this._nodes = nodes; // React node decorators for portals

    	    this._decorators = {};
    	    this._pendingDecorators = null; // Used to optimize reconciliation

    	    this._dirtyType = NO_DIRTY_NODES;
    	    this._cloneNotNeeded = new Set();
    	    this._dirtyLeaves = new Set();
    	    this._dirtyElements = new Map();
    	    this._normalizedNodes = new Set();
    	    this._updateTags = new Set(); // Handling of DOM mutations

    	    this._observer = null; // Used for identifying owning editors

    	    this._key = createUID();
    	    this._onError = onError;
    	    this._htmlConversions = htmlConversions; // We don't actually make use of the `editable` argument above.
    	    // Doing so, causes e2e tests around the lock to fail.

    	    this._editable = true;
    	    this._headless = parentEditor !== null && parentEditor._headless;
    	    this._window = null;
    	    this._blockCursorElement = null;
    	  }

    	  isComposing() {
    	    return this._compositionKey != null;
    	  }

    	  registerUpdateListener(listener) {
    	    const listenerSetOrMap = this._listeners.update;
    	    listenerSetOrMap.add(listener);
    	    return () => {
    	      listenerSetOrMap.delete(listener);
    	    };
    	  }

    	  registerEditableListener(listener) {
    	    const listenerSetOrMap = this._listeners.editable;
    	    listenerSetOrMap.add(listener);
    	    return () => {
    	      listenerSetOrMap.delete(listener);
    	    };
    	  }

    	  registerDecoratorListener(listener) {
    	    const listenerSetOrMap = this._listeners.decorator;
    	    listenerSetOrMap.add(listener);
    	    return () => {
    	      listenerSetOrMap.delete(listener);
    	    };
    	  }

    	  registerTextContentListener(listener) {
    	    const listenerSetOrMap = this._listeners.textcontent;
    	    listenerSetOrMap.add(listener);
    	    return () => {
    	      listenerSetOrMap.delete(listener);
    	    };
    	  }

    	  registerRootListener(listener) {
    	    const listenerSetOrMap = this._listeners.root;
    	    listener(this._rootElement, null);
    	    listenerSetOrMap.add(listener);
    	    return () => {
    	      listener(null, this._rootElement);
    	      listenerSetOrMap.delete(listener);
    	    };
    	  }

    	  registerCommand(command, listener, priority) {
    	    if (priority === undefined) {
    	      {
    	        throw Error(`Listener for type "command" requires a "priority".`);
    	      }
    	    }

    	    const commandsMap = this._commands;

    	    if (!commandsMap.has(command)) {
    	      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);
    	    }

    	    const listenersInPriorityOrder = commandsMap.get(command);

    	    if (listenersInPriorityOrder === undefined) {
    	      {
    	        throw Error(`registerCommand: Command ${String(command)} not found in command map`);
    	      }
    	    }

    	    const listeners = listenersInPriorityOrder[priority];
    	    listeners.add(listener);
    	    return () => {
    	      listeners.delete(listener);

    	      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {
    	        commandsMap.delete(command);
    	      }
    	    };
    	  }

    	  registerMutationListener(klass, listener) {
    	    const registeredNode = this._nodes.get(klass.getType());

    	    if (registeredNode === undefined) {
    	      {
    	        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
    	      }
    	    }

    	    const mutations = this._listeners.mutation;
    	    mutations.set(listener, klass);
    	    return () => {
    	      mutations.delete(listener);
    	    };
    	  }

    	  registerNodeTransform(klass, listener) {
    	    const type = klass.getType();

    	    const registeredNode = this._nodes.get(type);

    	    if (registeredNode === undefined) {
    	      {
    	        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
    	      }
    	    }

    	    const transforms = registeredNode.transforms;
    	    transforms.add(listener);
    	    markAllNodesAsDirty(this, type);
    	    return () => {
    	      transforms.delete(listener);
    	    };
    	  }

    	  hasNodes(nodes) {
    	    for (let i = 0; i < nodes.length; i++) {
    	      const klass = nodes[i];
    	      const type = klass.getType();

    	      if (!this._nodes.has(type)) {
    	        return false;
    	      }
    	    }

    	    return true;
    	  }

    	  dispatchCommand(type, payload) {
    	    return dispatchCommand(this, type, payload);
    	  }

    	  getDecorators() {
    	    return this._decorators;
    	  }

    	  getRootElement() {
    	    return this._rootElement;
    	  }

    	  getKey() {
    	    return this._key;
    	  }

    	  setRootElement(nextRootElement) {
    	    const prevRootElement = this._rootElement;

    	    if (nextRootElement !== prevRootElement) {
    	      const classNames = getCachedClassNameArray(this._config.theme, 'root');
    	      const pendingEditorState = this._pendingEditorState || this._editorState;
    	      this._rootElement = nextRootElement;
    	      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);

    	      if (prevRootElement !== null) {
    	        // TODO: remove this flag once we no longer use UEv2 internally
    	        if (!this._config.disableEvents) {
    	          removeRootElementEvents(prevRootElement);
    	        }

    	        if (classNames != null) {
    	          prevRootElement.classList.remove(...classNames);
    	        }
    	      }

    	      if (nextRootElement !== null) {
    	        const windowObj = getDefaultView(nextRootElement);
    	        const style = nextRootElement.style;
    	        style.userSelect = 'text';
    	        style.whiteSpace = 'pre-wrap';
    	        style.wordBreak = 'break-word';
    	        nextRootElement.setAttribute('data-lexical-editor', 'true');
    	        this._window = windowObj;
    	        this._dirtyType = FULL_RECONCILE;
    	        initMutationObserver(this);

    	        this._updateTags.add('history-merge');

    	        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally

    	        if (!this._config.disableEvents) {
    	          addRootElementEvents(nextRootElement, this);
    	        }

    	        if (classNames != null) {
    	          nextRootElement.classList.add(...classNames);
    	        }
    	      } else {
    	        this._window = null;
    	      }

    	      triggerListeners('root', this, false, nextRootElement, prevRootElement);
    	    }
    	  }

    	  getElementByKey(key) {
    	    return this._keyToDOMMap.get(key) || null;
    	  }

    	  getEditorState() {
    	    return this._editorState;
    	  }

    	  setEditorState(editorState, options) {
    	    if (editorState.isEmpty()) {
    	      {
    	        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
    	      }
    	    }

    	    flushRootMutations(this);
    	    const pendingEditorState = this._pendingEditorState;
    	    const tags = this._updateTags;
    	    const tag = options !== undefined ? options.tag : null;

    	    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
    	      if (tag != null) {
    	        tags.add(tag);
    	      }

    	      commitPendingUpdates(this);
    	    }

    	    this._pendingEditorState = editorState;
    	    this._dirtyType = FULL_RECONCILE;

    	    this._dirtyElements.set('root', false);

    	    this._compositionKey = null;

    	    if (tag != null) {
    	      tags.add(tag);
    	    }

    	    commitPendingUpdates(this);
    	  }

    	  parseEditorState(maybeStringifiedEditorState, updateFn) {
    	    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
    	    return parseEditorState(serializedEditorState, this, updateFn);
    	  }

    	  update(updateFn, options) {
    	    updateEditor(this, updateFn, options);
    	  }

    	  focus(callbackFn, options = {}) {
    	    const rootElement = this._rootElement;

    	    if (rootElement !== null) {
    	      // This ensures that iOS does not trigger caps lock upon focus
    	      rootElement.setAttribute('autocapitalize', 'off');
    	      updateEditor(this, () => {
    	        const selection = $getSelection();
    	        const root = $getRoot();

    	        if (selection !== null) {
    	          // Marking the selection dirty will force the selection back to it
    	          selection.dirty = true;
    	        } else if (root.getChildrenSize() !== 0) {
    	          if (options.defaultSelection === 'rootStart') {
    	            root.selectStart();
    	          } else {
    	            root.selectEnd();
    	          }
    	        }
    	      }, {
    	        onUpdate: () => {
    	          rootElement.removeAttribute('autocapitalize');

    	          if (callbackFn) {
    	            callbackFn();
    	          }
    	        }
    	      }); // In the case where onUpdate doesn't fire (due to the focus update not
    	      // occuring).

    	      if (this._pendingEditorState === null) {
    	        rootElement.removeAttribute('autocapitalize');
    	      }
    	    }
    	  }

    	  blur() {
    	    const rootElement = this._rootElement;

    	    if (rootElement !== null) {
    	      rootElement.blur();
    	    }

    	    const domSelection = getDOMSelection(this._window);

    	    if (domSelection !== null) {
    	      domSelection.removeAllRanges();
    	    }
    	  }

    	  isEditable() {
    	    return this._editable;
    	  }

    	  setEditable(editable) {
    	    if (this._editable !== editable) {
    	      this._editable = editable;
    	      triggerListeners('editable', this, true, editable);
    	    }
    	  }

    	  toJSON() {
    	    return {
    	      editorState: this._editorState.toJSON()
    	    };
    	  }

    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class DEPRECATED_GridCellNode extends ElementNode {
    	  /** @internal */
    	  constructor(colSpan, key) {
    	    super(key);
    	    this.__colSpan = colSpan;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      colSpan: this.__colSpan
    	    };
    	  }

    	}
    	function DEPRECATED_$isGridCellNode(node) {
    	  return node instanceof DEPRECATED_GridCellNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	class DEPRECATED_GridNode extends ElementNode {}
    	function DEPRECATED_$isGridNode(node) {
    	  return node instanceof DEPRECATED_GridNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	class DEPRECATED_GridRowNode extends ElementNode {}
    	function DEPRECATED_$isGridRowNode(node) {
    	  return node instanceof DEPRECATED_GridRowNode;
    	}

    	Lexical_dev.$addUpdateTag = $addUpdateTag;
    	Lexical_dev.$applyNodeReplacement = $applyNodeReplacement;
    	Lexical_dev.$copyNode = $copyNode;
    	Lexical_dev.$createLineBreakNode = $createLineBreakNode;
    	Lexical_dev.$createNodeSelection = $createNodeSelection;
    	Lexical_dev.$createParagraphNode = $createParagraphNode;
    	Lexical_dev.$createRangeSelection = $createRangeSelection;
    	Lexical_dev.$createTextNode = $createTextNode;
    	Lexical_dev.$getAdjacentNode = $getAdjacentNode;
    	Lexical_dev.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;
    	Lexical_dev.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;
    	Lexical_dev.$getNodeByKey = $getNodeByKey;
    	Lexical_dev.$getPreviousSelection = $getPreviousSelection;
    	Lexical_dev.$getRoot = $getRoot;
    	Lexical_dev.$getSelection = $getSelection;
    	Lexical_dev.$getTextContent = $getTextContent;
    	Lexical_dev.$hasAncestor = $hasAncestor;
    	Lexical_dev.$insertNodes = $insertNodes;
    	Lexical_dev.$isDecoratorNode = $isDecoratorNode;
    	Lexical_dev.$isElementNode = $isElementNode;
    	Lexical_dev.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;
    	Lexical_dev.$isLeafNode = $isLeafNode;
    	Lexical_dev.$isLineBreakNode = $isLineBreakNode;
    	Lexical_dev.$isNodeSelection = $isNodeSelection;
    	Lexical_dev.$isParagraphNode = $isParagraphNode;
    	Lexical_dev.$isRangeSelection = $isRangeSelection;
    	Lexical_dev.$isRootNode = $isRootNode;
    	Lexical_dev.$isRootOrShadowRoot = $isRootOrShadowRoot;
    	Lexical_dev.$isTextNode = $isTextNode;
    	Lexical_dev.$nodesOfType = $nodesOfType;
    	Lexical_dev.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;
    	Lexical_dev.$parseSerializedNode = $parseSerializedNode;
    	Lexical_dev.$setCompositionKey = $setCompositionKey;
    	Lexical_dev.$setSelection = $setSelection;
    	Lexical_dev.BLUR_COMMAND = BLUR_COMMAND;
    	Lexical_dev.CAN_REDO_COMMAND = CAN_REDO_COMMAND;
    	Lexical_dev.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;
    	Lexical_dev.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;
    	Lexical_dev.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;
    	Lexical_dev.CLICK_COMMAND = CLICK_COMMAND;
    	Lexical_dev.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;
    	Lexical_dev.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;
    	Lexical_dev.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;
    	Lexical_dev.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;
    	Lexical_dev.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;
    	Lexical_dev.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;
    	Lexical_dev.COPY_COMMAND = COPY_COMMAND;
    	Lexical_dev.CUT_COMMAND = CUT_COMMAND;
    	Lexical_dev.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;
    	Lexical_dev.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;
    	Lexical_dev.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;
    	Lexical_dev.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;
    	Lexical_dev.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;
    	Lexical_dev.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;
    	Lexical_dev.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;
    	Lexical_dev.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;
    	Lexical_dev.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;
    	Lexical_dev.DEPRECATED_GridNode = DEPRECATED_GridNode;
    	Lexical_dev.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;
    	Lexical_dev.DRAGEND_COMMAND = DRAGEND_COMMAND;
    	Lexical_dev.DRAGOVER_COMMAND = DRAGOVER_COMMAND;
    	Lexical_dev.DRAGSTART_COMMAND = DRAGSTART_COMMAND;
    	Lexical_dev.DROP_COMMAND = DROP_COMMAND;
    	Lexical_dev.DecoratorNode = DecoratorNode;
    	Lexical_dev.ElementNode = ElementNode;
    	Lexical_dev.FOCUS_COMMAND = FOCUS_COMMAND;
    	Lexical_dev.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;
    	Lexical_dev.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;
    	Lexical_dev.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;
    	Lexical_dev.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;
    	Lexical_dev.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;
    	Lexical_dev.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;
    	Lexical_dev.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;
    	Lexical_dev.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;
    	Lexical_dev.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;
    	Lexical_dev.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;
    	Lexical_dev.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;
    	Lexical_dev.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;
    	Lexical_dev.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;
    	Lexical_dev.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;
    	Lexical_dev.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;
    	Lexical_dev.KEY_TAB_COMMAND = KEY_TAB_COMMAND;
    	Lexical_dev.LineBreakNode = LineBreakNode;
    	Lexical_dev.MOVE_TO_END = MOVE_TO_END;
    	Lexical_dev.MOVE_TO_START = MOVE_TO_START;
    	Lexical_dev.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;
    	Lexical_dev.PASTE_COMMAND = PASTE_COMMAND;
    	Lexical_dev.ParagraphNode = ParagraphNode;
    	Lexical_dev.REDO_COMMAND = REDO_COMMAND;
    	Lexical_dev.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;
    	Lexical_dev.RootNode = RootNode;
    	Lexical_dev.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;
    	Lexical_dev.TextNode = TextNode;
    	Lexical_dev.UNDO_COMMAND = UNDO_COMMAND;
    	Lexical_dev.createCommand = createCommand;
    	Lexical_dev.createEditor = createEditor;
    	return Lexical_dev;
    }

    var Lexical_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexical_prod;

    function requireLexical_prod () {
    	if (hasRequiredLexical_prod) return Lexical_prod;
    	hasRequiredLexical_prod = 1;
    let aa={},ba={},ca={},ea={},fa={},ha={},ia={},ja={},ka={},ma={},na={},oa={},pa={},qa={},ra={},sa={},ua={},va={},wa={},xa={},ya={},za={},Aa={},Ba={},Ca={},Ea={},Fa={},Ga={},Ha={},Ia={},Ja={},Ka={},La={},Ma={};function q(a){throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or `+"use the non-minified dev environment for full errors and additional helpful warnings.");}
    	let Na="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,Oa=Na&&"documentMode"in document?document.documentMode:null,t=Na&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),Pa=Na&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),Qa=Na&&"InputEvent"in window&&!Oa?"getTargetRanges"in new window.InputEvent("input"):!1,Ra=Na&&/Version\/[\d.]+.*Safari/.test(navigator.userAgent),Sa=Na&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&
    	!window.MSStream,Ta=Na&&/^(?=.*Chrome).*/i.test(navigator.userAgent),Ua=Ra||Sa?"\u00a0":"\u200b",Wa=Pa?"\u00a0":Ua,Xa=/^[^A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]*[\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]/,Ya=/^[^\u0591-\u07ff\ufb1d-\ufdfd\ufe70-\ufefc]*[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0800-\u1fff\u200e\u2c00-\ufb1c\ufe00-\ufe6f\ufefd-\uffff]/,Za={bold:1,code:16,italic:2,strikethrough:4,subscript:32,
    	superscript:64,underline:8},$a={directionless:1,unmergeable:2},ab={center:2,end:6,justify:4,left:1,right:3,start:5},bb={2:"center",6:"end",4:"justify",1:"left",3:"right",5:"start"},cb={normal:0,segmented:2,token:1},db={0:"normal",2:"segmented",1:"token"},eb=!1,fb=0;function gb(a){fb=a.timeStamp;}function hb(a,b,c){return b.__lexicalLineBreak===a||void 0!==a[`__lexicalKey_${c._key}`]}function ib(a){return a.getEditorState().read(()=>{let b=u();return null!==b?b.clone():null})}
    	function jb(a,b,c){eb=!0;let d=100<performance.now()-fb;try{v(a,()=>{let e=u()||ib(a);var f=new Map,g=a.getRootElement(),h=a._editorState,k=a._blockCursorElement;let l=!1,m="";for(var p=0;p<b.length;p++){var n=b[p],r=n.type,w=n.target,y=kb(w,h);if(!(null===y&&w!==g||z(y)))if("characterData"===r){if(n=d&&B(y))a:{n=e;r=w;var x=y;if(C(n)){var A=n.anchor.getNode();if(A.is(x)&&n.format!==A.getFormat()){n=!1;break a}}n=3===r.nodeType&&x.isAttached();}n&&(x=D(a._window),r=n=null,null!==x&&x.anchorNode===
    	w&&(n=x.anchorOffset,r=x.focusOffset),w=w.nodeValue,null!==w&&lb(y,w,n,r,!1));}else if("childList"===r){l=!0;r=n.addedNodes;for(x=0;x<r.length;x++){A=r[x];var U=mb(A),I=A.parentNode;null==I||A===k||null!==U||"BR"===A.nodeName&&hb(A,I,a)||(Pa&&(U=A.innerText||A.nodeValue)&&(m+=U),I.removeChild(A));}n=n.removedNodes;r=n.length;if(0<r){x=0;for(A=0;A<r;A++)if(I=n[A],"BR"===I.nodeName&&hb(I,w,a)||k===I)w.appendChild(I),x++;r!==x&&(w===g&&(y=h._nodeMap.get("root")),f.set(w,y));}}}if(0<f.size)for(let [da,N]of f)if(E(N))for(f=
    	N.getChildrenKeys(),g=da.firstChild,h=0;h<f.length;h++)k=a.getElementByKey(f[h]),null!==k&&(null==g?(da.appendChild(k),g=k):g!==k&&da.replaceChild(k,g),g=g.nextSibling);else B(N)&&N.markDirty();f=c.takeRecords();if(0<f.length){for(g=0;g<f.length;g++)for(k=f[g],h=k.addedNodes,k=k.target,p=0;p<h.length;p++)y=h[p],w=y.parentNode,null==w||"BR"!==y.nodeName||hb(y,k,a)||w.removeChild(y);c.takeRecords();}null!==e&&(l&&(e.dirty=!0,nb(e)),Pa&&ob(a)&&e.insertRawText(m));});}finally{eb=!1;}}
    	function pb(a){let b=a._observer;if(null!==b){let c=b.takeRecords();jb(a,c,b);}}function qb(a){0===fb&&rb(a).addEventListener("textInput",gb,!0);a._observer=new MutationObserver((b,c)=>{jb(a,b,c);});}let sb=1,tb="function"===typeof queueMicrotask?queueMicrotask:a=>{Promise.resolve().then(a);};function wb(a){let b=document.activeElement;if(null===b)return !1;let c=b.nodeName;return z(kb(a))&&("INPUT"===c||"TEXTAREA"===c||"true"===b.contentEditable&&null==b.__lexicalEditor)}
    	function xb(a,b,c){let d=a.getRootElement();try{return null!==d&&d.contains(b)&&d.contains(c)&&null!==b&&!wb(b)&&yb(b)===a}catch(e){return !1}}function yb(a){for(;null!=a;){let b=a.__lexicalEditor;if(null!=b)return b;a=zb(a);}return null}function Ab(a){return a.isToken()||a.isSegmented()}function Bb(a){for(;null!=a;){if(3===a.nodeType)return a;a=a.firstChild;}return null}function Cb(a,b,c){b=Za[b];return a&b&&(null===c||0===(c&b))?a^b:null===c||c&b?a|b:a}function Db(a){return B(a)||Eb(a)||z(a)}
    	function Fb(a,b){if(null!=b)a.__key=b;else {F();99<Gb&&q(14);b=G();var c=H(),d=""+sb++;c._nodeMap.set(d,a);E(a)?b._dirtyElements.set(d,!0):b._dirtyLeaves.add(d);b._cloneNotNeeded.add(d);b._dirtyType=1;a.__key=d;}}
    	function Hb(a){var b=a.getParent();if(null!==b){let e=a.getWritable();b=b.getWritable();var c=a.getPreviousSibling();a=a.getNextSibling();if(null===c)if(null!==a){var d=a.getWritable();b.__first=a.__key;d.__prev=null;}else b.__first=null;else {d=c.getWritable();if(null!==a){let f=a.getWritable();f.__prev=d.__key;d.__next=f.__key;}else d.__next=null;e.__prev=null;}null===a?null!==c?(a=c.getWritable(),b.__last=c.__key,a.__next=null):b.__last=null:(a=a.getWritable(),null!==c?(c=c.getWritable(),c.__next=
    	a.__key,a.__prev=c.__key):a.__prev=null,e.__next=null);b.__size--;e.__parent=null;}}function Ib(a){99<Gb&&q(14);var b=a.getLatest(),c=b.__parent,d=H();let e=G(),f=d._nodeMap;d=e._dirtyElements;if(null!==c)a:for(;null!==c;){if(d.has(c))break a;let g=f.get(c);if(void 0===g)break;d.set(c,!1);c=g.__parent;}b=b.__key;e._dirtyType=1;E(a)?d.set(b,!0):e._dirtyLeaves.add(b);}
    	function J(a){F();var b=G();let c=b._compositionKey;a!==c&&(b._compositionKey=a,null!==c&&(b=K(c),null!==b&&b.getWritable()),null!==a&&(a=K(a),null!==a&&a.getWritable()));}function Jb(){return Kb()?null:G()._compositionKey}function K(a,b){a=(b||H())._nodeMap.get(a);return void 0===a?null:a}function mb(a,b){let c=G();a=a[`__lexicalKey_${c._key}`];return void 0!==a?K(a,b):null}function kb(a,b){for(;null!=a;){let c=mb(a,b);if(null!==c)return c;a=zb(a);}return null}
    	function Lb(a){let b=Object.assign({},a._decorators);return a._pendingDecorators=b}function Mb(a){return a.read(()=>Nb().getTextContent())}function Ob(a,b){v(a,()=>{var c=H();if(!c.isEmpty())if("root"===b)Nb().markDirty();else {c=c._nodeMap;for(let [,d]of c)d.markDirty();}},null===a._pendingEditorState?{tag:"history-merge"}:void 0);}function Nb(){return H()._nodeMap.get("root")}function nb(a){F();let b=H();null!==a&&(a.dirty=!0,a._cachedNodes=null);b._selection=a;}
    	function Pb(a){var b=G(),c;a:{for(c=a;null!=c;){let d=c[`__lexicalKey_${b._key}`];if(void 0!==d){c=d;break a}c=zb(c);}c=null;}return null===c?(b=b.getRootElement(),a===b?K("root"):null):K(c)}function Qb(a){return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(a)}function Rb(a){let b=[];for(;null!==a;)b.push(a),a=a._parentEditor;return b}function Sb(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(0,5)}
    	function Tb(a,b,c){b=D(b._window);if(null!==b){var d=b.anchorNode,{anchorOffset:e,focusOffset:f}=b;if(null!==d&&(b=3===d.nodeType?d.nodeValue:null,d=kb(d),null!==b&&B(d))){if(b===Ua&&c){let g=c.length;b=c;f=e=g;}null!==b&&lb(d,b,e,f,a);}}}
    	function lb(a,b,c,d,e){let f=a;if(f.isAttached()&&(e||!f.isDirty())){var g=f.isComposing();a=b;(g||e)&&b[b.length-1]===Ua&&(a=b.slice(0,-1));b=f.getTextContent();if(e||a!==b)if(""===a)if(J(null),Ra||Sa)f.remove();else {let l=G();setTimeout(()=>{l.update(()=>{f.isAttached()&&f.remove();});},20);}else {e=f.getParent();b=Ub();var h=Jb(),k=f.getKey();f.isToken()||null!==h&&k===h&&!g||null!==e&&C(b)&&!e.canInsertTextBefore()&&0===b.anchor.offset?f.markDirty():(g=u(),C(g)&&null!==c&&null!==d&&(g.setTextNodeRange(f,
    	c,f,d),f.isSegmented()&&(c=f.getTextContent(),c=M(c),f.replace(c),f=c)),f.setTextContent(a));}}}function Vb(a,b){if(b.isSegmented())return !0;if(!a.isCollapsed())return !1;a=a.anchor.offset;let c=b.getParentOrThrow(),d=b.isToken();return 0===a?((a=!b.canInsertTextBefore()||!c.canInsertTextBefore()||d)||(b=b.getPreviousSibling(),a=(B(b)||E(b)&&b.isInline())&&!b.canInsertTextAfter()),a):a===b.getTextContentSize()?!b.canInsertTextAfter()||!c.canInsertTextAfter()||d:!1}
    	function Wb(a,b){var c=a[b];return "string"===typeof c?(c=c.split(" "),a[b]=c):c}function Xb(a,b,c,d,e){0!==c.size&&(c=d.__key,b=b.get(d.__type),void 0===b&&q(33),d=b.klass,b=a.get(d),void 0===b&&(b=new Map,a.set(d,b)),a=b.get(c),d="destroyed"===a&&"created"===e,(void 0===a||d)&&b.set(c,d?"updated":e));}function Yb(a,b,c){let d=a.getParent(),e=c;null!==d&&(b&&0===c?(e=a.getIndexWithinParent(),a=d):b||c!==a.getChildrenSize()||(e=a.getIndexWithinParent()+1,a=d));return a.getChildAtIndex(b?e-1:e)}
    	function Zb(a,b){var c=a.offset;if("element"===a.type)return a=a.getNode(),Yb(a,b,c);a=a.getNode();return b&&0===c||!b&&c===a.getTextContentSize()?(c=b?a.getPreviousSibling():a.getNextSibling(),null===c?Yb(a.getParentOrThrow(),b,a.getIndexWithinParent()+(b?0:1)):c):null}function ob(a){a=(a=rb(a).event)&&a.inputType;return "insertFromPaste"===a||"insertFromPasteAsQuotation"===a}function $b(a){return !O(a)&&!a.isLastChild()&&!a.isInline()}
    	function ac(a,b){a=a._keyToDOMMap.get(b);void 0===a&&q(75);return a}function zb(a){a=a.assignedSlot||a.parentElement;return null!==a&&11===a.nodeType?a.host:a}
    	function bc(a,b,c){let d=c.ownerDocument,e=d.defaultView;if(null!==e){var {top:f,bottom:g}=b;for(b=c;null!==b;){if(c=b===d.body){var h=0;var k=rb(a).innerHeight;}else {var l=b.getBoundingClientRect();h=l.top;k=l.bottom;}l=0;f<h?l=-(h-f):g>k&&(l=g-k);0!==l&&(c?e.scrollBy(0,l):(h=b.scrollTop,b.scrollTop+=l,h=b.scrollTop-h,f-=h,g-=h));if(c)break;b=zb(b);}}}
    	function cc(a,b=0){0!==b&&q(1);b=u();if(!C(b)||!E(a))return b;let {anchor:c,focus:d}=b,e=c.getNode(),f=d.getNode();dc(e,a)&&c.set(a.__key,0,"element");dc(f,a)&&d.set(a.__key,0,"element");return b}function dc(a,b){for(a=a.getParent();null!==a;){if(a.is(b))return !0;a=a.getParent();}return !1}function rb(a){a=a._window;null===a&&q(78);return a}function ec(a){for(a=a.getParentOrThrow();null!==a&&!fc(a);)a=a.getParentOrThrow();return a}function fc(a){return O(a)||E(a)&&a.isShadowRoot()}
    	function gc(a){var b=G();let c=a.constructor.getType();b=b._nodes.get(c);void 0===b&&q(97);b=b.replace;return null!==b?(b=b(a),b instanceof a.constructor||q(98),b):a}function hc(a,b){a=a.getParent();!O(a)||E(b)||z(b)||q(99);}function ic(a){return (z(a)||E(a)&&!a.canBeEmpty())&&!a.isInline()}function jc(a,b,c){c.style.removeProperty("caret-color");b._blockCursorElement=null;b=a.parentElement;null!==b&&b.removeChild(a);}function D(a){return Na?(a||window).getSelection():null}
    	function kc(a,b,c,d,e){for(a=a.getFirstChild();null!==a;){let f=a.__key;void 0!==a&&a.__parent===b&&(E(a)&&kc(a,f,c,d,e),c.has(f)||e.delete(f),d.delete(f));a=a.isAttached()?a.getNextSibling():null;}}function mc(a,b,c,d){a=a._nodeMap;b=b._nodeMap;for(let e of c){let f=b.get(e);void 0===f||f.isAttached()||(a.has(e)||c.delete(e),b.delete(e));}for(let [e]of d)c=b.get(e),void 0===c||c.isAttached()||(E(c)&&kc(c,e,a,b,d),a.has(e)||d.delete(e),b.delete(e));}
    	function nc(a,b){let c=a.__mode,d=a.__format;a=a.__style;let e=b.__mode,f=b.__format;b=b.__style;return (null===c||c===e)&&(null===d||d===f)&&(null===a||a===b)}function oc(a,b){let c=a.mergeWithSibling(b),d=G()._normalizedNodes;d.add(a.__key);d.add(b.__key);return c}
    	function pc(a){if(""===a.__text&&a.isSimpleText()&&!a.isUnmergeable())a.remove();else {for(var b;null!==(b=a.getPreviousSibling())&&B(b)&&b.isSimpleText()&&!b.isUnmergeable();)if(""===b.__text)b.remove();else {nc(b,a)&&(a=oc(b,a));break}for(var c;null!==(c=a.getNextSibling())&&B(c)&&c.isSimpleText()&&!c.isUnmergeable();)if(""===c.__text)c.remove();else {nc(a,c)&&oc(a,c);break}}}function qc(a){rc(a.anchor);rc(a.focus);return a}
    	function rc(a){for(;"element"===a.type;){var b=a.getNode(),c=a.offset;c===b.getChildrenSize()?(b=b.getChildAtIndex(c-1),c=!0):(b=b.getChildAtIndex(c),c=!1);if(B(b)){a.set(b.__key,c?b.getTextContentSize():0,"text");break}else if(!E(b))break;a.set(b.__key,c?b.getChildrenSize():0,"element");}}let P="",Q="",R="",sc,S,tc,uc=!1,vc=!1,wc,xc=null,yc,zc,Ac,Bc,Cc,Dc;
    	function Ec(a,b){let c=Ac.get(a);if(null!==b){let d=Fc(a);d.parentNode===b&&b.removeChild(d);}Bc.has(a)||S._keyToDOMMap.delete(a);E(c)&&(a=Gc(c,Ac),Hc(a,0,a.length-1,null));void 0!==c&&Xb(Dc,tc,wc,c,"destroyed");}function Hc(a,b,c,d){for(;b<=c;++b){let e=a[b];void 0!==e&&Ec(e,d);}}function Ic(a,b){a.setProperty("text-align",b);}function Jc(a,b){a.style.setProperty("padding-inline-start",0===b?"":20*b+"px");}
    	function Kc(a,b){a=a.style;0===b?Ic(a,""):1===b?Ic(a,"left"):2===b?Ic(a,"center"):3===b?Ic(a,"right"):4===b?Ic(a,"justify"):5===b?Ic(a,"start"):6===b&&Ic(a,"end");}
    	function Lc(a,b,c){let d=Bc.get(a);void 0===d&&q(60);let e=d.createDOM(sc,S);var f=S._keyToDOMMap;e["__lexicalKey_"+S._key]=a;f.set(a,e);B(d)?e.setAttribute("data-lexical-text","true"):z(d)&&e.setAttribute("data-lexical-decorator","true");if(E(d)){a=d.__indent;f=d.__size;0!==a&&Jc(e,a);if(0!==f){--f;a=Gc(d,Bc);var g=Q;Q="";Mc(a,0,f,e,null);Nc(d,e);Q=g;$b(d)&&(P+="\n\n",e.__lexicalTextContent=P);}a=d.__format;0!==a&&Kc(e,a);d.isInline()||Oc(null,d,e);$b(d)&&(P+="\n\n",R+="\n\n");}else f=d.getTextContent(),
    	z(d)?(g=d.decorate(S,sc),null!==g&&Pc(a,g),e.contentEditable="false"):B(d)&&(d.isDirectionless()||(Q+=f)),P+=f,R+=f;null!==b&&(null!=c?b.insertBefore(e,c):(c=b.__lexicalLineBreak,null!=c?b.insertBefore(e,c):b.appendChild(e)));Xb(Dc,tc,wc,d,"created");return e}function Mc(a,b,c,d,e){let f=P;for(P="";b<=c;++b)Lc(a[b],d,e);d.__lexicalTextContent=P;P=f+P;}function Qc(a,b){a=b.get(a);return Eb(a)||z(a)&&a.isInline()}
    	function Oc(a,b,c){a=null!==a&&(0===a.__size||Qc(a.__last,Ac));b=0===b.__size||Qc(b.__last,Bc);a?b||(b=c.__lexicalLineBreak,null!=b&&c.removeChild(b),c.__lexicalLineBreak=null):b&&(b=document.createElement("br"),c.__lexicalLineBreak=b,c.appendChild(b));}
    	function Nc(a,b){var c=b.__lexicalDir;if(b.__lexicalDirTextContent!==Q||c!==xc){let f=""===Q;if(f)var d=xc;else d=Q,d=Xa.test(d)?"rtl":Ya.test(d)?"ltr":null;if(d!==c){let g=b.classList,h=sc.theme;var e=null!==c?h[c]:void 0;let k=null!==d?h[d]:void 0;void 0!==e&&("string"===typeof e&&(e=e.split(" "),e=h[c]=e),g.remove(...e));null===d||f&&"ltr"===d?b.removeAttribute("dir"):(void 0!==k&&("string"===typeof k&&(c=k.split(" "),k=h[d]=c),void 0!==k&&g.add(...k)),b.dir=d);vc||(a.getWritable().__dir=d);}xc=
    	d;b.__lexicalDirTextContent=Q;b.__lexicalDir=d;}}function Gc(a,b){let c=[];for(a=a.__first;null!==a;){let d=b.get(a);void 0===d&&q(101);c.push(a);a=d.__next;}return c}
    	function Rc(a,b){var c=Ac.get(a),d=Bc.get(a);void 0!==c&&void 0!==d||q(61);var e=uc||zc.has(a)||yc.has(a);let f=ac(S,a);if(c===d&&!e)return E(c)?(d=f.__lexicalTextContent,void 0!==d&&(P+=d,R+=d),d=f.__lexicalDirTextContent,void 0!==d&&(Q+=d)):(d=c.getTextContent(),B(c)&&!c.isDirectionless()&&(Q+=d),R+=d,P+=d),f;c!==d&&e&&Xb(Dc,tc,wc,d,"updated");if(d.updateDOM(c,f,sc))return d=Lc(a,null,null),null===b&&q(62),b.replaceChild(d,f),Ec(a,null),d;if(E(c)&&E(d)){a=d.__indent;a!==c.__indent&&Jc(f,a);a=d.__format;
    	a!==c.__format&&Kc(f,a);if(e){a=d;e=Q;Q="";b=P;var g=c.__size,h=a.__size;P="";if(1===g&&1===h){var k=c.__first,l=a.__first;if(k===l)Rc(k,f);else {var m=Fc(k);l=Lc(l,null,null);f.replaceChild(l,m);Ec(k,null);}}else {l=Gc(c,Ac);var p=Gc(a,Bc);if(0===g)0!==h&&Mc(p,0,h-1,f,null);else if(0===h)0!==g&&(k=null==f.__lexicalLineBreak,Hc(l,0,g-1,k?null:f),k&&(f.textContent=""));else {var n=l;l=p;p=g-1;g=h-1;let w=f.firstChild,y=0;for(h=0;y<=p&&h<=g;){var r=n[y];let x=l[h];if(r===x)w=Sc(Rc(x,f)),y++,h++;else {void 0===
    	k&&(k=new Set(n));void 0===m&&(m=new Set(l));let A=m.has(r),U=k.has(x);A?(U?(r=ac(S,x),r===w?w=Sc(Rc(x,f)):(null!=w?f.insertBefore(r,w):f.appendChild(r),Rc(x,f)),y++):Lc(x,f,w),h++):(w=Sc(Fc(r)),Ec(r,f),y++);}}k=y>p;m=h>g;k&&!m?(k=l[g+1],k=void 0===k?null:S.getElementByKey(k),Mc(l,h,g,f,k)):m&&!k&&Hc(n,y,p,f);}}$b(a)&&(P+="\n\n");f.__lexicalTextContent=P;P=b+P;Nc(a,f);Q=e;O(d)||d.isInline()||Oc(c,d,f);}$b(d)&&(P+="\n\n",R+="\n\n");}else c=d.getTextContent(),z(d)?(e=d.decorate(S,sc),null!==e&&Pc(a,e)):
    	B(d)&&!d.isDirectionless()&&(Q+=c),P+=c,R+=c;!vc&&O(d)&&d.__cachedText!==R&&(d=d.getWritable(),d.__cachedText=R);return f}function Pc(a,b){let c=S._pendingDecorators,d=S._decorators;if(null===c){if(d[a]===b)return;c=Lb(S);}c[a]=b;}function Sc(a){a=a.nextSibling;null!==a&&a===S._blockCursorElement&&(a=a.nextSibling);return a}function Fc(a){a=Cc.get(a);void 0===a&&q(75);return a}
    	let Tc=Object.freeze({}),$c=[["keydown",Uc],["pointerdown",Vc],["compositionstart",Wc],["compositionend",Xc],["input",Yc],["click",Zc],["cut",Tc],["copy",Tc],["dragstart",Tc],["dragover",Tc],["dragend",Tc],["paste",Tc],["focus",Tc],["blur",Tc],["drop",Tc]];Qa&&$c.push(["beforeinput",(a,b)=>ad(a,b)]);let bd=0,cd=0,dd=0,ed=0,fd=!1,gd=!1,hd=!1,id=!1,jd=[0,0,"root",0];
    	function kd(a,b,c,d){let e=a.anchor,f=a.focus,g=e.getNode();var h=G(),k=D(h._window);k=null!==k?k.anchorNode:null;let l=e.key;h=h.getElementByKey(l);let m=b.length;return l!==f.key||!B(g)||(!d&&(!Qa||dd<c+50)||2>m||Qb(b))&&e.offset!==f.offset&&!g.isComposing()||Ab(g)||g.isDirty()&&1<m||(d||!Qa)&&null!==h&&!g.isComposing()&&k!==Bb(h)||g.getFormat()!==a.format||Vb(a,g)}function ld(a,b){return null!==a&&null!==a.nodeValue&&3===a.nodeType&&0!==b&&b!==a.nodeValue.length}
    	function md(a,b,c){let {anchorNode:d,anchorOffset:e,focusNode:f,focusOffset:g}=a;if(fd&&(fd=!1,ld(d,e)&&ld(f,g)))return;v(b,()=>{if(!c)nb(null);else if(xb(b,d,f)){var h=u();if(C(h)){var k=h.anchor,l=k.getNode();if(h.isCollapsed()){"Range"===a.type&&a.anchorNode===a.focusNode&&(h.dirty=!0);var m=rb(b).event;m=m?m.timeStamp:performance.now();let [p,n,r,w]=jd;m<w+200&&k.offset===n&&k.key===r?h.format=p:"text"===k.type?h.format=l.getFormat():"element"===k.type&&(h.format=0);}else {k=127;l=!1;m=h.getNodes();
    	let p=m.length;for(let n=0;n<p;n++){let r=m[n];if(B(r)&&(l=!0,k&=r.getFormat(),0===k))break}h.format=l?k:0;}}T(b,aa,void 0);}});}function Zc(a,b){v(b,()=>{let c=u(),d=D(b._window),e=Ub();if(C(c)){let f=c.anchor,g=f.getNode();d&&"element"===f.type&&0===f.offset&&c.isCollapsed()&&!O(g)&&1===Nb().getChildrenSize()&&g.getTopLevelElementOrThrow().isEmpty()&&null!==e&&c.is(e)&&(d.removeAllRanges(),c.dirty=!0);}T(b,ba,a);});}
    	function Vc(a,b){let c=a.target;a=a.pointerType;c instanceof Node&&"touch"!==a&&v(b,()=>{z(kb(c))||(gd=!0);});}function nd(a,b){b.getTargetRanges&&(b=b.getTargetRanges()[0])&&a.applyDOMRange(b);}function od(a,b){return a!==b||E(a)||E(b)||!a.isToken()||!b.isToken()}
    	function ad(a,b){let c=a.inputType;"deleteCompositionText"===c||Pa&&ob(b)||"insertCompositionText"!==c&&v(b,()=>{let d=u();if("deleteContentBackward"===c){if(null===d){var e=Ub();if(!C(e))return;nb(e.clone());}if(C(d)){229===cd&&a.timeStamp<bd+30&&b.isComposing()&&d.anchor.key===d.focus.key?(J(null),bd=0,setTimeout(()=>{v(b,()=>{J(null);});},30),C(d)&&(e=d.anchor.getNode(),e.markDirty(),d.format=e.getFormat())):(a.preventDefault(),T(b,ca,!0));return}}if(C(d)){e=a.data;d.dirty||!d.isCollapsed()||O(d.anchor.getNode())||
    	nd(d,a);var f=d.focus,g=d.anchor.getNode();f=f.getNode();if("insertText"===c||"insertTranspose"===c)"\n"===e?(a.preventDefault(),T(b,ea,!1)):"\n\n"===e?(a.preventDefault(),T(b,fa,void 0)):null==e&&a.dataTransfer?(e=a.dataTransfer.getData("text/plain"),a.preventDefault(),d.insertRawText(e)):null!=e&&kd(d,e,a.timeStamp,!0)&&(a.preventDefault(),T(b,ha,e)),dd=a.timeStamp;else switch(a.preventDefault(),c){case "insertFromYank":case "insertFromDrop":case "insertReplacementText":T(b,ha,a);break;case "insertFromComposition":J(null);
    	T(b,ha,a);break;case "insertLineBreak":J(null);T(b,ea,!1);break;case "insertParagraph":J(null);hd?(hd=!1,T(b,ea,!1)):T(b,fa,void 0);break;case "insertFromPaste":case "insertFromPasteAsQuotation":T(b,ia,a);break;case "deleteByComposition":od(g,f)&&T(b,ja,void 0);break;case "deleteByDrag":case "deleteByCut":T(b,ja,void 0);break;case "deleteContent":T(b,ca,!1);break;case "deleteWordBackward":T(b,ka,!0);break;case "deleteWordForward":T(b,ka,!1);break;case "deleteHardLineBackward":case "deleteSoftLineBackward":T(b,
    	ma,!0);break;case "deleteContentForward":case "deleteHardLineForward":case "deleteSoftLineForward":T(b,ma,!1);break;case "formatStrikeThrough":T(b,na,"strikethrough");break;case "formatBold":T(b,na,"bold");break;case "formatItalic":T(b,na,"italic");break;case "formatUnderline":T(b,na,"underline");break;case "historyUndo":T(b,oa,void 0);break;case "historyRedo":T(b,pa,void 0);}}});}
    	function Yc(a,b){a.stopPropagation();v(b,()=>{var c=u(),d=a.data;if(null!=d&&C(c)&&kd(c,d,a.timeStamp,!1)){id&&(pd(b,d),id=!1);var e=c.anchor,f=e.getNode(),g=D(b._window);if(null===g)return;let h=e.offset;if(e=Qa&&!c.isCollapsed()&&B(f)&&null!==g.anchorNode)f=f.getTextContent().slice(0,h)+d+f.getTextContent().slice(h+c.focus.offset),g=g.anchorNode,e=f===(3===g.nodeType?g.nodeValue:null);e||T(b,ha,d);d=d.length;Pa&&1<d&&"insertCompositionText"===a.inputType&&!b.isComposing()&&(c.anchor.offset-=d);
    	Ra||Sa||!b.isComposing()||(bd=0,J(null));}else Tb(!1,b),id&&(pd(b,d||void 0),id=!1);F();c=G();pb(c);});}function Wc(a,b){v(b,()=>{let c=u();if(C(c)&&!b.isComposing()){let d=c.anchor;J(d.key);(a.timeStamp<bd+30||"element"===d.type||!c.isCollapsed()||c.anchor.getNode().getFormat()!==c.format)&&T(b,ha,Wa);}});}
    	function pd(a,b){var c=a._compositionKey;J(null);if(null!==c&&null!=b){if(""===b){b=K(c);a=Bb(a.getElementByKey(c));null!==a&&null!==a.nodeValue&&B(b)&&lb(b,a.nodeValue,null,null,!0);return}if("\n"===b[b.length-1]&&(c=u(),C(c))){b=c.focus;c.anchor.set(b.key,b.offset,b.type);T(a,xa,null);return}}Tb(!0,a,b);}function Xc(a,b){Pa?id=!0:v(b,()=>{pd(b,a.data);});}
    	function Uc(a,b){bd=a.timeStamp;cd=a.keyCode;if(!b.isComposing()){var {keyCode:c,shiftKey:d,ctrlKey:e,metaKey:f,altKey:g}=a;if(39!==c||e||f||g)if(39!==c||g||d||!e&&!f)if(37!==c||e||f||g)if(37!==c||g||d||!e&&!f)if(38!==c||e||f)if(40!==c||e||f)if(13===c&&d)hd=!0,T(b,xa,a);else if(32===c)T(b,ya,a);else if(t&&e&&79===c)a.preventDefault(),hd=!0,T(b,ea,!0);else if(13!==c||d){var h=t?g||f?!1:8===c||72===c&&e:e||g||f?!1:8===c;h?8===c?T(b,za,a):(a.preventDefault(),T(b,ca,!0)):27===c?T(b,Aa,a):(h=t?d||g||f?
    	!1:46===c||68===c&&e:e||g||f?!1:46===c,h?46===c?T(b,Ba,a):(a.preventDefault(),T(b,ca,!1)):8===c&&(t?g:e)?(a.preventDefault(),T(b,ka,!0)):46===c&&(t?g:e)?(a.preventDefault(),T(b,ka,!1)):t&&f&&8===c?(a.preventDefault(),T(b,ma,!0)):t&&f&&46===c?(a.preventDefault(),T(b,ma,!1)):66===c&&!g&&(t?f:e)?(a.preventDefault(),T(b,na,"bold")):85===c&&!g&&(t?f:e)?(a.preventDefault(),T(b,na,"underline")):73===c&&!g&&(t?f:e)?(a.preventDefault(),T(b,na,"italic")):9!==c||g||e||f?90===c&&!d&&(t?f:e)?(a.preventDefault(),
    	T(b,oa,void 0)):(h=t?90===c&&f&&d:89===c&&e||90===c&&e&&d,h?(a.preventDefault(),T(b,pa,void 0)):qd(b._editorState._selection)&&(h=d?!1:67===c?t?f:e:!1,h?(a.preventDefault(),T(b,Ia,a)):(h=d?!1:88===c?t?f:e:!1,h&&(a.preventDefault(),T(b,Ja,a))))):T(b,Ca,a));}else hd=!1,T(b,xa,a);else T(b,wa,a);else T(b,va,a);else T(b,ua,a);else T(b,sa,a);else T(b,ra,a);else T(b,qa,a);(e||d||g||f)&&T(b,Ma,a);}}function rd(a){let b=a.__lexicalEventHandles;void 0===b&&(b=[],a.__lexicalEventHandles=b);return b}let sd=new Map;
    	function td(a){a=a.target;let b=D(null==a?null:9===a.nodeType?a.defaultView:a.ownerDocument.defaultView);if(null!==b){var c=yb(b.anchorNode);if(null!==c){gd&&(gd=!1,v(c,()=>{var g=Ub(),h=b.anchorNode;null!==h&&(h=h.nodeType,1===h||3===h)&&(g=ud(g,b,c),nb(g));}));a=Rb(c);a=a[a.length-1];var d=a._key,e=sd.get(d),f=e||a;f!==c&&md(b,f,!1);md(b,c,!0);c!==a?sd.set(d,c):e&&sd.delete(d);}}}
    	function vd(a,b){0===ed&&a.ownerDocument.addEventListener("selectionchange",td);ed++;a.__lexicalEditor=b;let c=rd(a);for(let d=0;d<$c.length;d++){let [e,f]=$c[d],g="function"===typeof f?h=>{!0!==h._lexicalHandled&&(h._lexicalHandled=!0,b.isEditable()&&f(h,b));}:h=>{if(!0!==h._lexicalHandled&&(h._lexicalHandled=!0,b.isEditable()))switch(e){case "cut":return T(b,Ja,h);case "copy":return T(b,Ia,h);case "paste":return T(b,ia,h);case "dragstart":return T(b,Fa,h);case "dragover":return T(b,Ga,h);case "dragend":return T(b,
    	Ha,h);case "focus":return T(b,Ka,h);case "blur":return T(b,La,h);case "drop":return T(b,Ea,h)}};a.addEventListener(e,g);c.push(()=>{a.removeEventListener(e,g);});}}function wd(a,b,c,d){jd=[a,b,c,d];}
    	class W{constructor(a,b,c){this._selection=null;this.key=a;this.offset=b;this.type=c;}is(a){return this.key===a.key&&this.offset===a.offset&&this.type===a.type}isBefore(a){let b=this.getNode(),c=a.getNode(),d=this.offset;a=a.offset;if(E(b)){var e=b.getDescendantByIndex(d);b=null!=e?e:b;}E(c)&&(e=c.getDescendantByIndex(a),c=null!=e?e:c);return b===c?d<a:b.isBefore(c)}getNode(){let a=K(this.key);null===a&&q(20);return a}set(a,b,c){let d=this._selection,e=this.key;this.key=a;this.offset=b;this.type=c;
    	Kb()||(Jb()===e&&J(a),null!==d&&(d._cachedNodes=null,d.dirty=!0));}}function xd(a,b){let c=b.__key,d=a.offset,e="element";if(B(b))e="text",b=b.getTextContentSize(),d>b&&(d=b);else if(!E(b)){var f=b.getNextSibling();if(B(f))c=f.__key,d=0,e="text";else if(f=b.getParent())c=f.__key,d=b.getIndexWithinParent()+1;}a.set(c,d,e);}function yd(a,b){if(E(b)){let c=b.getLastDescendant();E(c)||B(c)?xd(a,c):xd(a,b);}else xd(a,b);}
    	function zd(a,b,c){let d=a.getNode(),e=d.getChildAtIndex(a.offset),f=M(),g=O(d)?Ad().append(f):f;f.setFormat(c);null===e?d.append(g):e.insertBefore(g);a.is(b)&&b.set(f.__key,0,"text");a.set(f.__key,0,"text");}function Bd(a,b,c,d){a.key=b;a.offset=c;a.type=d;}
    	class Cd{constructor(a){this.dirty=!1;this._nodes=a;this._cachedNodes=null;}is(a){if(!qd(a))return !1;let b=this._nodes,c=a._nodes;return b.size===c.size&&Array.from(b).every(d=>c.has(d))}add(a){this.dirty=!0;this._nodes.add(a);this._cachedNodes=null;}delete(a){this.dirty=!0;this._nodes.delete(a);this._cachedNodes=null;}clear(){this.dirty=!0;this._nodes.clear();this._cachedNodes=null;}has(a){return this._nodes.has(a)}clone(){return new Cd(new Set(this._nodes))}extract(){return this.getNodes()}insertRawText(){}insertText(){}insertNodes(a,
    	b){let c=this.getNodes(),d=c.length;var e=c[d-1];if(B(e))e=e.select();else {let f=e.getIndexWithinParent()+1;e=e.getParentOrThrow().select(f,f);}e.insertNodes(a,b);for(a=0;a<d;a++)c[a].remove();return !0}getNodes(){var a=this._cachedNodes;if(null!==a)return a;var b=this._nodes;a=[];for(let c of b)b=K(c),null!==b&&a.push(b);Kb()||(this._cachedNodes=a);return a}getTextContent(){let a=this.getNodes(),b="";for(let c=0;c<a.length;c++)b+=a[c].getTextContent();return b}}
    	function C(a){return a instanceof Dd}
    	class Ed{constructor(a,b,c){this.gridKey=a;this.anchor=b;this.focus=c;this.dirty=!1;this._cachedNodes=null;b._selection=this;c._selection=this;}is(a){return Fd(a)?this.gridKey===a.gridKey&&this.anchor.is(a.anchor)&&this.focus.is(a.focus):!1}set(a,b,c){this.dirty=!0;this.gridKey=a;this.anchor.key=b;this.focus.key=c;this._cachedNodes=null;}clone(){return new Ed(this.gridKey,this.anchor,this.focus)}isCollapsed(){return !1}isBackward(){return this.focus.isBefore(this.anchor)}getCharacterOffsets(){return Gd(this)}extract(){return this.getNodes()}insertRawText(){}insertText(){}insertNodes(a,b){let c=
    	this.focus.getNode();return qc(c.select(0,c.getChildrenSize())).insertNodes(a,b)}getShape(){var a=K(this.anchor.key);null===a&&q(21);var b=a.getIndexWithinParent();a=a.getParentOrThrow().getIndexWithinParent();var c=K(this.focus.key);null===c&&q(22);var d=c.getIndexWithinParent();let e=c.getParentOrThrow().getIndexWithinParent();c=Math.min(b,d);b=Math.max(b,d);d=Math.min(a,e);a=Math.max(a,e);return {fromX:Math.min(c,b),fromY:Math.min(d,a),toX:Math.max(c,b),toY:Math.max(d,a)}}getNodes(){var a=this._cachedNodes;
    	if(null!==a)return a;a=new Set;let {fromX:b,fromY:c,toX:d,toY:e}=this.getShape();var f=K(this.gridKey);Hd(f)||q(23);a.add(f);f=f.getChildren();for(let k=c;k<=e;k++){var g=f[k];a.add(g);Id(g)||q(24);g=g.getChildren();for(let l=b;l<=d;l++){var h=g[l];Jd(h)||q(25);a.add(h);for(h=h.getChildren();0<h.length;){let m=h.shift();a.add(m);E(m)&&h.unshift(...m.getChildren());}}}a=Array.from(a);Kb()||(this._cachedNodes=a);return a}getTextContent(){let a=this.getNodes(),b="";for(let c=0;c<a.length;c++)b+=a[c].getTextContent();
    	return b}}function Fd(a){return a instanceof Ed}
    	class Dd{constructor(a,b,c){this.anchor=a;this.focus=b;this.dirty=!1;this.format=c;this._cachedNodes=null;a._selection=this;b._selection=this;}is(a){return C(a)?this.anchor.is(a.anchor)&&this.focus.is(a.focus)&&this.format===a.format:!1}isBackward(){return this.focus.isBefore(this.anchor)}isCollapsed(){return this.anchor.is(this.focus)}getNodes(){var a=this._cachedNodes;if(null!==a)return a;var b=this.anchor,c=this.focus;a=b.getNode();let d=c.getNode();E(a)&&(b=a.getDescendantByIndex(b.offset),a=null!=
    	b?b:a);E(d)&&(c=d.getDescendantByIndex(c.offset),d=null!=c?c:d);a=a.is(d)?E(a)&&0<a.getChildrenSize()?[]:[a]:a.getNodesBetween(d);Kb()||(this._cachedNodes=a);return a}setTextNodeRange(a,b,c,d){Bd(this.anchor,a.__key,b,"text");Bd(this.focus,c.__key,d,"text");this._cachedNodes=null;this.dirty=!0;}getTextContent(){let a=this.getNodes();if(0===a.length)return "";let b=a[0],c=a[a.length-1],d=this.anchor.isBefore(this.focus),[e,f]=Gd(this),g="",h=!0;for(let k=0;k<a.length;k++){let l=a[k];if(E(l)&&!l.isInline())h||
    	(g+="\n"),h=l.isEmpty()?!1:!0;else if(h=!1,B(l)){let m=l.getTextContent();l===b?m=l===c?e<f?m.slice(e,f):m.slice(f,e):d?m.slice(e):m.slice(f):l===c&&(m=d?m.slice(0,f):m.slice(0,e));g+=m;}else !z(l)&&!Eb(l)||l===c&&this.isCollapsed()||(g+=l.getTextContent());}return g}applyDOMRange(a){let b=G(),c=b.getEditorState()._selection;a=Kd(a.startContainer,a.startOffset,a.endContainer,a.endOffset,b,c);if(null!==a){var [d,e]=a;Bd(this.anchor,d.key,d.offset,d.type);Bd(this.focus,e.key,e.offset,e.type);this._cachedNodes=
    	null;}}clone(){let a=this.anchor,b=this.focus;return new Dd(new W(a.key,a.offset,a.type),new W(b.key,b.offset,b.type),this.format)}toggleFormat(a){this.format=Cb(this.format,a,null);this.dirty=!0;}hasFormat(a){return 0!==(this.format&Za[a])}insertRawText(a){let b=a.split(/\r?\n/);if(1===b.length)this.insertText(a);else {a=[];let c=b.length;for(let d=0;d<c;d++){let e=b[d];""!==e&&a.push(M(e));d!==c-1&&a.push(Ld());}this.insertNodes(a);}}insertText(a){var b=this.anchor,c=this.focus,d=this.isCollapsed()||
    	b.isBefore(c),e=this.format;d&&"element"===b.type?zd(b,c,e):d||"element"!==c.type||zd(c,b,e);var f=this.getNodes(),g=f.length,h=d?c:b;c=(d?b:c).offset;var k=h.offset;b=f[0];B(b)||q(26);d=b.getTextContent().length;var l=b.getParentOrThrow(),m=f[g-1];if(this.isCollapsed()&&c===d&&(b.isSegmented()||b.isToken()||!b.canInsertTextAfter()||!l.canInsertTextAfter()&&null===b.getNextSibling())){var p=b.getNextSibling();if(!B(p)||Ab(p))p=M(),p.setFormat(e),l.canInsertTextAfter()?b.insertAfter(p):l.insertAfter(p);
    	p.select(0,0);b=p;if(""!==a){this.insertText(a);return}}else if(this.isCollapsed()&&0===c&&(b.isSegmented()||b.isToken()||!b.canInsertTextBefore()||!l.canInsertTextBefore()&&null===b.getPreviousSibling())){p=b.getPreviousSibling();if(!B(p)||Ab(p))p=M(),p.setFormat(e),l.canInsertTextBefore()?b.insertBefore(p):l.insertBefore(p);p.select();b=p;if(""!==a){this.insertText(a);return}}else if(b.isSegmented()&&c!==d)l=M(b.getTextContent()),l.setFormat(e),b.replace(l),b=l;else if(!(this.isCollapsed()||""===
    	a||(p=m.getParent(),l.canInsertTextBefore()&&l.canInsertTextAfter()&&(!E(p)||p.canInsertTextBefore()&&p.canInsertTextAfter())))){this.insertText("");Md(this.anchor,this.focus,null);this.insertText(a);return}if(1===g)if(b.isToken())a=M(a),a.select(),b.replace(a);else {f=b.getFormat();if(c===k&&f!==e)if(""===b.getTextContent())b.setFormat(e);else {f=M(a);f.setFormat(e);f.select();0===c?b.insertBefore(f,!1):([g]=b.splitText(c),g.insertAfter(f,!1));f.isComposing()&&"text"===this.anchor.type&&(this.anchor.offset-=
    	a.length);return}b=b.spliceText(c,k-c,a,!0);""===b.getTextContent()?b.remove():"text"===this.anchor.type&&(b.isComposing()?this.anchor.offset-=a.length:this.format=f);}else {e=new Set([...b.getParentKeys(),...m.getParentKeys()]);var n=E(b)?b:b.getParentOrThrow();l=E(m)?m:m.getParentOrThrow();p=m;if(!n.is(l)&&l.isInline()){do p=l,l=l.getParentOrThrow();while(l.isInline())}"text"===h.type&&(0!==k||""===m.getTextContent())||"element"===h.type&&m.getIndexWithinParent()<k?B(m)&&!m.isToken()&&k!==m.getTextContentSize()?
    	(m.isSegmented()&&(h=M(m.getTextContent()),m.replace(h),m=h),m=m.spliceText(0,k,""),e.add(m.__key)):(h=m.getParentOrThrow(),h.canBeEmpty()||1!==h.getChildrenSize()?m.remove():h.remove()):e.add(m.__key);h=l.getChildren();k=new Set(f);m=n.is(l);n=n.isInline()&&null===b.getNextSibling()?n:b;for(let r=h.length-1;0<=r;r--){let w=h[r];if(w.is(b)||E(w)&&w.isParentOf(b))break;w.isAttached()&&(!k.has(w)||w.is(p)?m||n.insertAfter(w,!1):w.remove());}if(!m)for(h=l,k=null;null!==h;){m=h.getChildren();l=m.length;
    	if(0===l||m[l-1].is(k))e.delete(h.__key),k=h;h=h.getParent();}b.isToken()?c===d?b.select():(a=M(a),a.select(),b.replace(a)):(b=b.spliceText(c,d-c,a,!0),""===b.getTextContent()?b.remove():b.isComposing()&&"text"===this.anchor.type&&(this.anchor.offset-=a.length));for(a=1;a<g;a++)b=f[a],e.has(b.__key)||b.remove();}}removeText(){this.insertText("");}formatText(a){if(this.isCollapsed())this.toggleFormat(a),J(null);else {var b=this.getNodes(),c=[];for(var d of b)B(d)&&c.push(d);var e=c.length;if(0===e)this.toggleFormat(a),
    	J(null);else {d=this.anchor;var f=this.focus,g=this.isBackward();b=g?f:d;d=g?d:f;var h=0,k=c[0];f="element"===b.type?0:b.offset;"text"===b.type&&f===k.getTextContentSize()&&(h=1,k=c[1],f=0);if(null!=k){g=k.getFormatFlags(a,null);var l=e-1,m=c[l];e="text"===d.type?d.offset:m.getTextContentSize();if(k.is(m))f!==e&&(0===f&&e===k.getTextContentSize()?k.setFormat(g):(a=k.splitText(f,e),a=0===f?a[0]:a[1],a.setFormat(g),"text"===b.type&&b.set(a.__key,0,"text"),"text"===d.type&&d.set(a.__key,e-f,"text")),
    	this.format=g);else {0!==f&&([,k]=k.splitText(f),f=0);k.setFormat(g);var p=m.getFormatFlags(a,g);0<e&&(e!==m.getTextContentSize()&&([m]=m.splitText(e)),m.setFormat(p));for(h+=1;h<l;h++){let n=c[h];if(!n.isToken()){let r=n.getFormatFlags(a,p);n.setFormat(r);}}"text"===b.type&&b.set(k.__key,f,"text");"text"===d.type&&d.set(m.__key,e,"text");this.format=g|p;}}}}}insertNodes(a,b){if(!this.isCollapsed()){var c=this.isBackward()?this.anchor:this.focus,d=c.getNode().getNextSibling();d=d?d.getKey():null;c=(c=
    	c.getNode().getPreviousSibling())?c.getKey():null;this.removeText();if(this.isCollapsed()&&"element"===this.focus.type){if(this.focus.key===d&&0===this.focus.offset){var e=M();this.focus.getNode().insertBefore(e);}else this.focus.key===c&&this.focus.offset===this.focus.getNode().getChildrenSize()&&(e=M(),this.focus.getNode().insertAfter(e));e&&(this.focus.set(e.__key,0,"text"),this.anchor.set(e.__key,0,"text"));}}d=this.anchor;c=d.offset;var f=d.getNode();e=f;"element"===d.type&&(e=d.getNode(),d=e.getChildAtIndex(c-
    	1),e=null===d?e:d);d=[];var g=f.getNextSiblings(),h=fc(f)?null:f.getTopLevelElementOrThrow();if(B(f))if(e=f.getTextContent().length,0===c&&0!==e)e=f.getPreviousSibling(),e=null!==e?e:f.getParentOrThrow(),d.push(f);else if(c===e)e=f;else {if(f.isToken())return !1;[e,f]=f.splitText(c);d.push(f);}f=e;d.push(...g);g=a[0];var k=!1,l=null;for(let r=0;r<a.length;r++){var m=a[r];if(z(e)||!E(m)||m.isInline())k&&!z(m)&&fc(e.getParent())&&q(28);else {if(m.is(g)){if(E(e)&&e.isEmpty()&&e.canReplaceWith(m)){e.replace(m);
    	e=m;k=!0;continue}var p=m.getFirstDescendant();if(Db(p)){for(p=p.getParentOrThrow();p.isInline();)p=p.getParentOrThrow();l=p.getChildren();k=l.length;if(E(e)){var n=e.getFirstChild();for(let w=0;w<k;w++){let y=l[w];null===n?e.append(y):n.insertAfter(y);n=y;}}else {for(n=k-1;0<=n;n--)e.insertAfter(l[n]);e=e.getParentOrThrow();}l=l[k-1];p.remove();k=!0;if(p.is(m))continue}}B(e)&&(null===h&&q(27),e=h);}k=!1;if(E(e)&&!e.isInline())if(l=m,z(m)&&!m.isInline())e=e.insertAfter(m,!1);else if(E(m)){if(m.canBeEmpty()||
    	!m.isEmpty())O(e)?(p=e.getChildAtIndex(c),null!==p?p.insertBefore(m):e.append(m),e=m):e=e.insertAfter(m,!1);}else p=e.getFirstChild(),null!==p?p.insertBefore(m):e.append(m),e=m;else !E(m)||E(m)&&m.isInline()||z(e)&&!e.isInline()?(l=m,e=e.insertAfter(m,!1)):(m=e.getParentOrThrow(),Eb(e)&&e.remove(),e=m,r--);}b&&(B(f)?f.select():(a=e.getPreviousSibling(),B(a)?a.select():(a=e.getIndexWithinParent(),e.getParentOrThrow().select(a,a))));if(E(e)){if(a=B(l)?l:E(l)&&l.isInline()?l.getLastDescendant():e.getLastDescendant(),
    	b||(null===a?e.select():B(a)?""===a.getTextContent()?a.selectPrevious():a.select():a.selectNext()),0!==d.length)for(b=e,a=d.length-1;0<=a;a--)c=d[a],h=c.getParentOrThrow(),!E(e)||Nd(c)||z(c)&&(!c.isInline()||c.isIsolated())?E(e)||Nd(c)?E(c)&&!c.canInsertAfter(e)?(f=h.constructor.clone(h),E(f)||q(29),f.append(c),e.insertAfter(f)):e.insertAfter(c):(e.insertBefore(c),e=c):(b===e?e.append(c):e.insertBefore(c),e=c),h.isEmpty()&&!h.canBeEmpty()&&h.remove();}else b||(B(e)?e.select():(b=e.getParentOrThrow(),
    	a=e.getIndexWithinParent()+1,b.select(a,a)));return !0}insertParagraph(){this.isCollapsed()||this.removeText();var a=this.anchor,b=a.offset,c=[];if("text"===a.type){var d=a.getNode();var e=d.getNextSiblings().reverse();var f=d.getParentOrThrow();var g=f.isInline(),h=g?f.getTextContentSize():d.getTextContentSize();0===b?e.push(d):(g&&(c=f.getNextSiblings()),b===h||g&&b===d.getTextContentSize()||([,d]=d.splitText(b),e.push(d)));}else {f=a.getNode();if(fc(f)){e=Ad();c=f.getChildAtIndex(b);e.select();null!==
    	c?c.insertBefore(e,!1):f.append(e);return}e=f.getChildren().slice(b).reverse();}d=e.length;if(0===b&&0<d&&f.isInline()){if(c=f.getParentOrThrow(),e=c.insertNewAfter(this,!1),E(e))for(c=c.getChildren(),f=0;f<c.length;f++)e.append(c[f]);}else if(g=f.insertNewAfter(this,!1),null===g)this.insertLineBreak();else if(E(g))if(h=f.getFirstChild(),0===b&&(f.is(a.getNode())||h&&h.is(a.getNode()))&&0<d)f.insertBefore(g);else {f=null;b=c.length;a=g.getParentOrThrow();if(0<b)for(h=0;h<b;h++)a.append(c[h]);if(0!==
    	d)for(c=0;c<d;c++)b=e[c],null===f?g.append(b):f.insertBefore(b),f=b;g.canBeEmpty()||0!==g.getChildrenSize()?g.selectStart():(g.selectPrevious(),g.remove());}}insertLineBreak(a){let b=Ld();var c=this.anchor;"element"===c.type&&(c=c.getNode(),O(c)&&this.insertParagraph());a?this.insertNodes([b],!0):this.insertNodes([b])&&b.selectNext(0,0);}getCharacterOffsets(){return Gd(this)}extract(){var a=this.getNodes(),b=a.length,c=b-1,d=this.anchor;let e=this.focus;var f=a[0];let g=a[c],[h,k]=Gd(this);if(0===b)return [];
    	if(1===b)return B(f)&&!this.isCollapsed()?(a=h>k?k:h,c=f.splitText(a,h>k?h:k),a=0===a?c[0]:c[1],null!=a?[a]:[]):[f];b=d.isBefore(e);B(f)&&(d=b?h:k,d===f.getTextContentSize()?a.shift():0!==d&&([,f]=f.splitText(d),a[0]=f));B(g)&&(f=g.getTextContent().length,b=b?k:h,0===b?a.pop():b!==f&&([g]=g.splitText(b),a[c]=g));return a}modify(a,b,c){var d=this.focus,e=this.anchor,f="move"===a,g=Zb(d,b);if(z(g)&&!g.isIsolated())f&&g.isKeyboardSelectable()?(b=Od(),b.add(g.__key),nb(b)):(a=b?g.getPreviousSibling():
    	g.getNextSibling(),B(a)?(g=a.__key,b=b?a.getTextContent().length:0,d.set(g,b,"text"),f&&e.set(g,b,"text")):(c=g.getParentOrThrow(),E(a)?(c=a.__key,g=b?a.getChildrenSize():0):(g=g.getIndexWithinParent(),c=c.__key,b||g++),d.set(c,g,"element"),f&&e.set(c,g,"element")));else if(e=G(),d=D(e._window)){var h=e._blockCursorElement,k=e._rootElement;null===k||null===h||!E(g)||g.isInline()||g.canBeEmpty()||jc(h,e,k);d.modify(a,b?"backward":"forward",c);if(0<d.rangeCount&&(g=d.getRangeAt(0),e=this.anchor.getNode(),
    	e=O(e)?e:ec(e),this.applyDOMRange(g),this.dirty=!0,!f)){f=this.getNodes();a=[];c=!1;for(h=0;h<f.length;h++)k=f[h],dc(k,e)?a.push(k):c=!0;c&&0<a.length&&(b?(b=a[0],E(b)?b.selectStart():b.getParentOrThrow().selectStart()):(b=a[a.length-1],E(b)?b.selectEnd():b.getParentOrThrow().selectEnd()));if(d.anchorNode!==g.startContainer||d.anchorOffset!==g.startOffset)b=this.focus,f=this.anchor,d=f.key,g=f.offset,e=f.type,Bd(f,b.key,b.offset,b.type),Bd(b,d,g,e),this._cachedNodes=null;}}}deleteCharacter(a){if(this.isCollapsed()){var b=
    	this.anchor,c=this.focus,d=b.getNode();if(!a&&("element"===b.type&&E(d)&&b.offset===d.getChildrenSize()||"text"===b.type&&b.offset===d.getTextContentSize())){var e=d.getParent();e=d.getNextSibling()||(null===e?null:e.getNextSibling());if(E(e)&&!e.canExtractContents())return}e=Zb(c,a);if(z(e)&&!e.isIsolated()){e.isKeyboardSelectable()&&E(d)&&0===d.getChildrenSize()?(d.remove(),a=Od(),a.add(e.__key),nb(a)):e.remove();return}this.modify("extend",a,"character");if(!this.isCollapsed()){e="text"===c.type?
    	c.getNode():null;d="text"===b.type?b.getNode():null;if(null!==e&&e.isSegmented()){if(b=c.offset,c=e.getTextContentSize(),e.is(d)||a&&b!==c||!a&&0!==b){Pd(e,a,b);return}}else if(null!==d&&d.isSegmented()&&(b=b.offset,c=d.getTextContentSize(),d.is(e)||a&&0!==b||!a&&b!==c)){Pd(d,a,b);return}d=this.anchor;e=this.focus;b=d.getNode();c=e.getNode();if(b===c&&"text"===d.type&&"text"===e.type){var f=d.offset,g=e.offset;let h=f<g;c=h?f:g;g=h?g:f;f=g-1;c!==f&&(b=b.getTextContent().slice(c,g),Qb(b)||(a?e.offset=
    	f:d.offset=f));}}else if(a&&0===b.offset&&("element"===b.type?b.getNode():b.getNode().getParentOrThrow()).collapseAtStart(this))return}this.removeText();}deleteLine(a){this.isCollapsed()&&("text"===this.anchor.type&&this.modify("extend",a,"lineboundary"),0===(a?this.focus:this.anchor).offset&&this.modify("extend",a,"character"));this.removeText();}deleteWord(a){this.isCollapsed()&&this.modify("extend",a,"word");this.removeText();}}function qd(a){return a instanceof Cd}
    	function Qd(a){let b=a.offset;if("text"===a.type)return b;a=a.getNode();return b===a.getChildrenSize()?a.getTextContent().length:0}function Gd(a){let b=a.anchor;a=a.focus;return "element"===b.type&&"element"===a.type&&b.key===a.key&&b.offset===a.offset?[0,0]:[Qd(b),Qd(a)]}
    	function Pd(a,b,c){let d=a.getTextContent().split(/(?=\s)/g),e=d.length,f=0,g=0;for(let h=0;h<e;h++){let k=d[h],l=h===e-1;g=f;f+=k.length;if(b&&f===c||f>c||l){d.splice(h,1);l&&(g=void 0);break}}b=d.join("").trim();""===b?a.remove():(a.setTextContent(b),a.select(g,g));}
    	function Rd(a,b,c,d){var e=b;if(1===a.nodeType){let h=!1;var f=a.childNodes,g=f.length;e===g&&(h=!0,e=g-1);let k=f[e];g=!1;k===d._blockCursorElement?(k=f[e+1],g=!0):null!==d._blockCursorElement&&e--;d=Pb(k);if(B(d))e=h?d.getTextContentSize():0;else {f=Pb(a);if(null===f)return null;if(E(f)){a=f.getChildAtIndex(e);if(b=E(a))b=a.getParent(),b=null===c||null===b||!b.canBeEmpty()||b!==c.getNode();b&&(c=h?a.getLastDescendant():a.getFirstDescendant(),null===c?(f=a,e=0):(a=c,f=E(a)?a:a.getParentOrThrow()));
    	B(a)?(d=a,f=null,e=h?a.getTextContentSize():0):a!==f&&h&&!g&&e++;}else e=f.getIndexWithinParent(),e=0===b&&z(f)&&Pb(a)===f?e:e+1,f=f.getParentOrThrow();if(E(f))return new W(f.__key,e,"element")}}else d=Pb(a);return B(d)?new W(d.__key,e,"text"):null}
    	function Sd(a,b,c){var d=a.offset,e=a.getNode();0===d?(d=e.getPreviousSibling(),e=e.getParent(),b)?(c||!b)&&null===d&&E(e)&&e.isInline()&&(b=e.getPreviousSibling(),B(b)&&(a.key=b.__key,a.offset=b.getTextContent().length)):E(d)&&!c&&d.isInline()?(a.key=d.__key,a.offset=d.getChildrenSize(),a.type="element"):B(d)&&(a.key=d.__key,a.offset=d.getTextContent().length):d===e.getTextContent().length&&(d=e.getNextSibling(),e=e.getParent(),b&&E(d)&&d.isInline()?(a.key=d.__key,a.offset=0,a.type="element"):(c||
    	b)&&null===d&&E(e)&&e.isInline()&&!e.canInsertTextAfter()&&(b=e.getNextSibling(),B(b)&&(a.key=b.__key,a.offset=0)));}function Md(a,b,c){if("text"===a.type&&"text"===b.type){var d=a.isBefore(b);let e=a.is(b);Sd(a,d,e);Sd(b,!d,e);e&&(b.key=a.key,b.offset=a.offset,b.type=a.type);d=G();d.isComposing()&&d._compositionKey!==a.key&&C(c)&&(d=c.anchor,c=c.focus,Bd(a,d.key,d.offset,d.type),Bd(b,c.key,c.offset,c.type));}}
    	function Kd(a,b,c,d,e,f){if(null===a||null===c||!xb(e,a,c))return null;b=Rd(a,b,C(f)?f.anchor:null,e);if(null===b)return null;d=Rd(c,d,C(f)?f.focus:null,e);if(null===d||"element"===b.type&&"element"===d.type&&(a=Pb(a),c=Pb(c),z(a)&&z(c)))return null;Md(b,d,f);return [b,d]}function Nd(a){return E(a)&&!a.isInline()}function Td(a,b,c,d,e,f){let g=H();a=new Dd(new W(a,b,e),new W(c,d,f),0);a.dirty=!0;return g._selection=a}function Od(){return new Cd(new Set)}
    	function Ud(a){let b=a.getEditorState()._selection,c=D(a._window);return qd(b)||Fd(b)?b.clone():ud(b,c,a)}
    	function ud(a,b,c){var d=c._window;if(null===d)return null;var e=d.event,f=e?e.type:void 0;d="selectionchange"===f;e=!eb&&(d||"beforeinput"===f||"compositionstart"===f||"compositionend"===f||"click"===f&&e&&3===e.detail||"drop"===f||void 0===f);let g;if(!C(a)||e){if(null===b)return null;e=b.anchorNode;f=b.focusNode;g=b.anchorOffset;b=b.focusOffset;if(d&&C(a)&&!xb(c,e,f))return a.clone()}else return a.clone();c=Kd(e,g,f,b,c,a);if(null===c)return null;let [h,k]=c;return new Dd(h,k,C(a)?a.format:0)}
    	function u(){return H()._selection}function Ub(){return G()._editorState._selection}
    	function Vd(a,b,c,d=1){var e=a.anchor,f=a.focus,g=e.getNode(),h=f.getNode();if(b.is(g)||b.is(h))if(g=b.__key,a.isCollapsed())b=e.offset,c<=b&&(c=Math.max(0,b+d),e.set(g,c,"element"),f.set(g,c,"element"),Wd(a));else {var k=a.isBackward();h=k?f:e;var l=h.getNode();e=k?e:f;f=e.getNode();b.is(l)&&(l=h.offset,c<=l&&h.set(g,Math.max(0,l+d),"element"));b.is(f)&&(b=e.offset,c<=b&&e.set(g,Math.max(0,b+d),"element"));Wd(a);}}
    	function Wd(a){var b=a.anchor,c=b.offset;let d=a.focus;var e=d.offset,f=b.getNode(),g=d.getNode();if(a.isCollapsed())E(f)&&(g=f.getChildrenSize(),g=(e=c>=g)?f.getChildAtIndex(g-1):f.getChildAtIndex(c),B(g)&&(c=0,e&&(c=g.getTextContentSize()),b.set(g.__key,c,"text"),d.set(g.__key,c,"text")));else {if(E(f)){let h=f.getChildrenSize();c=(a=c>=h)?f.getChildAtIndex(h-1):f.getChildAtIndex(c);B(c)&&(f=0,a&&(f=c.getTextContentSize()),b.set(c.__key,f,"text"));}E(g)&&(c=g.getChildrenSize(),e=(b=e>=c)?g.getChildAtIndex(c-
    	1):g.getChildAtIndex(e),B(e)&&(g=0,b&&(g=e.getTextContentSize()),d.set(e.__key,g,"text")));}}function Xd(a,b){b=b.getEditorState()._selection;a=a._selection;if(C(a)){var c=a.anchor;let d=a.focus,e;"text"===c.type&&(e=c.getNode(),e.selectionTransform(b,a));"text"===d.type&&(c=d.getNode(),e!==c&&c.selectionTransform(b,a));}}
    	function Yd(a,b,c,d,e){let f=null,g=0,h=null;null!==d?(f=d.__key,B(d)?(g=d.getTextContentSize(),h="text"):E(d)&&(g=d.getChildrenSize(),h="element")):null!==e&&(f=e.__key,B(e)?h="text":E(e)&&(h="element"));null!==f&&null!==h?a.set(f,g,h):(g=b.getIndexWithinParent(),-1===g&&(g=c.getChildrenSize()),a.set(c.__key,g,"element"));}function Zd(a,b,c,d,e){"text"===a.type?(a.key=c,b||(a.offset+=e)):a.offset>d.getIndexWithinParent()&&--a.offset;}
    	function $d(a,b,c,d,e,f,g){let h=d.anchorNode,k=d.focusNode,l=d.anchorOffset,m=d.focusOffset,p=document.activeElement;if(!(e.has("collaboration")&&p!==f||null!==p&&wb(p)))if(C(b)){var n=b.anchor,r=b.focus,w=n.key,y=r.key,x=ac(c,w);y=ac(c,y);var A=n.offset,U=r.offset,I=b.format,da=b.isCollapsed(),N=x,V=y,L=!1;"text"===n.type&&(N=Bb(x),L=n.getNode().getFormat()!==I);"text"===r.type&&(V=Bb(y));if(null!==N&&null!==V){da&&(null===a||L||C(a)&&a.format!==I)&&wd(I,A,w,performance.now());if(l===A&&m===U&&
    	h===N&&k===V&&("Range"!==d.type||!da)&&(null!==p&&f.contains(p)||f.focus({preventScroll:!0}),"element"!==n.type))return;try{Ta&&1E3<g?window.requestAnimationFrame(()=>d.setBaseAndExtent(N,A,V,U)):d.setBaseAndExtent(N,A,V,U);}catch(ta){}!e.has("skip-scroll-into-view")&&b.isCollapsed()&&null!==f&&f===document.activeElement&&(a=b instanceof Dd&&"element"===b.anchor.type?N.childNodes[A]||null:0<d.rangeCount?d.getRangeAt(0):null,null!==a&&(a=a.getBoundingClientRect(),bc(c,a,f)));fd=!0;}}else null!==a&&xb(c,
    	h,k)&&d.removeAllRanges();}let X=null,Y=null,Z=!1,ae=!1,Gb=0,be={characterData:!0,childList:!0,subtree:!0};function Kb(){return Z||null!==X&&X._readOnly}function F(){Z&&q(13);}function H(){null===X&&q(15);return X}function G(){null===Y&&q(16);return Y}function ce(a,b,c){var d=b.__type;let e=a._nodes.get(d);void 0===e&&q(30);a=c.get(d);void 0===a&&(a=Array.from(e.transforms),c.set(d,a));c=a.length;for(d=0;d<c&&(a[d](b),b.isAttached());d++);}
    	function de(a,b){b=b._dirtyLeaves;a=a._nodeMap;for(let c of b)b=a.get(c),B(b)&&b.isAttached()&&b.isSimpleText()&&!b.isUnmergeable()&&pc(b);}
    	function ee(a,b){let c=b._dirtyLeaves,d=b._dirtyElements;a=a._nodeMap;let e=Jb(),f=new Map;var g=c;let h=g.size;for(var k=d,l=k.size;0<h||0<l;){if(0<h){b._dirtyLeaves=new Set;for(let m of g)g=a.get(m),B(g)&&g.isAttached()&&g.isSimpleText()&&!g.isUnmergeable()&&pc(g),void 0!==g&&void 0!==g&&g.__key!==e&&g.isAttached()&&ce(b,g,f),c.add(m);g=b._dirtyLeaves;h=g.size;if(0<h){Gb++;continue}}b._dirtyLeaves=new Set;b._dirtyElements=new Map;for(let m of k)if(k=m[0],l=m[1],"root"===k||l)g=a.get(k),void 0!==
    	g&&void 0!==g&&g.__key!==e&&g.isAttached()&&ce(b,g,f),d.set(k,l);g=b._dirtyLeaves;h=g.size;k=b._dirtyElements;l=k.size;Gb++;}b._dirtyLeaves=c;b._dirtyElements=d;}function fe(a,b){var c=b.get(a.type);void 0===c&&q(17);c=c.klass;a.type!==c.getType()&&q(18);c=c.importJSON(a);a=a.children;if(E(c)&&Array.isArray(a))for(let d=0;d<a.length;d++){let e=fe(a[d],b);c.append(e);}return c}function ge(a,b){let c=X,d=Z,e=Y;X=a;Z=!0;Y=null;try{return b()}finally{X=c,Z=d,Y=e;}}
    	function he(a){var b=a._pendingEditorState,c=a._rootElement,d=a._headless||null===c;if(null!==b){var e=a._editorState,f=e._selection,g=b._selection,h=0!==a._dirtyType,k=X,l=Z,m=Y,p=a._updating,n=a._observer,r=null;a._pendingEditorState=null;a._editorState=b;if(!d&&h&&null!==n){Y=a;X=b;Z=!1;a._updating=!0;try{var w=a._dirtyType,y=a._dirtyElements,x=a._dirtyLeaves;n.disconnect();Q=R=P="";uc=2===w;xc=null;S=a;sc=a._config;tc=a._nodes;wc=S._listeners.mutation;yc=y;zc=x;Ac=e._nodeMap;Bc=b._nodeMap;vc=
    	b._readOnly;Cc=new Map(a._keyToDOMMap);var A=new Map;Dc=A;Rc("root",null);Dc=Cc=sc=Bc=Ac=zc=yc=tc=S=void 0;r=A;}catch(L){L instanceof Error&&a._onError(L);if(ae)throw L;ie(a,null,c,b);qb(a);a._dirtyType=2;ae=!0;he(a);ae=!1;return}finally{n.observe(c,be),a._updating=p,X=k,Z=l,Y=m;}}b._readOnly||(b._readOnly=!0);p=a._dirtyLeaves;A=a._dirtyElements;w=a._normalizedNodes;x=a._updateTags;l=a._deferred;y=b._nodeMap.size;h&&(a._dirtyType=0,a._cloneNotNeeded.clear(),a._dirtyLeaves=new Set,a._dirtyElements=new Map,
    	a._normalizedNodes=new Set,a._updateTags=new Set);var U=a._decorators,I=a._pendingDecorators||U,da=b._nodeMap,N;for(N in I)da.has(N)||(I===U&&(I=Lb(a)),delete I[N]);d=d?null:D(a._window);if(a._editable&&null!==d&&(h||null===g||g.dirty)){Y=a;X=b;try{null!==n&&n.disconnect();if(h||null===g||g.dirty){var V=a._blockCursorElement;null!==V&&jc(V,a,c);$d(f,g,a,d,x,c,y);}a:{let L=a._blockCursorElement;if(C(g)&&g.isCollapsed()&&"element"===g.anchor.type&&c.contains(document.activeElement)){let ta=g.anchor,
    	ub=ta.getNode(),lc=ta.offset,He=ub.getChildrenSize();h=!1;V=null;if(lc===He){let la=ub.getChildAtIndex(lc-1);ic(la)&&(h=!0);}else {let la=ub.getChildAtIndex(lc);if(ic(la)){let Va=la.getPreviousSibling();if(null===Va||ic(Va))h=!0,V=a.getElementByKey(la.__key);}}if(h){let la=a.getElementByKey(ub.__key);if(null===L){let Va=a._config.theme,vb=document.createElement("div");vb.contentEditable="false";vb.setAttribute("data-lexical-cursor","true");let Da=Va.blockCursor;if(void 0!==Da){if("string"===typeof Da){let Ie=
    	Da.split(" ");Da=Va.blockCursor=Ie;}void 0!==Da&&vb.classList.add(...Da);}a._blockCursorElement=L=vb;}c.style.caretColor="transparent";null===V?la.appendChild(L):la.insertBefore(L,V);break a}}null!==L&&jc(L,a,c);}null!==n&&n.observe(c,be);}finally{Y=m,X=k;}}if(null!==r)for(c=r,k=Array.from(a._listeners.mutation),m=k.length,n=0;n<m;n++){let [L,ta]=k[n];r=c.get(ta);void 0!==r&&L(r,{dirtyLeaves:p,updateTags:x});}C(g)||null===g||null!==f&&f.is(g)||a.dispatchCommand(aa,void 0);f=a._pendingDecorators;null!==f&&
    	(a._decorators=f,a._pendingDecorators=null,je("decorator",a,!0,f));f=Mb(e);g=Mb(b);f!==g&&je("textcontent",a,!0,g);je("update",a,!0,{dirtyElements:A,dirtyLeaves:p,editorState:b,normalizedNodes:w,prevEditorState:e,tags:x});a._deferred=[];if(0!==l.length){b=a._updating;a._updating=!0;try{for(e=0;e<l.length;e++)l[e]();}finally{a._updating=b;}}b=a._updates;if(0!==b.length&&(b=b.shift())){let [L,ta]=b;ke(a,L,ta);}}}
    	function je(a,b,c,...d){let e=b._updating;b._updating=c;try{let f=Array.from(b._listeners[a]);for(a=0;a<f.length;a++)f[a].apply(null,d);}finally{b._updating=e;}}function T(a,b,c){if(!1===a._updating||Y!==a){let f=!1;a.update(()=>{f=T(a,b,c);});return f}let d=Rb(a);for(let f=4;0<=f;f--)for(let g=0;g<d.length;g++){var e=d[g]._commands.get(b);if(void 0!==e&&(e=e[f],void 0!==e)){e=Array.from(e);let h=e.length;for(let k=0;k<h;k++)if(!0===e[k](c,a))return !0}}return !1}
    	function le(a,b){let c=a._updates;for(b=b||!1;0!==c.length;){var d=c.shift();if(d){let [e,f]=d,g;void 0!==f&&(d=f.onUpdate,g=f.tag,f.skipTransforms&&(b=!0),d&&a._deferred.push(d),g&&a._updateTags.add(g));e();}}return b}
    	function ke(a,b,c){let d=a._updateTags;var e,f=e=!1;if(void 0!==c){var g=c.onUpdate;e=c.tag;null!=e&&d.add(e);e=c.skipTransforms||!1;f=c.discrete||!1;}g&&a._deferred.push(g);let h=a._editorState;c=a._pendingEditorState;g=!1;if(null===c||c._readOnly)c=a._pendingEditorState=new me(new Map((c||h)._nodeMap)),g=!0;c._flushSync=f;f=X;let k=Z,l=Y,m=a._updating;X=c;Z=!1;a._updating=!0;Y=a;try{g&&(a._headless?null!=h._selection&&(c._selection=h._selection.clone()):c._selection=Ud(a));let p=a._compositionKey;
    	b();e=le(a,e);Xd(c,a);0!==a._dirtyType&&(e?de(c,a):ee(c,a),le(a),mc(h,c,a._dirtyLeaves,a._dirtyElements));p!==a._compositionKey&&(c._flushSync=!0);let n=c._selection;if(C(n)){let r=c._nodeMap,w=n.focus.key;void 0!==r.get(n.anchor.key)&&void 0!==r.get(w)||q(19);}else qd(n)&&0===n._nodes.size&&(c._selection=null);}catch(p){p instanceof Error&&a._onError(p);a._pendingEditorState=h;a._dirtyType=2;a._cloneNotNeeded.clear();a._dirtyLeaves=new Set;a._dirtyElements.clear();he(a);return}finally{X=f,Z=k,Y=l,
    	a._updating=m,Gb=0;}b=null!==a._window?window.event:null;b=null!=b?b.type:null;0!==a._dirtyType||ne(c,a)||null!==a._blockCursorElement&&"blur"===b?c._flushSync?(c._flushSync=!1,he(a)):g&&tb(()=>{he(a);}):(c._flushSync=!1,g&&(d.clear(),a._deferred=[],a._pendingEditorState=null));}function v(a,b,c){a._updating?a._updates.push([b,c]):ke(a,b,c);}
    	function oe(a,b,c){F();var d=a.__key;let e=a.getParent();if(null!==e){var f=cc(a),g=!1;if(C(f)&&b){let h=f.anchor,k=f.focus;h.key===d&&(Yd(h,a,e,a.getPreviousSibling(),a.getNextSibling()),g=!0);k.key===d&&(Yd(k,a,e,a.getPreviousSibling(),a.getNextSibling()),g=!0);}C(f)&&b&&!g?(d=a.getIndexWithinParent(),Hb(a),Vd(f,e,d,-1)):Hb(a);c||fc(e)||e.canBeEmpty()||!e.isEmpty()||oe(e,b);b&&O(e)&&e.isEmpty()&&e.selectEnd();}}
    	class pe{static getType(){q(64);}static clone(){q(65);}constructor(a){this.__type=this.constructor.getType();this.__next=this.__prev=this.__parent=null;Fb(this,a);}getType(){return this.__type}isAttached(){for(var a=this.__key;null!==a;){if("root"===a)return !0;a=K(a);if(null===a)break;a=a.__parent;}return !1}isSelected(){let a=u();if(null==a)return !1;let b=a.getNodes().some(c=>c.__key===this.__key);return B(this)?b:C(a)&&"element"===a.anchor.type&&"element"===a.focus.type&&a.anchor.key===a.focus.key&&
    	a.anchor.offset===a.focus.offset?!1:b}getKey(){return this.__key}getIndexWithinParent(){var a=this.getParent();if(null===a)return -1;a=a.getFirstChild();let b=0;for(;null!==a;){if(this.is(a))return b;b++;a=a.getNextSibling();}return -1}getParent(){let a=this.getLatest().__parent;return null===a?null:K(a)}getParentOrThrow(){let a=this.getParent();null===a&&q(66);return a}getTopLevelElement(){let a=this;for(;null!==a;){let b=a.getParent();if(fc(b))return a;a=b;}return null}getTopLevelElementOrThrow(){let a=
    	this.getTopLevelElement();null===a&&q(67);return a}getParents(){let a=[],b=this.getParent();for(;null!==b;)a.push(b),b=b.getParent();return a}getParentKeys(){let a=[],b=this.getParent();for(;null!==b;)a.push(b.__key),b=b.getParent();return a}getPreviousSibling(){let a=this.getLatest().__prev;return null===a?null:K(a)}getPreviousSiblings(){let a=[];var b=this.getParent();if(null===b)return a;for(b=b.getFirstChild();null!==b&&!b.is(this);)a.push(b),b=b.getNextSibling();return a}getNextSibling(){let a=
    	this.getLatest().__next;return null===a?null:K(a)}getNextSiblings(){let a=[],b=this.getNextSibling();for(;null!==b;)a.push(b),b=b.getNextSibling();return a}getCommonAncestor(a){let b=this.getParents();var c=a.getParents();E(this)&&b.unshift(this);E(a)&&c.unshift(a);a=b.length;var d=c.length;if(0===a||0===d||b[a-1]!==c[d-1])return null;c=new Set(c);for(d=0;d<a;d++){let e=b[d];if(c.has(e))return e}return null}is(a){return null==a?!1:this.__key===a.__key}isBefore(a){if(a.isParentOf(this))return !0;if(this.isParentOf(a))return !1;
    	var b=this.getCommonAncestor(a);let c=this;for(;;){var d=c.getParentOrThrow();if(d===b){d=c.getIndexWithinParent();break}c=d;}for(c=a;;){a=c.getParentOrThrow();if(a===b){b=c.getIndexWithinParent();break}c=a;}return d<b}isParentOf(a){let b=this.__key;if(b===a.__key)return !1;for(;null!==a;){if(a.__key===b)return !0;a=a.getParent();}return !1}getNodesBetween(a){let b=this.isBefore(a),c=[],d=new Set;for(var e=this;;){var f=e.__key;d.has(f)||(d.add(f),c.push(e));if(e===a)break;f=E(e)?b?e.getFirstChild():e.getLastChild():
    	null;if(null!==f)e=f;else if(f=b?e.getNextSibling():e.getPreviousSibling(),null!==f)e=f;else {e=e.getParentOrThrow();d.has(e.__key)||c.push(e);if(e===a)break;f=e;do null===f&&q(68),e=b?f.getNextSibling():f.getPreviousSibling(),f=f.getParent(),null!==f&&(null!==e||d.has(f.__key)||c.push(f));while(null===e)}}b||c.reverse();return c}isDirty(){let a=G()._dirtyLeaves;return null!==a&&a.has(this.__key)}getLatest(){let a=K(this.__key);if(null===a)throw Error("Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.");
    	return a}getWritable(){F();var a=H(),b=G();a=a._nodeMap;let c=this.__key,d=this.getLatest(),e=d.__parent;b=b._cloneNotNeeded;var f=u();null!==f&&(f._cachedNodes=null);if(b.has(c))return Ib(d),d;f=d.constructor.clone(d);f.__parent=e;f.__next=d.__next;f.__prev=d.__prev;E(d)&&E(f)?(f.__first=d.__first,f.__last=d.__last,f.__size=d.__size,f.__indent=d.__indent,f.__format=d.__format,f.__dir=d.__dir):B(d)&&B(f)&&(f.__format=d.__format,f.__style=d.__style,f.__mode=d.__mode,f.__detail=d.__detail);b.add(c);
    	f.__key=c;Ib(f);a.set(c,f);return f}getTextContent(){return ""}getTextContentSize(){return this.getTextContent().length}createDOM(){q(70);}updateDOM(){q(71);}exportDOM(a){return {element:this.createDOM(a._config,a)}}exportJSON(){q(72);}static importJSON(){q(18);}remove(a){oe(this,!0,a);}replace(a,b){F();var c=u();null!==c&&(c=c.clone());hc(this,a);let d=this.getLatest(),e=this.__key,f=a.__key,g=a.getWritable();a=this.getParentOrThrow().getWritable();let h=a.__size;Hb(g);let k=d.getPreviousSibling(),l=d.getNextSibling(),
    	m=d.__prev,p=d.__next,n=d.__parent;oe(d,!1,!0);null===k?a.__first=f:k.getWritable().__next=f;g.__prev=m;null===l?a.__last=f:l.getWritable().__prev=f;g.__next=p;g.__parent=n;a.__size=h;b&&this.getChildren().forEach(r=>{g.append(r);});C(c)&&(nb(c),b=c.anchor,c=c.focus,b.key===e&&yd(b,g),c.key===e&&yd(c,g));Jb()===e&&J(f);return g}insertAfter(a,b=!0){F();hc(this,a);var c=this.getWritable();let d=a.getWritable();var e=d.getParent();let f=u();var g=!1,h=!1;if(null!==e){var k=a.getIndexWithinParent();Hb(d);
    	C(f)&&(h=e.__key,g=f.anchor,e=f.focus,g="element"===g.type&&g.key===h&&g.offset===k+1,h="element"===e.type&&e.key===h&&e.offset===k+1);}e=this.getNextSibling();k=this.getParentOrThrow().getWritable();let l=d.__key,m=c.__next;null===e?k.__last=l:e.getWritable().__prev=l;k.__size++;c.__next=l;d.__next=m;d.__prev=c.__key;d.__parent=c.__parent;b&&C(f)&&(b=this.getIndexWithinParent(),Vd(f,k,b+1),c=k.__key,g&&f.anchor.set(c,b+2,"element"),h&&f.focus.set(c,b+2,"element"));return a}insertBefore(a,b=!0){F();
    	hc(this,a);var c=this.getWritable();let d=a.getWritable(),e=d.__key;Hb(d);let f=this.getPreviousSibling(),g=this.getParentOrThrow().getWritable(),h=c.__prev,k=this.getIndexWithinParent();null===f?g.__first=e:f.getWritable().__next=e;g.__size++;c.__prev=e;d.__prev=h;d.__next=c.__key;d.__parent=c.__parent;c=u();b&&C(c)&&(b=this.getParentOrThrow(),Vd(c,b,k));return a}selectPrevious(a,b){F();let c=this.getPreviousSibling(),d=this.getParentOrThrow();return null===c?d.select(0,0):E(c)?c.select():B(c)?c.select(a,
    	b):(a=c.getIndexWithinParent()+1,d.select(a,a))}selectNext(a,b){F();let c=this.getNextSibling(),d=this.getParentOrThrow();return null===c?d.select():E(c)?c.select(0,0):B(c)?c.select(a,b):(a=c.getIndexWithinParent(),d.select(a,a))}markDirty(){this.getWritable();}}class qe extends pe{constructor(a){super(a);}decorate(){q(47);}isIsolated(){return !1}isInline(){return !0}isKeyboardSelectable(){return !0}}function z(a){return a instanceof qe}
    	class re extends pe{constructor(a){super(a);this.__last=this.__first=null;this.__indent=this.__format=this.__size=0;this.__dir=null;}getFormat(){return this.getLatest().__format}getFormatType(){let a=this.getFormat();return bb[a]||""}getIndent(){return this.getLatest().__indent}getChildren(){let a=[],b=this.getFirstChild();for(;null!==b;)a.push(b),b=b.getNextSibling();return a}getChildrenKeys(){let a=[],b=this.getFirstChild();for(;null!==b;)a.push(b.__key),b=b.getNextSibling();return a}getChildrenSize(){return this.getLatest().__size}isEmpty(){return 0===
    	this.getChildrenSize()}isDirty(){let a=G()._dirtyElements;return null!==a&&a.has(this.__key)}isLastChild(){let a=this.getLatest(),b=this.getParentOrThrow().getLastChild();return null!==b&&b.is(a)}getAllTextNodes(){let a=[],b=this.getFirstChild();for(;null!==b;){B(b)&&a.push(b);if(E(b)){let c=b.getAllTextNodes();a.push(...c);}b=b.getNextSibling();}return a}getFirstDescendant(){let a=this.getFirstChild();for(;null!==a;){if(E(a)){let b=a.getFirstChild();if(null!==b){a=b;continue}}break}return a}getLastDescendant(){let a=
    	this.getLastChild();for(;null!==a;){if(E(a)){let b=a.getLastChild();if(null!==b){a=b;continue}}break}return a}getDescendantByIndex(a){let b=this.getChildren(),c=b.length;if(a>=c)return a=b[c-1],E(a)&&a.getLastDescendant()||a||null;a=b[a];return E(a)&&a.getFirstDescendant()||a||null}getFirstChild(){let a=this.getLatest().__first;return null===a?null:K(a)}getFirstChildOrThrow(){let a=this.getFirstChild();null===a&&q(45);return a}getLastChild(){let a=this.getLatest().__last;return null===a?null:K(a)}getLastChildOrThrow(){let a=
    	this.getLastChild();null===a&&q(96);return a}getChildAtIndex(a){var b=this.getChildrenSize();let c;if(a<b/2){c=this.getFirstChild();for(b=0;null!==c&&b<=a;){if(b===a)return c;c=c.getNextSibling();b++;}return null}c=this.getLastChild();for(--b;null!==c&&b>=a;){if(b===a)return c;c=c.getPreviousSibling();b--;}return null}getTextContent(){let a="",b=this.getChildren(),c=b.length;for(let d=0;d<c;d++){let e=b[d];a+=e.getTextContent();E(e)&&d!==c-1&&!e.isInline()&&(a+="\n\n");}return a}getDirection(){return this.getLatest().__dir}hasFormat(a){return ""!==
    	a?(a=ab[a],0!==(this.getFormat()&a)):!1}select(a,b){F();let c=u(),d=a,e=b;var f=this.getChildrenSize();if(!this.canBeEmpty())if(0===a&&0===b){if(a=this.getFirstChild(),B(a)||E(a))return a.select(0,0)}else if(!(void 0!==a&&a!==f||void 0!==b&&b!==f)&&(a=this.getLastChild(),B(a)||E(a)))return a.select();void 0===d&&(d=f);void 0===e&&(e=f);f=this.__key;if(C(c))c.anchor.set(f,d,"element"),c.focus.set(f,e,"element"),c.dirty=!0;else return Td(f,d,f,e,"element","element");return c}selectStart(){let a=this.getFirstDescendant();
    	return E(a)||B(a)?a.select(0,0):null!==a?a.selectPrevious():this.select(0,0)}selectEnd(){let a=this.getLastDescendant();return E(a)||B(a)?a.select():null!==a?a.selectNext():this.select()}clear(){let a=this.getWritable();this.getChildren().forEach(b=>b.remove());return a}append(...a){return this.splice(this.getChildrenSize(),0,a)}setDirection(a){let b=this.getWritable();b.__dir=a;return b}setFormat(a){this.getWritable().__format=""!==a?ab[a]:0;return this}setIndent(a){this.getWritable().__indent=a;
    	return this}splice(a,b,c){let d=c.length,e=this.getChildrenSize(),f=this.getWritable(),g=f.__key;var h=[],k=[];let l=this.getChildAtIndex(a+b),m=null,p=e-b+d;if(0!==a)if(a===e)m=this.getLastChild();else {var n=this.getChildAtIndex(a);null!==n&&(m=n.getPreviousSibling());}if(0<b){var r=null===m?this.getFirstChild():m.getNextSibling();for(n=0;n<b;n++){null===r&&q(100);var w=r.getNextSibling(),y=r.__key;r=r.getWritable();Hb(r);k.push(y);r=w;}}n=m;for(w=0;w<d;w++){y=c[w];null!==n&&y.is(n)&&(m=n=n.getPreviousSibling());
    	r=y.getWritable();r.__parent===g&&p--;Hb(r);let x=y.__key;null===n?(f.__first=x,r.__prev=null):(n=n.getWritable(),n.__next=x,r.__prev=n.__key);y.__key===g&&q(76);r.__parent=g;h.push(x);n=y;}a+b===e?null!==n&&(n.getWritable().__next=null,f.__last=n.__key):null!==l&&(a=l.getWritable(),null!==n?(b=n.getWritable(),a.__prev=n.__key,b.__next=l.__key):a.__prev=null);f.__size=p;if(k.length&&(a=u(),C(a))){k=new Set(k);h=new Set(h);let {anchor:x,focus:A}=a;se(x,k,h)&&Yd(x,x.getNode(),this,m,l);se(A,k,h)&&Yd(A,
    	A.getNode(),this,m,l);0!==p||this.canBeEmpty()||fc(this)||this.remove();}return f}exportJSON(){return {children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:"element",version:1}}insertNewAfter(){return null}canInsertTab(){return !1}canIndent(){return !0}collapseAtStart(){return !1}excludeFromCopy(){return !1}canExtractContents(){return !0}canReplaceWith(){return !0}canInsertAfter(){return !0}canBeEmpty(){return !0}canInsertTextBefore(){return !0}canInsertTextAfter(){return !0}isInline(){return !1}isShadowRoot(){return !1}canMergeWith(){return !1}extractWithChild(){return !1}}
    	function E(a){return a instanceof re}function se(a,b,c){for(a=a.getNode();a;){let d=a.__key;if(b.has(d)&&!c.has(d))return !0;a=a.getParent();}return !1}
    	class te extends re{static getType(){return "root"}static clone(){return new te}constructor(){super("root");this.__cachedText=null;}getTopLevelElementOrThrow(){q(51);}getTextContent(){let a=this.__cachedText;return !Kb()&&0!==G()._dirtyType||null===a?super.getTextContent():a}remove(){q(52);}replace(){q(53);}insertBefore(){q(54);}insertAfter(){q(55);}updateDOM(){return !1}append(...a){for(let b=0;b<a.length;b++){let c=a[b];E(c)||z(c)||q(56);}return super.append(...a)}static importJSON(a){let b=Nb();b.setFormat(a.format);
    	b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:"root",version:1}}collapseAtStart(){return !0}}function O(a){return a instanceof te}function ne(a,b){b=b.getEditorState()._selection;a=a._selection;if(null!==a){if(a.dirty||!a.is(b))return !0}else if(null!==b)return !0;return !1}function ue(){return new me(new Map([["root",new te]]))}
    	function ve(a){let b=a.exportJSON();b.type!==a.constructor.getType()&&q(58);let c=b.children;if(E(a)){Array.isArray(c)||q(59);a=a.getChildren();for(let d=0;d<a.length;d++){let e=ve(a[d]);c.push(e);}}return b}
    	class me{constructor(a,b){this._nodeMap=a;this._selection=b||null;this._readOnly=this._flushSync=!1;}isEmpty(){return 1===this._nodeMap.size&&null===this._selection}read(a){return ge(this,a)}clone(a){a=new me(this._nodeMap,void 0===a?this._selection:a);a._readOnly=!0;return a}toJSON(){return ge(this,()=>({root:ve(Nb())}))}}
    	class we extends pe{static getType(){return "linebreak"}static clone(a){return new we(a.__key)}constructor(a){super(a);}getTextContent(){return "\n"}createDOM(){return document.createElement("br")}updateDOM(){return !1}static importDOM(){return {br:a=>{let b=a.parentElement;return null!=b&&b.firstChild===a&&b.lastChild===a?null:{conversion:xe,priority:0}}}}static importJSON(){return Ld()}exportJSON(){return {type:"linebreak",version:1}}}function xe(){return {node:Ld()}}function Ld(){return gc(new we)}
    	function Eb(a){return a instanceof we}function ye(a,b){return b&16?"code":b&32?"sub":b&64?"sup":null}function ze(a,b){return b&1?"strong":b&2?"em":"span"}
    	function Ae(a,b,c,d,e){a=d.classList;d=Wb(e,"base");void 0!==d&&a.add(...d);d=Wb(e,"underlineStrikethrough");let f=!1,g=b&8&&b&4;var h=c&8&&c&4;void 0!==d&&(h?(f=!0,g||a.add(...d)):g&&a.remove(...d));for(let k in Za)h=Za[k],d=Wb(e,k),void 0!==d&&(c&h?!f||"underline"!==k&&"strikethrough"!==k?(0===(b&h)||g&&"underline"===k||"strikethrough"===k)&&a.add(...d):b&h&&a.remove(...d):b&h&&a.remove(...d));}
    	function Be(a,b,c){let d=b.firstChild;c=c.isComposing();a+=c?Ua:"";if(null==d)b.textContent=a;else if(b=d.nodeValue,b!==a)if(c||Pa){c=b.length;let e=a.length,f=0,g=0;for(;f<c&&f<e&&b[f]===a[f];)f++;for(;g+f<c&&g+f<e&&b[c-g-1]===a[e-g-1];)g++;a=[f,c-f-g,a.slice(f,e-g)];let [h,k,l]=a;0!==k&&d.deleteData(h,k);d.insertData(h,l);}else d.nodeValue=a;}function Ce(a,b){b=document.createElement(b);b.appendChild(a);return b}
    	class De extends pe{static getType(){return "text"}static clone(a){return new De(a.__text,a.__key)}constructor(a,b){super(b);this.__text=a;this.__format=0;this.__style="";this.__detail=this.__mode=0;}getFormat(){return this.getLatest().__format}getDetail(){return this.getLatest().__detail}getMode(){let a=this.getLatest();return db[a.__mode]}getStyle(){return this.getLatest().__style}isToken(){return 1===this.getLatest().__mode}isComposing(){return this.__key===Jb()}isSegmented(){return 2===this.getLatest().__mode}isDirectionless(){return 0!==
    	(this.getLatest().__detail&1)}isUnmergeable(){return 0!==(this.getLatest().__detail&2)}hasFormat(a){a=Za[a];return 0!==(this.getFormat()&a)}isSimpleText(){return "text"===this.__type&&0===this.__mode}getTextContent(){return this.getLatest().__text}getFormatFlags(a,b){let c=this.getLatest().__format;return Cb(c,a,b)}createDOM(a){var b=this.__format,c=ye(this,b);let d=ze(this,b),e=document.createElement(null===c?d:c),f=e;null!==c&&(f=document.createElement(d),e.appendChild(f));c=f;Be(this.__text,c,this);
    	a=a.theme.text;void 0!==a&&Ae(d,0,b,c,a);b=this.__style;""!==b&&(e.style.cssText=b);return e}updateDOM(a,b,c){let d=this.__text;var e=a.__format,f=this.__format,g=ye(this,e);let h=ye(this,f);var k=ze(this,e);let l=ze(this,f);if((null===g?k:g)!==(null===h?l:h))return !0;if(g===h&&k!==l)return e=b.firstChild,null==e&&q(48),a=g=document.createElement(l),Be(d,a,this),c=c.theme.text,void 0!==c&&Ae(l,0,f,a,c),b.replaceChild(g,e),!1;k=b;null!==h&&null!==g&&(k=b.firstChild,null==k&&q(49));Be(d,k,this);c=c.theme.text;
    	void 0!==c&&e!==f&&Ae(l,e,f,k,c);f=this.__style;a.__style!==f&&(b.style.cssText=f);return !1}static importDOM(){return {"#text":()=>({conversion:Ee,priority:0}),b:()=>({conversion:Fe,priority:0}),br:()=>({conversion:Ge,priority:0}),code:()=>({conversion:Je,priority:0}),em:()=>({conversion:Je,priority:0}),i:()=>({conversion:Je,priority:0}),s:()=>({conversion:Je,priority:0}),span:()=>({conversion:Ke,priority:0}),strong:()=>({conversion:Je,priority:0}),sub:()=>({conversion:Je,priority:0}),sup:()=>({conversion:Je,
    	priority:0}),u:()=>({conversion:Je,priority:0})}}static importJSON(a){let b=M(a.text);b.setFormat(a.format);b.setDetail(a.detail);b.setMode(a.mode);b.setStyle(a.style);return b}exportDOM(a){({element:a}=super.exportDOM(a));null!==a&&(this.hasFormat("bold")&&(a=Ce(a,"b")),this.hasFormat("italic")&&(a=Ce(a,"i")),this.hasFormat("strikethrough")&&(a=Ce(a,"s")),this.hasFormat("underline")&&(a=Ce(a,"u")));return {element:a}}exportJSON(){return {detail:this.getDetail(),format:this.getFormat(),mode:this.getMode(),
    	style:this.getStyle(),text:this.getTextContent(),type:"text",version:1}}selectionTransform(){}setFormat(a){let b=this.getWritable();b.__format="string"===typeof a?Za[a]:a;return b}setDetail(a){let b=this.getWritable();b.__detail="string"===typeof a?$a[a]:a;return b}setStyle(a){let b=this.getWritable();b.__style=a;return b}toggleFormat(a){a=Za[a];return this.setFormat(this.getFormat()^a)}toggleDirectionless(){let a=this.getWritable();a.__detail^=1;return a}toggleUnmergeable(){let a=this.getWritable();
    	a.__detail^=2;return a}setMode(a){a=cb[a];if(this.__mode===a)return this;let b=this.getWritable();b.__mode=a;return b}setTextContent(a){if(this.__text===a)return this;let b=this.getWritable();b.__text=a;return b}select(a,b){F();let c=u();var d=this.getTextContent();let e=this.__key;"string"===typeof d?(d=d.length,void 0===a&&(a=d),void 0===b&&(b=d)):b=a=0;if(C(c))d=Jb(),d!==c.anchor.key&&d!==c.focus.key||J(e),c.setTextNodeRange(this,a,this,b);else return Td(e,a,e,b,"text","text");return c}spliceText(a,
    	b,c,d){let e=this.getWritable(),f=e.__text,g=c.length,h=a;0>h&&(h=g+h,0>h&&(h=0));let k=u();d&&C(k)&&(a+=g,k.setTextNodeRange(e,a,e,a));b=f.slice(0,h)+c+f.slice(h+b);e.__text=b;return e}canInsertTextBefore(){return !0}canInsertTextAfter(){return !0}splitText(...a){F();var b=this.getLatest(),c=b.getTextContent(),d=b.__key,e=Jb(),f=new Set(a);a=[];var g=c.length,h="";for(var k=0;k<g;k++)""!==h&&f.has(k)&&(a.push(h),h=""),h+=c[k];""!==h&&a.push(h);f=a.length;if(0===f)return [];if(a[0]===c)return [b];var l=
    	a[0];c=b.getParentOrThrow();k=b.getFormat();let m=b.getStyle(),p=b.__detail;g=!1;b.isSegmented()?(h=M(l),h.__format=k,h.__style=m,h.__detail=p,g=!0):(h=b.getWritable(),h.__text=l);b=u();h=[h];l=l.length;for(let w=1;w<f;w++){var n=a[w],r=n.length;n=M(n).getWritable();n.__format=k;n.__style=m;n.__detail=p;let y=n.__key;r=l+r;if(C(b)){let x=b.anchor,A=b.focus;x.key===d&&"text"===x.type&&x.offset>l&&x.offset<=r&&(x.key=y,x.offset-=l,b.dirty=!0);A.key===d&&"text"===A.type&&A.offset>l&&A.offset<=r&&(A.key=
    	y,A.offset-=l,b.dirty=!0);}e===d&&J(y);l=r;h.push(n);}d=this.getPreviousSibling();e=this.getNextSibling();null!==d&&Ib(d);null!==e&&Ib(e);d=c.getWritable();e=this.getIndexWithinParent();g?(d.splice(e,0,h),this.remove()):d.splice(e,1,h);C(b)&&Vd(b,c,e,f-1);return h}mergeWithSibling(a){var b=a===this.getPreviousSibling();b||a===this.getNextSibling()||q(50);var c=this.__key;let d=a.__key,e=this.__text,f=e.length;Jb()===d&&J(c);let g=u();if(C(g)){let h=g.anchor,k=g.focus;null!==h&&h.key===d&&(Zd(h,b,c,
    	a,f),g.dirty=!0);null!==k&&k.key===d&&(Zd(k,b,c,a,f),g.dirty=!0);}c=a.__text;this.setTextContent(b?c+e:e+c);b=this.getWritable();a.remove();return b}isTextEntity(){return !1}}
    	function Ke(a){let b="700"===a.style.fontWeight,c="line-through"===a.style.textDecoration,d="italic"===a.style.fontStyle,e="underline"===a.style.textDecoration,f=a.style.verticalAlign;return {forChild:g=>{if(!B(g))return g;b&&g.toggleFormat("bold");c&&g.toggleFormat("strikethrough");d&&g.toggleFormat("italic");e&&g.toggleFormat("underline");"sub"===f&&g.toggleFormat("subscript");"super"===f&&g.toggleFormat("superscript");return g},node:null}}function Ge(){return {node:Ld()}}
    	function Fe(a){let b="normal"===a.style.fontWeight;return {forChild:c=>{B(c)&&!b&&c.toggleFormat("bold");return c},node:null}}function Ee(a,b,c){a=a.textContent||"";return !c&&/\n/.test(a)&&(a=a.replace(/\r?\n/gm," "),0===a.trim().length)?{node:null}:{node:M(a)}}let Le={code:"code",em:"italic",i:"italic",s:"strikethrough",strong:"bold",sub:"subscript",sup:"superscript",u:"underline"};
    	function Je(a){let b=Le[a.nodeName.toLowerCase()];return void 0===b?{node:null}:{forChild:c=>{B(c)&&!c.hasFormat(b)&&c.toggleFormat(b);return c},node:null}}function M(a=""){return gc(new De(a))}function B(a){return a instanceof De}
    	class Me extends re{static getType(){return "paragraph"}static clone(a){return new Me(a.__key)}createDOM(a){let b=document.createElement("p");a=Wb(a.theme,"paragraph");void 0!==a&&b.classList.add(...a);return b}updateDOM(){return !1}static importDOM(){return {p:()=>({conversion:Ne,priority:0})}}exportDOM(a){({element:a}=super.exportDOM(a));a&&this.isEmpty()&&a.append(document.createElement("br"));if(a){var b=this.getFormatType();a.style.textAlign=b;if(b=this.getDirection())a.dir=b;b=this.getIndent();
    	0<b&&(a.style.textIndent=`${20*b}px`);}return {element:a}}static importJSON(a){let b=Ad();b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {...super.exportJSON(),type:"paragraph",version:1}}insertNewAfter(a,b){a=Ad();let c=this.getDirection();a.setDirection(c);this.insertAfter(a,b);return a}collapseAtStart(){let a=this.getChildren();if(0===a.length||B(a[0])&&""===a[0].getTextContent().trim()){if(null!==this.getNextSibling())return this.selectNext(),
    	this.remove(),!0;if(null!==this.getPreviousSibling())return this.selectPrevious(),this.remove(),!0}return !1}}function Ne(){return {node:Ad()}}function Ad(){return gc(new Me)}
    	function ie(a,b,c,d){let e=a._keyToDOMMap;e.clear();a._editorState=ue();a._pendingEditorState=d;a._compositionKey=null;a._dirtyType=0;a._cloneNotNeeded.clear();a._dirtyLeaves=new Set;a._dirtyElements.clear();a._normalizedNodes=new Set;a._updateTags=new Set;a._updates=[];a._blockCursorElement=null;d=a._observer;null!==d&&(d.disconnect(),a._observer=null);null!==b&&(b.textContent="");null!==c&&(c.textContent="",e.set("root",c));}
    	function Oe(a){let b=new Map,c=new Set;a.forEach(d=>{d=null!=d.klass.importDOM?d.klass.importDOM.bind(d.klass):null;if(null!=d&&!c.has(d)){c.add(d);var e=d();null!==e&&Object.keys(e).forEach(f=>{let g=b.get(f);void 0===g&&(g=[],b.set(f,g));g.push(e[f]);});}});return b}
    	class Pe{constructor(a,b,c,d,e,f){this._parentEditor=b;this._rootElement=null;this._editorState=a;this._compositionKey=this._pendingEditorState=null;this._deferred=[];this._keyToDOMMap=new Map;this._updates=[];this._updating=!1;this._listeners={decorator:new Set,editable:new Set,mutation:new Map,root:new Set,textcontent:new Set,update:new Set};this._commands=new Map;this._config=d;this._nodes=c;this._decorators={};this._pendingDecorators=null;this._dirtyType=0;this._cloneNotNeeded=new Set;this._dirtyLeaves=
    	new Set;this._dirtyElements=new Map;this._normalizedNodes=new Set;this._updateTags=new Set;this._observer=null;this._key=Sb();this._onError=e;this._htmlConversions=f;this._editable=!0;this._headless=null!==b&&b._headless;this._blockCursorElement=this._window=null;}isComposing(){return null!=this._compositionKey}registerUpdateListener(a){let b=this._listeners.update;b.add(a);return ()=>{b.delete(a);}}registerEditableListener(a){let b=this._listeners.editable;b.add(a);return ()=>{b.delete(a);}}registerDecoratorListener(a){let b=
    	this._listeners.decorator;b.add(a);return ()=>{b.delete(a);}}registerTextContentListener(a){let b=this._listeners.textcontent;b.add(a);return ()=>{b.delete(a);}}registerRootListener(a){let b=this._listeners.root;a(this._rootElement,null);b.add(a);return ()=>{a(null,this._rootElement);b.delete(a);}}registerCommand(a,b,c){void 0===c&&q(35);let d=this._commands;d.has(a)||d.set(a,[new Set,new Set,new Set,new Set,new Set]);let e=d.get(a);void 0===e&&q(36);let f=e[c];f.add(b);return ()=>{f.delete(b);e.every(g=>
    	0===g.size)&&d.delete(a);}}registerMutationListener(a,b){void 0===this._nodes.get(a.getType())&&q(37);let c=this._listeners.mutation;c.set(b,a);return ()=>{c.delete(b);}}registerNodeTransform(a,b){a=a.getType();let c=this._nodes.get(a);void 0===c&&q(37);let d=c.transforms;d.add(b);Ob(this,a);return ()=>{d.delete(b);}}hasNodes(a){for(let b=0;b<a.length;b++){let c=a[b].getType();if(!this._nodes.has(c))return !1}return !0}dispatchCommand(a,b){return T(this,a,b)}getDecorators(){return this._decorators}getRootElement(){return this._rootElement}getKey(){return this._key}setRootElement(a){let b=
    	this._rootElement;if(a!==b){let e=Wb(this._config.theme,"root");var c=this._pendingEditorState||this._editorState;this._rootElement=a;ie(this,b,a,c);if(null!==b){if(!this._config.disableEvents){0!==ed&&(ed--,0===ed&&b.ownerDocument.removeEventListener("selectionchange",td));c=b.__lexicalEditor;if(null!==c&&void 0!==c){if(null!==c._parentEditor){var d=Rb(c);d=d[d.length-1]._key;sd.get(d)===c&&sd.delete(d);}else sd.delete(c._key);b.__lexicalEditor=null;}c=rd(b);for(d=0;d<c.length;d++)c[d]();b.__lexicalEventHandles=
    	[];}null!=e&&b.classList.remove(...e);}null!==a?(c=(c=a.ownerDocument)&&c.defaultView||null,d=a.style,d.userSelect="text",d.whiteSpace="pre-wrap",d.wordBreak="break-word",a.setAttribute("data-lexical-editor","true"),this._window=c,this._dirtyType=2,qb(this),this._updateTags.add("history-merge"),he(this),this._config.disableEvents||vd(a,this),null!=e&&a.classList.add(...e)):this._window=null;je("root",this,!1,a,b);}}getElementByKey(a){return this._keyToDOMMap.get(a)||null}getEditorState(){return this._editorState}setEditorState(a,
    	b){a.isEmpty()&&q(38);pb(this);let c=this._pendingEditorState,d=this._updateTags;b=void 0!==b?b.tag:null;null===c||c.isEmpty()||(null!=b&&d.add(b),he(this));this._pendingEditorState=a;this._dirtyType=2;this._dirtyElements.set("root",!1);this._compositionKey=null;null!=b&&d.add(b);he(this);}parseEditorState(a,b){a="string"===typeof a?JSON.parse(a):a;let c=ue(),d=X,e=Z,f=Y,g=this._dirtyElements,h=this._dirtyLeaves,k=this._cloneNotNeeded,l=this._dirtyType;this._dirtyElements=new Map;this._dirtyLeaves=
    	new Set;this._cloneNotNeeded=new Set;this._dirtyType=0;X=c;Z=!1;Y=this;try{fe(a.root,this._nodes),b&&b(),c._readOnly=!0;}finally{this._dirtyElements=g,this._dirtyLeaves=h,this._cloneNotNeeded=k,this._dirtyType=l,X=d,Z=e,Y=f;}return c}update(a,b){v(this,a,b);}focus(a,b={}){let c=this._rootElement;null!==c&&(c.setAttribute("autocapitalize","off"),v(this,()=>{let d=u(),e=Nb();null!==d?d.dirty=!0:0!==e.getChildrenSize()&&("rootStart"===b.defaultSelection?e.selectStart():e.selectEnd());},{onUpdate:()=>{c.removeAttribute("autocapitalize");
    	a&&a();}}),null===this._pendingEditorState&&c.removeAttribute("autocapitalize"));}blur(){var a=this._rootElement;null!==a&&a.blur();a=D(this._window);null!==a&&a.removeAllRanges();}isEditable(){return this._editable}setEditable(a){this._editable!==a&&(this._editable=a,je("editable",this,!0,a));}toJSON(){return {editorState:this._editorState.toJSON()}}}class Qe extends re{constructor(a,b){super(b);this.__colSpan=a;}exportJSON(){return {...super.exportJSON(),colSpan:this.__colSpan}}}
    	function Jd(a){return a instanceof Qe}class Re extends re{}function Hd(a){return a instanceof Re}class Se extends re{}function Id(a){return a instanceof Se}Lexical_prod.$addUpdateTag=function(a){F();G()._updateTags.add(a);};Lexical_prod.$applyNodeReplacement=gc;Lexical_prod.$copyNode=function(a){a=a.constructor.clone(a);Fb(a,null);return a};Lexical_prod.$createLineBreakNode=Ld;Lexical_prod.$createNodeSelection=Od;Lexical_prod.$createParagraphNode=Ad;
    	Lexical_prod.$createRangeSelection=function(){let a=new W("root",0,"element"),b=new W("root",0,"element");return new Dd(a,b,0)};Lexical_prod.$createTextNode=M;Lexical_prod.$getAdjacentNode=Zb;Lexical_prod.$getNearestNodeFromDOMNode=kb;Lexical_prod.$getNearestRootOrShadowRoot=ec;Lexical_prod.$getNodeByKey=K;Lexical_prod.$getPreviousSelection=Ub;Lexical_prod.$getRoot=Nb;Lexical_prod.$getSelection=u;Lexical_prod.$getTextContent=function(){let a=u();return null===a?"":a.getTextContent()};Lexical_prod.$hasAncestor=dc;
    	Lexical_prod.$insertNodes=function(a,b){let c=u();null===c&&(c=Nb().selectEnd());return c.insertNodes(a,b)};Lexical_prod.$isDecoratorNode=z;Lexical_prod.$isElementNode=E;Lexical_prod.$isInlineElementOrDecoratorNode=function(a){return E(a)&&a.isInline()||z(a)&&a.isInline()};Lexical_prod.$isLeafNode=Db;Lexical_prod.$isLineBreakNode=Eb;Lexical_prod.$isNodeSelection=qd;Lexical_prod.$isParagraphNode=function(a){return a instanceof Me};Lexical_prod.$isRangeSelection=C;Lexical_prod.$isRootNode=O;Lexical_prod.$isRootOrShadowRoot=fc;Lexical_prod.$isTextNode=B;
    	Lexical_prod.$nodesOfType=function(a){var b=H();let c=b._readOnly,d=a.getType();b=b._nodeMap;let e=[];for(let [,f]of b)f instanceof a&&f.__type===d&&(c||f.isAttached())&&e.push(f);return e};Lexical_prod.$normalizeSelection__EXPERIMENTAL=qc;Lexical_prod.$parseSerializedNode=function(a){return fe(a,G()._nodes)};Lexical_prod.$setCompositionKey=J;Lexical_prod.$setSelection=nb;Lexical_prod.BLUR_COMMAND=La;Lexical_prod.CAN_REDO_COMMAND={};Lexical_prod.CAN_UNDO_COMMAND={};Lexical_prod.CLEAR_EDITOR_COMMAND={};Lexical_prod.CLEAR_HISTORY_COMMAND={};
    	Lexical_prod.CLICK_COMMAND=ba;Lexical_prod.COMMAND_PRIORITY_CRITICAL=4;Lexical_prod.COMMAND_PRIORITY_EDITOR=0;Lexical_prod.COMMAND_PRIORITY_HIGH=3;Lexical_prod.COMMAND_PRIORITY_LOW=1;Lexical_prod.COMMAND_PRIORITY_NORMAL=2;Lexical_prod.CONTROLLED_TEXT_INSERTION_COMMAND=ha;Lexical_prod.COPY_COMMAND=Ia;Lexical_prod.CUT_COMMAND=Ja;Lexical_prod.DELETE_CHARACTER_COMMAND=ca;Lexical_prod.DELETE_LINE_COMMAND=ma;Lexical_prod.DELETE_WORD_COMMAND=ka;
    	Lexical_prod.DEPRECATED_$createGridSelection=function(){let a=new W("root",0,"element"),b=new W("root",0,"element");return new Ed("root",a,b)};Lexical_prod.DEPRECATED_$isGridCellNode=Jd;Lexical_prod.DEPRECATED_$isGridNode=Hd;Lexical_prod.DEPRECATED_$isGridRowNode=Id;Lexical_prod.DEPRECATED_$isGridSelection=Fd;Lexical_prod.DEPRECATED_GridCellNode=Qe;Lexical_prod.DEPRECATED_GridNode=Re;Lexical_prod.DEPRECATED_GridRowNode=Se;Lexical_prod.DRAGEND_COMMAND=Ha;Lexical_prod.DRAGOVER_COMMAND=Ga;Lexical_prod.DRAGSTART_COMMAND=Fa;Lexical_prod.DROP_COMMAND=Ea;
    	Lexical_prod.DecoratorNode=qe;Lexical_prod.ElementNode=re;Lexical_prod.FOCUS_COMMAND=Ka;Lexical_prod.FORMAT_ELEMENT_COMMAND={};Lexical_prod.FORMAT_TEXT_COMMAND=na;Lexical_prod.INDENT_CONTENT_COMMAND={};Lexical_prod.INSERT_LINE_BREAK_COMMAND=ea;Lexical_prod.INSERT_PARAGRAPH_COMMAND=fa;Lexical_prod.KEY_ARROW_DOWN_COMMAND=wa;Lexical_prod.KEY_ARROW_LEFT_COMMAND=sa;Lexical_prod.KEY_ARROW_RIGHT_COMMAND=qa;Lexical_prod.KEY_ARROW_UP_COMMAND=va;Lexical_prod.KEY_BACKSPACE_COMMAND=za;Lexical_prod.KEY_DELETE_COMMAND=Ba;Lexical_prod.KEY_ENTER_COMMAND=xa;Lexical_prod.KEY_ESCAPE_COMMAND=Aa;
    	Lexical_prod.KEY_MODIFIER_COMMAND=Ma;Lexical_prod.KEY_SPACE_COMMAND=ya;Lexical_prod.KEY_TAB_COMMAND=Ca;Lexical_prod.LineBreakNode=we;Lexical_prod.MOVE_TO_END=ra;Lexical_prod.MOVE_TO_START=ua;Lexical_prod.OUTDENT_CONTENT_COMMAND={};Lexical_prod.PASTE_COMMAND=ia;Lexical_prod.ParagraphNode=Me;Lexical_prod.REDO_COMMAND=pa;Lexical_prod.REMOVE_TEXT_COMMAND=ja;Lexical_prod.RootNode=te;Lexical_prod.SELECTION_CHANGE_COMMAND=aa;Lexical_prod.TextNode=De;Lexical_prod.UNDO_COMMAND=oa;Lexical_prod.createCommand=function(){return {}};
    	Lexical_prod.createEditor=function(a){var b=a||{},c=Y,d=b.theme||{};let e=void 0===a?c:b.parentEditor||null,f=b.disableEvents||!1,g=ue(),h=b.namespace||(null!==e?e._config.namespace:Sb()),k=b.editorState,l=[te,De,we,Me,...(b.nodes||[])],m=b.onError;b=void 0!==b.editable?b.editable:!0;if(void 0===a&&null!==c)a=c._nodes;else for(a=new Map,c=0;c<l.length;c++){let n=l[c];var p=null;"function"!==typeof n&&(p=n,n=p.replace,p=p.with);let r=n.getType();a.set(r,{klass:n,replace:p,transforms:new Set});}d=new Pe(g,
    	e,a,{disableEvents:f,namespace:h,theme:d},m?m:console.error,Oe(a),b);void 0!==k&&(d._pendingEditorState=k,d._dirtyType=2);return d};
    	return Lexical_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const Lexical = process.env.NODE_ENV === 'development' ? requireLexical_dev() : requireLexical_prod();
    var Lexical_1 = Lexical;

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalSelection_dev;

    function requireLexicalSelection_dev () {
    	if (hasRequiredLexicalSelection_dev) return LexicalSelection_dev;
    	hasRequiredLexicalSelection_dev = 1;

    	var lexical = Lexical_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const CSS_TO_STYLES = new Map();

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	function getDOMTextNode(element) {
    	  let node = element;

    	  while (node != null) {
    	    if (node.nodeType === Node.TEXT_NODE) {
    	      return node;
    	    }

    	    node = node.firstChild;
    	  }

    	  return null;
    	}

    	function getDOMIndexWithinParent(node) {
    	  const parent = node.parentNode;

    	  if (parent == null) {
    	    throw new Error('Should never happen');
    	  }

    	  return [parent, Array.from(parent.childNodes).indexOf(node)];
    	}

    	function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
    	  const anchorKey = anchorNode.getKey();
    	  const focusKey = focusNode.getKey();
    	  const range = document.createRange();
    	  let anchorDOM = editor.getElementByKey(anchorKey);
    	  let focusDOM = editor.getElementByKey(focusKey);
    	  let anchorOffset = _anchorOffset;
    	  let focusOffset = _focusOffset;

    	  if (lexical.$isTextNode(anchorNode)) {
    	    anchorDOM = getDOMTextNode(anchorDOM);
    	  }

    	  if (lexical.$isTextNode(focusNode)) {
    	    focusDOM = getDOMTextNode(focusDOM);
    	  }

    	  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {
    	    return null;
    	  }

    	  if (anchorDOM.nodeName === 'BR') {
    	    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
    	  }

    	  if (focusDOM.nodeName === 'BR') {
    	    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
    	  }

    	  const firstChild = anchorDOM.firstChild;

    	  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {
    	    focusOffset = 1;
    	  }

    	  try {
    	    range.setStart(anchorDOM, anchorOffset);
    	    range.setEnd(focusDOM, focusOffset);
    	  } catch (e) {
    	    return null;
    	  }

    	  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
    	    // Range is backwards, we need to reverse it
    	    range.setStart(focusDOM, focusOffset);
    	    range.setEnd(anchorDOM, anchorOffset);
    	  }

    	  return range;
    	}
    	function createRectsFromDOMRange(editor, range) {
    	  const rootElement = editor.getRootElement();

    	  if (rootElement === null) {
    	    return [];
    	  }

    	  const rootRect = rootElement.getBoundingClientRect();
    	  const computedStyle = getComputedStyle(rootElement);
    	  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
    	  const selectionRects = Array.from(range.getClientRects());
    	  let selectionRectsLength = selectionRects.length;
    	  let prevRect;

    	  for (let i = 0; i < selectionRectsLength; i++) {
    	    const selectionRect = selectionRects[i]; // Exclude a rect that is the exact same as the last rect. getClientRects() can return
    	    // the same rect twice for some elements. A more sophisticated thing to do here is to
    	    // merge all the rects together into a set of rects that don't overlap, so we don't
    	    // generate backgrounds that are too dark.

    	    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height; // Exclude selections that span the entire element

    	    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;

    	    if (isDuplicateRect || selectionSpansElement) {
    	      selectionRects.splice(i--, 1);
    	      selectionRectsLength--;
    	      continue;
    	    }

    	    prevRect = selectionRect;
    	  }

    	  return selectionRects;
    	}
    	function getStyleObjectFromRawCSS(css) {
    	  const styleObject = {};
    	  const styles = css.split(';');

    	  for (const style of styles) {
    	    if (style !== '') {
    	      const [key, value] = style.split(/:([^]+)/); // split on first colon

    	      styleObject[key.trim()] = value.trim();
    	    }
    	  }

    	  return styleObject;
    	}
    	function getStyleObjectFromCSS(css) {
    	  let value = CSS_TO_STYLES.get(css);

    	  if (value === undefined) {
    	    value = getStyleObjectFromRawCSS(css);
    	    CSS_TO_STYLES.set(css, value);
    	  }

    	  return value;
    	}
    	function getCSSFromStyleObject(styles) {
    	  let css = '';

    	  for (const style in styles) {
    	    if (style) {
    	      css += `${style}: ${styles[style]};`;
    	    }
    	  }

    	  return css;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	function $updateElementNodeProperties(target, source) {
    	  target.__first = source.__first;
    	  target.__last = source.__last;
    	  target.__size = source.__size;
    	  target.__format = source.__format;
    	  target.__indent = source.__indent;
    	  target.__dir = source.__dir;
    	  return target;
    	}

    	function $updateTextNodeProperties(target, source) {
    	  target.__format = source.__format;
    	  target.__style = source.__style;
    	  target.__mode = source.__mode;
    	  target.__detail = source.__detail;
    	  return target;
    	}

    	function $cloneWithProperties(node) {
    	  const latest = node.getLatest();
    	  const constructor = latest.constructor; // @ts-expect-error

    	  const clone = constructor.clone(latest);
    	  clone.__parent = latest.__parent;
    	  clone.__next = latest.__next;
    	  clone.__prev = latest.__prev;

    	  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {
    	    return $updateElementNodeProperties(clone, latest);
    	  }

    	  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {
    	    return $updateTextNodeProperties(clone, latest);
    	  }

    	  return clone;
    	}
    	function $sliceSelectedTextNodeContent(selection, textNode) {
    	  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {
    	    const anchorNode = selection.anchor.getNode();
    	    const focusNode = selection.focus.getNode();
    	    const isAnchor = textNode.is(anchorNode);
    	    const isFocus = textNode.is(focusNode);

    	    if (isAnchor || isFocus) {
    	      const isBackward = selection.isBackward();
    	      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();
    	      const isSame = anchorNode.is(focusNode);
    	      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
    	      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
    	      let startOffset = 0;
    	      let endOffset = undefined;

    	      if (isSame) {
    	        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
    	        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
    	      } else if (isFirst) {
    	        const offset = isBackward ? focusOffset : anchorOffset;
    	        startOffset = offset;
    	        endOffset = undefined;
    	      } else if (isLast) {
    	        const offset = isBackward ? anchorOffset : focusOffset;
    	        startOffset = 0;
    	        endOffset = offset;
    	      }

    	      textNode.__text = textNode.__text.slice(startOffset, endOffset);
    	      return textNode;
    	    }
    	  }

    	  return textNode;
    	}
    	function $isAtNodeEnd(point) {
    	  if (point.type === 'text') {
    	    return point.offset === point.getNode().getTextContentSize();
    	  }

    	  return point.offset === point.getNode().getChildrenSize();
    	}
    	function trimTextContentFromAnchor(editor, anchor, delCount) {
    	  // Work from the current selection anchor point
    	  let currentNode = anchor.getNode();
    	  let remaining = delCount;

    	  if (lexical.$isElementNode(currentNode)) {
    	    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);

    	    if (descendantNode !== null) {
    	      currentNode = descendantNode;
    	    }
    	  }

    	  while (remaining > 0 && currentNode !== null) {
    	    let nextNode = currentNode.getPreviousSibling();
    	    let additionalElementWhitespace = 0;

    	    if (nextNode === null) {
    	      let parent = currentNode.getParentOrThrow();
    	      let parentSibling = parent.getPreviousSibling();

    	      while (parentSibling === null) {
    	        parent = parent.getParent();

    	        if (parent === null) {
    	          nextNode = null;
    	          break;
    	        }

    	        parentSibling = parent.getPreviousSibling();
    	      }

    	      if (parent !== null) {
    	        additionalElementWhitespace = parent.isInline() ? 0 : 2;

    	        if (lexical.$isElementNode(parentSibling)) {
    	          nextNode = parentSibling.getLastDescendant();
    	        } else {
    	          nextNode = parentSibling;
    	        }
    	      }
    	    }

    	    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match
    	    // the content if we were to get it from its parent.

    	    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {
    	      // TODO: should this be handled in core?
    	      text = '\n\n';
    	    }

    	    const textNodeSize = text.length;
    	    const offset = textNodeSize - remaining;
    	    const slicedText = text.slice(0, offset);

    	    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {
    	      const parent = currentNode.getParent();
    	      currentNode.remove();

    	      if (parent != null && parent.getChildrenSize() === 0) {
    	        parent.remove();
    	      }

    	      remaining -= textNodeSize + additionalElementWhitespace;
    	      currentNode = nextNode;
    	    } else {
    	      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state

    	      const prevTextContent = editor.getEditorState().read(() => {
    	        const prevNode = lexical.$getNodeByKey(key);

    	        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {
    	          return prevNode.getTextContent();
    	        }

    	        return null;
    	      });

    	      if (prevTextContent !== null && prevTextContent !== text) {
    	        const prevSelection = lexical.$getPreviousSelection();
    	        let target = currentNode;

    	        if (!currentNode.isSimpleText()) {
    	          const textNode = lexical.$createTextNode(prevTextContent);
    	          currentNode.replace(textNode);
    	          target = textNode;
    	        } else {
    	          currentNode.setTextContent(prevTextContent);
    	        }

    	        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
    	          const prevOffset = prevSelection.anchor.offset;
    	          target.select(prevOffset, prevOffset);
    	        }
    	      } else if (currentNode.isSimpleText()) {
    	        // Split text
    	        const isSelected = anchor.key === key;
    	        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaniing number, otherwise
    	        // we'll have a negative splitStart.

    	        if (anchorOffset < remaining) {
    	          anchorOffset = textNodeSize;
    	        }

    	        const splitStart = isSelected ? anchorOffset - remaining : 0;
    	        const splitEnd = isSelected ? anchorOffset : offset;

    	        if (isSelected && splitStart === 0) {
    	          const [excessNode] = currentNode.splitText(splitStart, splitEnd);
    	          excessNode.remove();
    	        } else {
    	          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
    	          excessNode.remove();
    	        }
    	      } else {
    	        const textNode = lexical.$createTextNode(slicedText);
    	        currentNode.replace(textNode);
    	      }

    	      remaining = 0;
    	    }
    	  }
    	}
    	function $addNodeStyle(node) {
    	  const CSSText = node.getStyle();
    	  const styles = getStyleObjectFromRawCSS(CSSText);
    	  CSS_TO_STYLES.set(CSSText, styles);
    	}

    	function $patchNodeStyle(node, patch) {
    	  const prevStyles = getStyleObjectFromCSS(node.getStyle());
    	  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
    	    if (value === null) {
    	      delete styles[key];
    	    } else {
    	      styles[key] = value;
    	    }

    	    return styles;
    	  }, { ...prevStyles
    	  } || {});
    	  const newCSSText = getCSSFromStyleObject(newStyles);
    	  node.setStyle(newCSSText);
    	  CSS_TO_STYLES.set(newCSSText, newStyles);
    	}

    	function $patchStyleText(selection, patch) {
    	  const selectedNodes = selection.getNodes();
    	  const selectedNodesLength = selectedNodes.length;
    	  const lastIndex = selectedNodesLength - 1;
    	  let firstNode = selectedNodes[0];
    	  let lastNode = selectedNodes[lastIndex];

    	  if (selection.isCollapsed()) {
    	    return;
    	  }

    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const firstNodeText = firstNode.getTextContent();
    	  const firstNodeTextLength = firstNodeText.length;
    	  const focusOffset = focus.offset;
    	  let anchorOffset = anchor.offset;
    	  const isBefore = anchor.isBefore(focus);
    	  let startOffset = isBefore ? anchorOffset : focusOffset;
    	  let endOffset = isBefore ? focusOffset : anchorOffset;
    	  const startType = isBefore ? anchor.type : focus.type;
    	  const endType = isBefore ? focus.type : anchor.type;
    	  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the
    	  // first node so we don't want to include it in the formatting change.

    	  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {
    	    const nextSibling = firstNode.getNextSibling();

    	    if (lexical.$isTextNode(nextSibling)) {
    	      // we basically make the second node the firstNode, changing offsets accordingly
    	      anchorOffset = 0;
    	      startOffset = 0;
    	      firstNode = nextSibling;
    	    }
    	  } // This is the case where we only selected a single node


    	  if (firstNode.is(lastNode)) {
    	    if (lexical.$isTextNode(firstNode)) {
    	      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
    	      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.

    	      if (startOffset === endOffset) {
    	        return;
    	      } // The entire node is selected, so just format it


    	      if (startOffset === 0 && endOffset === firstNodeTextLength) {
    	        $patchNodeStyle(firstNode, patch);
    	        firstNode.select(startOffset, endOffset);
    	      } else {
    	        // The node is partially selected, so split it into two nodes
    	        // and style the selected one.
    	        const splitNodes = firstNode.splitText(startOffset, endOffset);
    	        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
    	        $patchNodeStyle(replacement, patch);
    	        replacement.select(0, endOffset - startOffset);
    	      }
    	    } // multiple nodes selected.

    	  } else {
    	    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {
    	      if (startOffset !== 0) {
    	        // the entire first node isn't selected, so split it
    	        firstNode = firstNode.splitText(startOffset)[1];
    	        startOffset = 0;
    	      }

    	      $patchNodeStyle(firstNode, patch);
    	    }

    	    if (lexical.$isTextNode(lastNode)) {
    	      const lastNodeText = lastNode.getTextContent();
    	      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node
    	      //
    	      // If not, assume the last node is fully-selected unless the end offset is
    	      // zero.

    	      if (lastNode.__key !== endKey && endOffset !== 0) {
    	        endOffset = lastNodeTextLength;
    	      } // if the entire last node isn't selected, split it


    	      if (endOffset !== lastNodeTextLength) {
    	        [lastNode] = lastNode.splitText(endOffset);
    	      }

    	      if (endOffset !== 0) {
    	        $patchNodeStyle(lastNode, patch);
    	      }
    	    } // style all the text nodes in between


    	    for (let i = 1; i < lastIndex; i++) {
    	      const selectedNode = selectedNodes[i];
    	      const selectedNodeKey = selectedNode.getKey();

    	      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
    	        $patchNodeStyle(selectedNode, patch);
    	      }
    	    }
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	/**
    	 * Converts all nodes in the selection that are of one block type to another specified by parameter
    	 *
    	 * @param selection
    	 * @param createElement
    	 * @returns
    	 */

    	function $setBlocksType_experimental(selection, createElement) {
    	  if (selection.anchor.key === 'root') {
    	    const element = createElement();
    	    const root = lexical.$getRoot();
    	    const firstChild = root.getFirstChild();
    	    if (firstChild) firstChild.replace(element, true);else root.append(element);
    	    return;
    	  }

    	  const nodes = selection.getNodes();

    	  if (selection.anchor.type === 'text') {
    	    let firstBlock = selection.anchor.getNode().getParent();
    	    firstBlock = firstBlock.isInline() ? firstBlock.getParent() : firstBlock;
    	    if (nodes.indexOf(firstBlock) === -1) nodes.push(firstBlock);
    	  }

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];
    	    if (!isBlock(node)) continue;
    	    const targetElement = createElement();
    	    targetElement.setFormat(node.getFormatType());
    	    targetElement.setIndent(node.getIndent());
    	    node.replace(targetElement, true);
    	  }
    	}

    	function isBlock(node) {
    	  return lexical.$isElementNode(node) && !lexical.$isRootOrShadowRoot(node) && !node.isInline();
    	}

    	function isPointAttached(point) {
    	  return point.getNode().isAttached();
    	}

    	function $removeParentEmptyElements(startingNode) {
    	  let node = startingNode;

    	  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {
    	    const latest = node.getLatest();
    	    const parentNode = node.getParent();

    	    if (latest.getChildrenSize() === 0) {
    	      node.remove(true);
    	    }

    	    node = parentNode;
    	  }
    	}

    	function $wrapNodes(selection, createElement, wrappingElement = null) {
    	  const nodes = selection.getNodes();
    	  const nodesLength = nodes.length;
    	  const anchor = selection.anchor;

    	  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {
    	    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();
    	    const children = target.getChildren();
    	    let element = createElement();
    	    element.setFormat(target.getFormatType());
    	    element.setIndent(target.getIndent());
    	    children.forEach(child => element.append(child));

    	    if (wrappingElement) {
    	      element = wrappingElement.append(element);
    	    }

    	    target.replace(element);
    	    return;
    	  }

    	  let topLevelNode = null;
    	  let descendants = [];

    	  for (let i = 0; i < nodesLength; i++) {
    	    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the
    	    // user selected multiple Root-like nodes that have to be treated separately as if they are
    	    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each
    	    // of each of the cell nodes.

    	    if (lexical.$isRootOrShadowRoot(node)) {
    	      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
    	      descendants = [];
    	      topLevelNode = node;
    	    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {
    	      descendants.push(node);
    	    } else {
    	      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
    	      descendants = [node];
    	    }
    	  }

    	  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
    	}
    	function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
    	  if (nodes.length === 0) {
    	    return;
    	  }

    	  const firstNode = nodes[0];
    	  const elementMapping = new Map();
    	  const elements = []; // The below logic is to find the right target for us to
    	  // either insertAfter/insertBefore/append the corresponding
    	  // elements to. This is made more complicated due to nested
    	  // structures.

    	  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();

    	  if (target.isInline()) {
    	    target = target.getParentOrThrow();
    	  }

    	  let targetIsPrevSibling = false;

    	  while (target !== null) {
    	    const prevSibling = target.getPreviousSibling();

    	    if (prevSibling !== null) {
    	      target = prevSibling;
    	      targetIsPrevSibling = true;
    	      break;
    	    }

    	    target = target.getParentOrThrow();

    	    if (lexical.$isRootOrShadowRoot(target)) {
    	      break;
    	    }
    	  }

    	  const emptyElements = new Set(); // Find any top level empty elements

    	  for (let i = 0; i < nodesLength; i++) {
    	    const node = nodes[i];

    	    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {
    	      emptyElements.add(node.getKey());
    	    }
    	  }

    	  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.
    	  // If we find a top level empty element, also move make
    	  // an element for that.

    	  for (let i = 0; i < nodesLength; i++) {
    	    const node = nodes[i];
    	    let parent = node.getParent();

    	    if (parent !== null && parent.isInline()) {
    	      parent = parent.getParent();
    	    }

    	    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {
    	      const parentKey = parent.getKey();

    	      if (elementMapping.get(parentKey) === undefined) {
    	        const targetElement = createElement();
    	        targetElement.setFormat(parent.getFormatType());
    	        targetElement.setIndent(parent.getIndent());
    	        elements.push(targetElement);
    	        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new
    	        // element.

    	        parent.getChildren().forEach(child => {
    	          targetElement.append(child);
    	          movedNodes.add(child.getKey());

    	          if (lexical.$isElementNode(child)) {
    	            // Skip nested leaf nodes if the parent has already been moved
    	            child.getChildrenKeys().forEach(key => movedNodes.add(key));
    	          }
    	        });
    	        $removeParentEmptyElements(parent);
    	      }
    	    } else if (emptyElements.has(node.getKey())) {
    	      const targetElement = createElement();
    	      targetElement.setFormat(node.getFormatType());
    	      targetElement.setIndent(node.getIndent());
    	      elements.push(targetElement);
    	      node.remove(true);
    	    }
    	  }

    	  if (wrappingElement !== null) {
    	    for (let i = 0; i < elements.length; i++) {
    	      const element = elements[i];
    	      wrappingElement.append(element);
    	    }
    	  }

    	  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust
    	  // so that the target is the first child instead.

    	  if (lexical.$isRootOrShadowRoot(target)) {
    	    if (targetIsPrevSibling) {
    	      if (wrappingElement !== null) {
    	        target.insertAfter(wrappingElement);
    	      } else {
    	        for (let i = elements.length - 1; i >= 0; i--) {
    	          const element = elements[i];
    	          target.insertAfter(element);
    	        }
    	      }
    	    } else {
    	      const firstChild = target.getFirstChild();

    	      if (lexical.$isElementNode(firstChild)) {
    	        target = firstChild;
    	      }

    	      if (firstChild === null) {
    	        if (wrappingElement) {
    	          target.append(wrappingElement);
    	        } else {
    	          for (let i = 0; i < elements.length; i++) {
    	            const element = elements[i];
    	            target.append(element);
    	            lastElement = element;
    	          }
    	        }
    	      } else {
    	        if (wrappingElement !== null) {
    	          firstChild.insertBefore(wrappingElement);
    	        } else {
    	          for (let i = 0; i < elements.length; i++) {
    	            const element = elements[i];
    	            firstChild.insertBefore(element);
    	            lastElement = element;
    	          }
    	        }
    	      }
    	    }
    	  } else {
    	    if (wrappingElement) {
    	      target.insertAfter(wrappingElement);
    	    } else {
    	      for (let i = elements.length - 1; i >= 0; i--) {
    	        const element = elements[i];
    	        target.insertAfter(element);
    	        lastElement = element;
    	      }
    	    }
    	  }

    	  const prevSelection = lexical.$getPreviousSelection();

    	  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
    	    lexical.$setSelection(prevSelection.clone());
    	  } else if (lastElement !== null) {
    	    lastElement.selectEnd();
    	  } else {
    	    selection.dirty = true;
    	  }
    	}
    	function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
    	  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);
    	  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
    	}
    	function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
    	  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);
    	}
    	function $isParentElementRTL(selection) {
    	  const anchorNode = selection.anchor.getNode();
    	  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
    	  return parent.getDirection() === 'rtl';
    	}
    	function $moveCharacter(selection, isHoldingShift, isBackward) {
    	  const isRTL = $isParentElementRTL(selection);
    	  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');
    	}
    	function $selectAll(selection) {
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const anchorNode = anchor.getNode();
    	  const topParent = anchorNode.getTopLevelElementOrThrow();
    	  const root = topParent.getParentOrThrow();
    	  let firstNode = root.getFirstDescendant();
    	  let lastNode = root.getLastDescendant();
    	  let firstType = 'element';
    	  let lastType = 'element';
    	  let lastOffset = 0;

    	  if (lexical.$isTextNode(firstNode)) {
    	    firstType = 'text';
    	  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {
    	    firstNode = firstNode.getParentOrThrow();
    	  }

    	  if (lexical.$isTextNode(lastNode)) {
    	    lastType = 'text';
    	    lastOffset = lastNode.getTextContentSize();
    	  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {
    	    lastNode = lastNode.getParentOrThrow();
    	  }

    	  if (firstNode && lastNode) {
    	    anchor.set(firstNode.getKey(), 0, firstType);
    	    focus.set(lastNode.getKey(), lastOffset, lastType);
    	  }
    	}

    	function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
    	  const css = node.getStyle();
    	  const styleObject = getStyleObjectFromCSS(css);

    	  if (styleObject !== null) {
    	    return styleObject[styleProperty] || defaultValue;
    	  }

    	  return defaultValue;
    	}

    	function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {
    	  let styleValue = null;
    	  const nodes = selection.getNodes();
    	  const anchor = selection.anchor;
    	  const focus = selection.focus;
    	  const isBackward = selection.isBackward();
    	  const endOffset = isBackward ? focus.offset : anchor.offset;
    	  const endNode = isBackward ? focus.getNode() : anchor.getNode();

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i]; // if no actual characters in the end node are selected, we don't
    	    // include it in the selection for purposes of determining style
    	    // value

    	    if (i !== 0 && endOffset === 0 && node.is(endNode)) {
    	      continue;
    	    }

    	    if (lexical.$isTextNode(node)) {
    	      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);

    	      if (styleValue === null) {
    	        styleValue = nodeStyleValue;
    	      } else if (styleValue !== nodeStyleValue) {
    	        // multiple text nodes are in the selection and they don't all
    	        // have the same font size.
    	        styleValue = '';
    	        break;
    	      }
    	    }
    	  }

    	  return styleValue === null ? defaultValue : styleValue;
    	}

    	LexicalSelection_dev.$addNodeStyle = $addNodeStyle;
    	LexicalSelection_dev.$cloneWithProperties = $cloneWithProperties;
    	LexicalSelection_dev.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;
    	LexicalSelection_dev.$isAtNodeEnd = $isAtNodeEnd;
    	LexicalSelection_dev.$isParentElementRTL = $isParentElementRTL;
    	LexicalSelection_dev.$moveCaretSelection = $moveCaretSelection;
    	LexicalSelection_dev.$moveCharacter = $moveCharacter;
    	LexicalSelection_dev.$patchStyleText = $patchStyleText;
    	LexicalSelection_dev.$selectAll = $selectAll;
    	LexicalSelection_dev.$setBlocksType_experimental = $setBlocksType_experimental;
    	LexicalSelection_dev.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;
    	LexicalSelection_dev.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;
    	LexicalSelection_dev.$wrapNodes = $wrapNodes;
    	LexicalSelection_dev.createDOMRange = createDOMRange;
    	LexicalSelection_dev.createRectsFromDOMRange = createRectsFromDOMRange;
    	LexicalSelection_dev.getStyleObjectFromCSS = getStyleObjectFromCSS;
    	LexicalSelection_dev.trimTextContentFromAnchor = trimTextContentFromAnchor;
    	return LexicalSelection_dev;
    }

    var LexicalSelection_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalSelection_prod;

    function requireLexicalSelection_prod () {
    	if (hasRequiredLexicalSelection_prod) return LexicalSelection_prod;
    	hasRequiredLexicalSelection_prod = 1;
    var l=Lexical_1;let u=new Map;function v(a){for(;null!=a;){if(a.nodeType===Node.TEXT_NODE)return a;a=a.firstChild;}return null}function x(a){let b=a.parentNode;if(null==b)throw Error("Should never happen");return [b,Array.from(b.childNodes).indexOf(a)]}function y(a){let b={};a=a.split(";");for(let c of a)if(""!==c){let [f,d]=c.split(/:([^]+)/);b[f.trim()]=d.trim();}return b}function z(a){let b=u.get(a);void 0===b&&(b=y(a),u.set(a,b));return b}
    	function A(a){let b="";for(let c in a)c&&(b+=`${c}: ${a[c]};`);return b}function B(a,b){var c=z(a.getStyle());b=Object.entries(b).reduce((f,[d,e])=>{null===e?delete f[d]:f[d]=e;return f},{...c});c=A(b);a.setStyle(c);u.set(c,b);}function C(a){for(;null!==a&&!l.$isRootOrShadowRoot(a);){let b=a.getLatest(),c=a.getParent();0===b.getChildrenSize()&&a.remove(!0);a=c;}}
    	function D(a,b,c,f,d=null){if(0!==b.length){var e=b[0],k=new Map,g=[];e=l.$isElementNode(e)?e:e.getParentOrThrow();e.isInline()&&(e=e.getParentOrThrow());for(var h=!1;null!==e;){var p=e.getPreviousSibling();if(null!==p){e=p;h=!0;break}e=e.getParentOrThrow();if(l.$isRootOrShadowRoot(e))break}p=new Set;for(var q=0;q<c;q++){var m=b[q];l.$isElementNode(m)&&0===m.getChildrenSize()&&p.add(m.getKey());}var n=new Set;for(q=0;q<c;q++){m=b[q];var r=m.getParent();null!==r&&r.isInline()&&(r=r.getParent());if(null!==
    	r&&l.$isLeafNode(m)&&!n.has(m.getKey())){if(m=r.getKey(),void 0===k.get(m)){let t=f();t.setFormat(r.getFormatType());t.setIndent(r.getIndent());g.push(t);k.set(m,t);r.getChildren().forEach(w=>{t.append(w);n.add(w.getKey());l.$isElementNode(w)&&w.getChildrenKeys().forEach(G=>n.add(G));});C(r);}}else p.has(m.getKey())&&(r=f(),r.setFormat(m.getFormatType()),r.setIndent(m.getIndent()),g.push(r),m.remove(!0));}if(null!==d)for(b=0;b<g.length;b++)d.append(g[b]);b=null;if(l.$isRootOrShadowRoot(e))if(h)if(null!==
    	d)e.insertAfter(d);else for(d=g.length-1;0<=d;d--)e.insertAfter(g[d]);else if(h=e.getFirstChild(),l.$isElementNode(h)&&(e=h),null===h)if(d)e.append(d);else for(d=0;d<g.length;d++)h=g[d],e.append(h),b=h;else if(null!==d)h.insertBefore(d);else for(e=0;e<g.length;e++)d=g[e],h.insertBefore(d),b=d;else if(d)e.insertAfter(d);else for(d=g.length-1;0<=d;d--)h=g[d],e.insertAfter(h),b=h;g=l.$getPreviousSelection();l.$isRangeSelection(g)&&g.anchor.getNode().isAttached()&&g.focus.getNode().isAttached()?l.$setSelection(g.clone()):
    	null!==b?b.selectEnd():a.dirty=!0;}}function E(a,b,c,f){a.modify(b?"extend":"move",c,f);}function F(a){a=a.anchor.getNode();return "rtl"===(l.$isRootNode(a)?a:a.getParentOrThrow()).getDirection()}LexicalSelection_prod.$addNodeStyle=function(a){a=a.getStyle();let b=y(a);u.set(a,b);};
    	LexicalSelection_prod.$cloneWithProperties=function(a){a=a.getLatest();let b=a.constructor.clone(a);b.__parent=a.__parent;b.__next=a.__next;b.__prev=a.__prev;if(l.$isElementNode(a)&&l.$isElementNode(b))return b.__first=a.__first,b.__last=a.__last,b.__size=a.__size,b.__format=a.__format,b.__indent=a.__indent,b.__dir=a.__dir,b;l.$isTextNode(a)&&l.$isTextNode(b)&&(b.__format=a.__format,b.__style=a.__style,b.__mode=a.__mode,b.__detail=a.__detail);return b};
    	LexicalSelection_prod.$getSelectionStyleValueForProperty=function(a,b,c=""){let f=null,d=a.getNodes();var e=a.anchor,k=a.focus,g=a.isBackward();a=g?k.offset:e.offset;e=g?k.getNode():e.getNode();for(k=0;k<d.length;k++){var h=d[k];if((0===k||0!==a||!h.is(e))&&l.$isTextNode(h)){g=b;var p=c;h=h.getStyle();h=z(h);g=null!==h?h[g]||p:p;if(null===f)f=g;else if(f!==g){f="";break}}}return null===f?c:f};LexicalSelection_prod.$isAtNodeEnd=function(a){return "text"===a.type?a.offset===a.getNode().getTextContentSize():a.offset===a.getNode().getChildrenSize()};
    	LexicalSelection_prod.$isParentElementRTL=F;LexicalSelection_prod.$moveCaretSelection=E;LexicalSelection_prod.$moveCharacter=function(a,b,c){let f=F(a);E(a,b,c?!f:f,"character");};
    	LexicalSelection_prod.$patchStyleText=function(a,b){var c=a.getNodes();let f=c.length-1,d=c[0],e=c[f];if(!a.isCollapsed()){var k=a.anchor,g=a.focus,h=d.getTextContent().length,p=g.offset,q=k.offset,m=k.isBefore(g),n=m?q:p;a=m?p:q;var r=m?k.type:g.type,t=m?g.type:k.type;k=m?g.key:k.key;l.$isTextNode(d)&&n===h&&(g=d.getNextSibling(),l.$isTextNode(g)&&(n=q=0,d=g));if(d.is(e))l.$isTextNode(d)&&(n="element"===r?0:q>p?p:q,a="element"===t?h:q>p?q:p,n!==a&&(0===n&&a===h?(B(d,b),d.select(n,a)):(c=d.splitText(n,a),c=0===
    	n?c[0]:c[1],B(c,b),c.select(0,a-n))));else for(l.$isTextNode(d)&&n<d.getTextContentSize()&&(0!==n&&(d=d.splitText(n)[1]),B(d,b)),l.$isTextNode(e)&&(n=e.getTextContent().length,e.__key!==k&&0!==a&&(a=n),a!==n&&([e]=e.splitText(a)),0!==a&&B(e,b)),a=1;a<f;a++)n=c[a],h=n.getKey(),l.$isTextNode(n)&&h!==d.getKey()&&h!==e.getKey()&&!n.isToken()&&B(n,b);}};
    	LexicalSelection_prod.$selectAll=function(a){let b=a.anchor;a=a.focus;var c=b.getNode().getTopLevelElementOrThrow().getParentOrThrow();let f=c.getFirstDescendant();c=c.getLastDescendant();let d="element",e="element",k=0;l.$isTextNode(f)?d="text":l.$isElementNode(f)||null===f||(f=f.getParentOrThrow());l.$isTextNode(c)?(e="text",k=c.getTextContentSize()):l.$isElementNode(c)||null===c||(c=c.getParentOrThrow());f&&c&&(b.set(f.getKey(),0,d),a.set(c.getKey(),k,e));};
    	LexicalSelection_prod.$setBlocksType_experimental=function(a,b){if("root"===a.anchor.key){b=b();var c=l.$getRoot();(a=c.getFirstChild())?a.replace(b,!0):c.append(b);}else for(c=a.getNodes(),"text"===a.anchor.type&&(a=a.anchor.getNode().getParent(),a=a.isInline()?a.getParent():a,-1===c.indexOf(a)&&c.push(a)),a=0;a<c.length;a++){let d=c[a];var f=d;!l.$isElementNode(f)||l.$isRootOrShadowRoot(f)||f.isInline()||(f=b(),f.setFormat(d.getFormatType()),f.setIndent(d.getIndent()),d.replace(f,!0));}};
    	LexicalSelection_prod.$shouldOverrideDefaultCharacterSelection=function(a,b){a=l.$getAdjacentNode(a.focus,b);return l.$isDecoratorNode(a)&&!a.isIsolated()||l.$isElementNode(a)&&!a.isInline()&&!a.canBeEmpty()};
    	LexicalSelection_prod.$sliceSelectedTextNodeContent=function(a,b){if(b.isSelected()&&!b.isSegmented()&&!b.isToken()&&(l.$isRangeSelection(a)||l.DEPRECATED_$isGridSelection(a))){var c=a.anchor.getNode(),f=a.focus.getNode(),d=b.is(c),e=b.is(f);if(d||e){d=a.isBackward();let [k,g]=a.getCharacterOffsets();a=c.is(f);e=b.is(d?f:c);f=b.is(d?c:f);c=0;let h=void 0;a?(c=k>g?g:k,h=k>g?k:g):e?(c=d?g:k,h=void 0):f&&(d=d?k:g,c=0,h=d);b.__text=b.__text.slice(c,h);}}return b};
    	LexicalSelection_prod.$wrapNodes=function(a,b,c=null){var f=a.getNodes();let d=f.length;var e=a.anchor;if(0===d||1===d&&"element"===e.type&&0===e.getNode().getChildrenSize()){a="text"===e.type?e.getNode().getParentOrThrow():e.getNode();f=a.getChildren();let g=b();g.setFormat(a.getFormatType());g.setIndent(a.getIndent());f.forEach(h=>g.append(h));c&&(g=c.append(g));a.replace(g);}else {e=null;var k=[];for(let g=0;g<d;g++){let h=f[g];l.$isRootOrShadowRoot(h)?(D(a,k,k.length,b,c),k=[],e=h):null===e||null!==e&&l.$hasAncestor(h,
    	e)?k.push(h):(D(a,k,k.length,b,c),k=[h]);}D(a,k,k.length,b,c);}};
    	LexicalSelection_prod.createDOMRange=function(a,b,c,f,d){let e=b.getKey(),k=f.getKey(),g=document.createRange(),h=a.getElementByKey(e);a=a.getElementByKey(k);l.$isTextNode(b)&&(h=v(h));l.$isTextNode(f)&&(a=v(a));if(void 0===b||void 0===f||null===h||null===a)return null;"BR"===h.nodeName&&([h,c]=x(h));"BR"===a.nodeName&&([a,d]=x(a));b=h.firstChild;h===a&&null!=b&&"BR"===b.nodeName&&0===c&&0===d&&(d=1);try{g.setStart(h,c),g.setEnd(a,d);}catch(p){return null}!g.collapsed||c===d&&e===k||(g.setStart(a,d),g.setEnd(h,
    	c));return g};LexicalSelection_prod.createRectsFromDOMRange=function(a,b){var c=a.getRootElement();if(null===c)return [];a=c.getBoundingClientRect();c=getComputedStyle(c);c=parseFloat(c.paddingLeft)+parseFloat(c.paddingRight);b=Array.from(b.getClientRects());let f=b.length,d;for(let e=0;e<f;e++){let k=b[e],g=k.width+c===a.width;d&&d.top===k.top&&d.left===k.left&&d.width===k.width&&d.height===k.height||g?(b.splice(e--,1),f--):d=k;}return b};LexicalSelection_prod.getStyleObjectFromCSS=z;
    	LexicalSelection_prod.trimTextContentFromAnchor=function(a,b,c){let f=b.getNode();if(l.$isElementNode(f)){var d=f.getDescendantByIndex(b.offset);null!==d&&(f=d);}for(;0<c&&null!==f;){var e=f.getPreviousSibling(),k=0;if(null===e){d=f.getParentOrThrow();for(var g=d.getPreviousSibling();null===g;){d=d.getParent();if(null===d){e=null;break}g=d.getPreviousSibling();}null!==d&&(k=d.isInline()?0:2,e=l.$isElementNode(g)?g.getLastDescendant():g);}let h=f.getTextContent();""===h&&l.$isElementNode(f)&&!f.isInline()&&(h="\n\n");
    	d=h.length;g=d-c;let p=h.slice(0,g);if(!l.$isTextNode(f)||c>=d)g=f.getParent(),f.remove(),null!=g&&0===g.getChildrenSize()&&g.remove(),c-=d+k,f=e;else {let q=f.getKey();e=a.getEditorState().read(()=>{const m=l.$getNodeByKey(q);return l.$isTextNode(m)&&m.isSimpleText()?m.getTextContent():null});null!==e&&e!==h?(c=l.$getPreviousSelection(),d=f,f.isSimpleText()?f.setTextContent(e):(d=l.$createTextNode(e),f.replace(d)),l.$isRangeSelection(c)&&c.isCollapsed()&&(c=c.anchor.offset,d.select(c,c))):f.isSimpleText()?
    	(e=b.key===q,k=b.offset,k<c&&(k=d),c=e?k-c:0,d=e?k:g,e&&0===c?([c]=f.splitText(c,d),c.remove()):([,c]=f.splitText(c,d),c.remove())):(c=l.$createTextNode(p),f.replace(c));c=0;}}};
    	return LexicalSelection_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var LexicalSelection_1;
    var hasRequiredLexicalSelection;

    function requireLexicalSelection () {
    	if (hasRequiredLexicalSelection) return LexicalSelection_1;
    	hasRequiredLexicalSelection = 1;
    	const LexicalSelection = process.env.NODE_ENV === 'development' ? requireLexicalSelection_dev() : requireLexicalSelection_prod();
    	LexicalSelection_1 = LexicalSelection;
    	return LexicalSelection_1;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalHtml_dev;

    function requireLexicalHtml_dev () {
    	if (hasRequiredLexicalHtml_dev) return LexicalHtml_dev;
    	hasRequiredLexicalHtml_dev = 1;

    	var selection = requireLexicalSelection();
    	var lexical = Lexical_1;

    	/** @module @lexical/html */
    	/**
    	 * How you parse your html string to get a document is left up to you. In the browser you can use the native
    	 * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom
    	 * or an equivilant library and pass in the document here.
    	 */

    	function $generateNodesFromDOM(editor, dom) {
    	  let lexicalNodes = [];
    	  const elements = dom.body ? Array.from(dom.body.childNodes) : [];
    	  const elementsLength = elements.length;

    	  for (let i = 0; i < elementsLength; i++) {
    	    const element = elements[i];

    	    if (!IGNORE_TAGS.has(element.nodeName)) {
    	      const lexicalNode = $createNodesFromDOM(element, editor);

    	      if (lexicalNode !== null) {
    	        lexicalNodes = lexicalNodes.concat(lexicalNode);
    	      }
    	    }
    	  }

    	  return lexicalNodes;
    	}
    	function $generateHtmlFromNodes(editor, selection) {
    	  if (typeof document === 'undefined' || typeof window === 'undefined') {
    	    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');
    	  }

    	  const container = document.createElement('div');
    	  const root = lexical.$getRoot();
    	  const topLevelChildren = root.getChildren();

    	  for (let i = 0; i < topLevelChildren.length; i++) {
    	    const topLevelNode = topLevelChildren[i];
    	    $appendNodesToHTML(editor, topLevelNode, container, selection);
    	  }

    	  return container.innerHTML;
    	}

    	function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
    	  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;
    	  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');
    	  let target = currentNode;

    	  if (selection$1 !== null) {
    	    let clone = selection.$cloneWithProperties(currentNode);
    	    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
    	    target = clone;
    	  }

    	  const children = lexical.$isElementNode(target) ? target.getChildren() : [];
    	  const {
    	    element,
    	    after
    	  } = target.exportDOM(editor);

    	  if (!element) {
    	    return false;
    	  }

    	  const fragment = new DocumentFragment();

    	  for (let i = 0; i < children.length; i++) {
    	    const childNode = children[i];
    	    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);

    	    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {
    	      shouldInclude = true;
    	    }
    	  }

    	  if (shouldInclude && !shouldExclude) {
    	    element.append(fragment);
    	    parentElement.append(element);

    	    if (after) {
    	      const newElement = after.call(target, element);
    	      if (newElement) element.replaceWith(newElement);
    	    }
    	  } else {
    	    parentElement.append(fragment);
    	  }

    	  return shouldInclude;
    	}

    	function getConversionFunction(domNode, editor) {
    	  const {
    	    nodeName
    	  } = domNode;

    	  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());

    	  let currentConversion = null;

    	  if (cachedConversions !== undefined) {
    	    for (const cachedConversion of cachedConversions) {
    	      const domConversion = cachedConversion(domNode);

    	      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {
    	        currentConversion = domConversion;
    	      }
    	    }
    	  }

    	  return currentConversion !== null ? currentConversion.conversion : null;
    	}

    	const IGNORE_TAGS = new Set(['STYLE']);

    	function $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {
    	  let lexicalNodes = [];

    	  if (IGNORE_TAGS.has(node.nodeName)) {
    	    return lexicalNodes;
    	  }

    	  let currentLexicalNode = null;
    	  const transformFunction = getConversionFunction(node, editor);
    	  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;
    	  let postTransform = null;

    	  if (transformOutput !== null) {
    	    postTransform = transformOutput.after;
    	    currentLexicalNode = transformOutput.node;

    	    if (currentLexicalNode !== null) {
    	      for (const [, forChildFunction] of forChildMap) {
    	        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);

    	        if (!currentLexicalNode) {
    	          break;
    	        }
    	      }

    	      if (currentLexicalNode) {
    	        lexicalNodes.push(currentLexicalNode);
    	      }
    	    }

    	    if (transformOutput.forChild != null) {
    	      forChildMap.set(node.nodeName, transformOutput.forChild);
    	    }
    	  } // If the DOM node doesn't have a transformer, we don't know what
    	  // to do with it but we still need to process any childNodes.


    	  const children = node.childNodes;
    	  let childLexicalNodes = [];

    	  for (let i = 0; i < children.length; i++) {
    	    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));
    	  }

    	  if (postTransform != null) {
    	    childLexicalNodes = postTransform(childLexicalNodes);
    	  }

    	  if (currentLexicalNode == null) {
    	    // If it hasn't been converted to a LexicalNode, we hoist its children
    	    // up to the same level as it.
    	    lexicalNodes = lexicalNodes.concat(childLexicalNodes);
    	  } else {
    	    if (lexical.$isElementNode(currentLexicalNode)) {
    	      // If the current node is a ElementNode after conversion,
    	      // we can append all the children to it.
    	      currentLexicalNode.append(...childLexicalNodes);
    	    }
    	  }

    	  return lexicalNodes;
    	}

    	LexicalHtml_dev.$generateHtmlFromNodes = $generateHtmlFromNodes;
    	LexicalHtml_dev.$generateNodesFromDOM = $generateNodesFromDOM;
    	return LexicalHtml_dev;
    }

    var LexicalHtml_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalHtml_prod;

    function requireLexicalHtml_prod () {
    	if (hasRequiredLexicalHtml_prod) return LexicalHtml_prod;
    	hasRequiredLexicalHtml_prod = 1;
    var n=requireLexicalSelection(),q=Lexical_1;
    	function r(c,d,h,b=null){let e=null!=b?d.isSelected():!0,l=q.$isElementNode(d)&&d.excludeFromCopy("html");var a=d;null!==b&&(a=n.$cloneWithProperties(d),a=q.$isTextNode(a)&&null!=b?n.$sliceSelectedTextNodeContent(b,a):a);let f=q.$isElementNode(a)?a.getChildren():[],{element:k,after:g}=a.exportDOM(c);if(!k)return !1;let m=new DocumentFragment;for(let p=0;p<f.length;p++){let t=f[p],w=r(c,t,m,b);!e&&q.$isElementNode(d)&&w&&d.extractWithChild(t,b,"html")&&(e=!0);}e&&!l?(k.append(m),h.append(k),g&&(c=g.call(a,
    	k))&&k.replaceWith(c)):h.append(m);return e}let u=new Set(["STYLE"]);
    	function v(c,d,h=new Map,b,e=!1){let l=[];if(u.has(c.nodeName))return l;let a=null;var {nodeName:f}=c,k=d._htmlConversions.get(f.toLowerCase());f=null;if(void 0!==k)for(g of k)k=g(c),null!==k&&(null===f||f.priority<k.priority)&&(f=k);var g=(g=null!==f?f.conversion:null)?g(c,void 0,e):null;f=null;if(null!==g){f=g.after;a=g.node;if(null!==a){for(var [,m]of h)if(a=m(a,b),!a)break;a&&l.push(a);}null!=g.forChild&&h.set(c.nodeName,g.forChild);}c=c.childNodes;b=[];for(m=0;m<c.length;m++)b.push(...v(c[m],d,
    	new Map(h),a,e||!0===(g&&g.preformatted)));null!=f&&(b=f(b));null==a?l=l.concat(b):q.$isElementNode(a)&&a.append(...b);return l}LexicalHtml_prod.$generateHtmlFromNodes=function(c,d){if("undefined"===typeof document||"undefined"===typeof window)throw Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");let h=document.createElement("div"),b=q.$getRoot().getChildren();for(let e=0;e<b.length;e++)r(c,b[e],h,d);return h.innerHTML};
    	LexicalHtml_prod.$generateNodesFromDOM=function(c,d){let h=[];d=d.body?Array.from(d.body.childNodes):[];let b=d.length;for(let l=0;l<b;l++){var e=d[l];u.has(e.nodeName)||(e=v(e,c),null!==e&&(h=h.concat(e)));}return h};
    	return LexicalHtml_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var LexicalHtml_1;
    var hasRequiredLexicalHtml;

    function requireLexicalHtml () {
    	if (hasRequiredLexicalHtml) return LexicalHtml_1;
    	hasRequiredLexicalHtml = 1;
    	const LexicalHtml = process.env.NODE_ENV === 'development' ? requireLexicalHtml_dev() : requireLexicalHtml_prod();
    	LexicalHtml_1 = LexicalHtml;
    	return LexicalHtml_1;
    }

    var LexicalList_dev = {};

    var LexicalUtils_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalUtils_dev;

    function requireLexicalUtils_dev () {
    	if (hasRequiredLexicalUtils_dev) return LexicalUtils_dev;
    	hasRequiredLexicalUtils_dev = 1;

    	var lexical = Lexical_1;

    	/** @module @lexical/utils */
    	function addClassNamesToElement(element, ...classNames) {
    	  classNames.forEach(className => {
    	    if (typeof className === 'string') {
    	      const classesToAdd = className.split(' ').filter(n => n !== '');
    	      element.classList.add(...classesToAdd);
    	    }
    	  });
    	}
    	function removeClassNamesFromElement(element, ...classNames) {
    	  classNames.forEach(className => {
    	    if (typeof className === 'string') {
    	      element.classList.remove(...className.split(' '));
    	    }
    	  });
    	}
    	function isMimeType(file, acceptableMimeTypes) {
    	  for (const acceptableType of acceptableMimeTypes) {
    	    if (file.type.startsWith(acceptableType)) {
    	      return true;
    	    }
    	  }

    	  return false;
    	}
    	/**
    	 * Lexical File Reader with:
    	 *  1. MIME type support
    	 *  2. batched results (HistoryPlugin compatibility)
    	 *  3. Order aware (respects the order when multiple Files are passed)
    	 *
    	 * const filesResult = await mediaFileReader(files, ['image/']);
    	 * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {
    	 *   src: file.result,
    	 * }));
    	 */

    	function mediaFileReader(files, acceptableMimeTypes) {
    	  const filesIterator = files[Symbol.iterator]();
    	  return new Promise((resolve, reject) => {
    	    const processed = [];

    	    const handleNextFile = () => {
    	      const {
    	        done,
    	        value: file
    	      } = filesIterator.next();

    	      if (done) {
    	        return resolve(processed);
    	      }

    	      const fileReader = new FileReader();
    	      fileReader.addEventListener('error', reject);
    	      fileReader.addEventListener('load', () => {
    	        const result = fileReader.result;

    	        if (typeof result === 'string') {
    	          processed.push({
    	            file,
    	            result
    	          });
    	        }

    	        handleNextFile();
    	      });

    	      if (isMimeType(file, acceptableMimeTypes)) {
    	        fileReader.readAsDataURL(file);
    	      } else {
    	        handleNextFile();
    	      }
    	    };

    	    handleNextFile();
    	  });
    	}
    	function $dfs(startingNode, endingNode) {
    	  const nodes = [];
    	  const start = (startingNode || lexical.$getRoot()).getLatest();
    	  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
    	  let node = start;
    	  let depth = $getDepth(node);

    	  while (node !== null && !node.is(end)) {
    	    nodes.push({
    	      depth,
    	      node
    	    });

    	    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
    	      node = node.getFirstChild();
    	      depth++;
    	    } else {
    	      // Find immediate sibling or nearest parent sibling
    	      let sibling = null;

    	      while (sibling === null && node !== null) {
    	        sibling = node.getNextSibling();

    	        if (sibling === null) {
    	          node = node.getParent();
    	          depth--;
    	        } else {
    	          node = sibling;
    	        }
    	      }
    	    }
    	  }

    	  if (node !== null && node.is(end)) {
    	    nodes.push({
    	      depth,
    	      node
    	    });
    	  }

    	  return nodes;
    	}

    	function $getDepth(node) {
    	  let innerNode = node;
    	  let depth = 0;

    	  while ((innerNode = innerNode.getParent()) !== null) {
    	    depth++;
    	  }

    	  return depth;
    	}

    	function $getNearestNodeOfType(node, klass) {
    	  let parent = node;

    	  while (parent != null) {
    	    if (parent instanceof klass) {
    	      return parent;
    	    }

    	    parent = parent.getParent();
    	  }

    	  return null;
    	}
    	function $getNearestBlockElementAncestorOrThrow(startNode) {
    	  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());

    	  if (!lexical.$isElementNode(blockNode)) {
    	    {
    	      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
    	    }
    	  }

    	  return blockNode;
    	}
    	function $findMatchingParent(startingNode, findFn) {
    	  let curr = startingNode;

    	  while (curr !== lexical.$getRoot() && curr != null) {
    	    if (findFn(curr)) {
    	      return curr;
    	    }

    	    curr = curr.getParent();
    	  }

    	  return null;
    	}
    	function mergeRegister(...func) {
    	  return () => {
    	    func.forEach(f => f());
    	  };
    	}
    	function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
    	  const $isTargetNode = node => {
    	    return node instanceof targetNode;
    	  };

    	  const $findMatch = node => {
    	    // First validate we don't have any children that are of the target,
    	    // as we need to handle them first.
    	    const children = node.getChildren();

    	    for (let i = 0; i < children.length; i++) {
    	      const child = children[i];

    	      if ($isTargetNode(child)) {
    	        return null;
    	      }
    	    }

    	    let parentNode = node;
    	    let childNode = node;

    	    while (parentNode !== null) {
    	      childNode = parentNode;
    	      parentNode = parentNode.getParent();

    	      if ($isTargetNode(parentNode)) {
    	        return {
    	          child: childNode,
    	          parent: parentNode
    	        };
    	      }
    	    }

    	    return null;
    	  };

    	  const elementNodeTransform = node => {
    	    const match = $findMatch(node);

    	    if (match !== null) {
    	      const {
    	        child,
    	        parent
    	      } = match; // Simple path, we can move child out and siblings into a new parent.

    	      if (child.is(node)) {
    	        handleOverlap(parent, node);
    	        const nextSiblings = child.getNextSiblings();
    	        const nextSiblingsLength = nextSiblings.length;
    	        parent.insertAfter(child);

    	        if (nextSiblingsLength !== 0) {
    	          const newParent = cloneNode(parent);
    	          child.insertAfter(newParent);

    	          for (let i = 0; i < nextSiblingsLength; i++) {
    	            newParent.append(nextSiblings[i]);
    	          }
    	        }

    	        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
    	          parent.remove();
    	        }
    	      }
    	    }
    	  };

    	  return editor.registerNodeTransform(targetNode, elementNodeTransform);
    	}
    	function $restoreEditorState(editor, editorState) {
    	  const FULL_RECONCILE = 2;
    	  const nodeMap = new Map(editorState._nodeMap);
    	  const activeEditorState = editor._pendingEditorState;

    	  if (activeEditorState) {
    	    activeEditorState._nodeMap = nodeMap;
    	  }

    	  editor._dirtyType = FULL_RECONCILE;
    	  const selection = editorState._selection;
    	  lexical.$setSelection(selection === null ? null : selection.clone());
    	}
    	function $insertNodeToNearestRoot(node) {
    	  const selection = lexical.$getSelection();

    	  if (lexical.$isRangeSelection(selection)) {
    	    const {
    	      focus
    	    } = selection;
    	    const focusNode = focus.getNode();
    	    const focusOffset = focus.offset;

    	    if (lexical.$isRootOrShadowRoot(focusNode)) {
    	      const focusChild = focusNode.getChildAtIndex(focusOffset);

    	      if (focusChild == null) {
    	        focusNode.append(node);
    	      } else {
    	        focusChild.insertBefore(node);
    	      }

    	      node.selectNext();
    	    } else {
    	      let splitNode;
    	      let splitOffset;

    	      if (lexical.$isTextNode(focusNode)) {
    	        splitNode = focusNode.getParentOrThrow();
    	        splitOffset = focusNode.getIndexWithinParent();

    	        if (focusOffset > 0) {
    	          splitOffset += 1;
    	          focusNode.splitText(focusOffset);
    	        }
    	      } else {
    	        splitNode = focusNode;
    	        splitOffset = focusOffset;
    	      }

    	      const [, rightTree] = $splitNode(splitNode, splitOffset);
    	      rightTree.insertBefore(node);
    	      rightTree.selectStart();
    	    }
    	  } else {
    	    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
    	      const nodes = selection.getNodes();
    	      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
    	    } else {
    	      const root = lexical.$getRoot();
    	      root.append(node);
    	    }

    	    const paragraphNode = lexical.$createParagraphNode();
    	    node.insertAfter(paragraphNode);
    	    paragraphNode.select();
    	  }

    	  return node.getLatest();
    	}
    	function $wrapNodeInElement(node, createElementNode) {
    	  const elementNode = createElementNode();
    	  node.replace(elementNode);
    	  elementNode.append(node);
    	  return elementNode;
    	}
    	function $splitNode(node, offset) {
    	  let startNode = node.getChildAtIndex(offset);

    	  if (startNode == null) {
    	    startNode = node;
    	  }

    	  if (!!lexical.$isRootOrShadowRoot(node)) {
    	    throw Error(`Can not call $splitNode() on root element`);
    	  }

    	  const recurse = currentNode => {
    	    const parent = currentNode.getParentOrThrow();
    	    const isParentRoot = lexical.$isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive
    	    // parents are copied to create separate tree

    	    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : lexical.$copyNode(currentNode);

    	    if (isParentRoot) {
    	      currentNode.insertAfter(nodeToMove);
    	      return [currentNode, nodeToMove, nodeToMove];
    	    } else {
    	      const [leftTree, rightTree, newParent] = recurse(parent);
    	      const nextSiblings = currentNode.getNextSiblings();
    	      newParent.append(nodeToMove, ...nextSiblings);
    	      return [leftTree, rightTree, nodeToMove];
    	    }
    	  };

    	  const [leftTree, rightTree] = recurse(startNode);
    	  return [leftTree, rightTree];
    	}

    	LexicalUtils_dev.$dfs = $dfs;
    	LexicalUtils_dev.$findMatchingParent = $findMatchingParent;
    	LexicalUtils_dev.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    	LexicalUtils_dev.$getNearestNodeOfType = $getNearestNodeOfType;
    	LexicalUtils_dev.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
    	LexicalUtils_dev.$restoreEditorState = $restoreEditorState;
    	LexicalUtils_dev.$splitNode = $splitNode;
    	LexicalUtils_dev.$wrapNodeInElement = $wrapNodeInElement;
    	LexicalUtils_dev.addClassNamesToElement = addClassNamesToElement;
    	LexicalUtils_dev.isMimeType = isMimeType;
    	LexicalUtils_dev.mediaFileReader = mediaFileReader;
    	LexicalUtils_dev.mergeRegister = mergeRegister;
    	LexicalUtils_dev.registerNestedElementResolver = registerNestedElementResolver;
    	LexicalUtils_dev.removeClassNamesFromElement = removeClassNamesFromElement;
    	return LexicalUtils_dev;
    }

    var LexicalUtils_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalUtils_prod;

    function requireLexicalUtils_prod () {
    	if (hasRequiredLexicalUtils_prod) return LexicalUtils_prod;
    	hasRequiredLexicalUtils_prod = 1;
    var h=Lexical_1;function p(a){throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or `+"use the non-minified dev environment for full errors and additional helpful warnings.");}function q(a,b){for(let c of b)if(a.type.startsWith(c))return !0;return !1}function r(a,b){for(;a!==h.$getRoot()&&null!=a;){if(b(a))return a;a=a.getParent();}return null}
    	function t(a,b){let c=a.getChildAtIndex(b);null==c&&(c=a);h.$isRootOrShadowRoot(a)&&p(102);let e=f=>{const m=f.getParentOrThrow(),l=h.$isRootOrShadowRoot(m),k=f!==c||l?h.$copyNode(f):f;if(l)return f.insertAfter(k),[f,k,k];const [n,u,v]=e(m);f=f.getNextSiblings();v.append(k,...f);return [n,u,k]},[d,g]=e(c);return [d,g]}
    	LexicalUtils_prod.$dfs=function(a,b){let c=[];a=(a||h.$getRoot()).getLatest();b=b||(h.$isElementNode(a)?a.getLastDescendant():a);for(var e=a,d=0;null!==(e=e.getParent());)d++;for(e=d;null!==a&&!a.is(b);)if(c.push({depth:e,node:a}),h.$isElementNode(a)&&0<a.getChildrenSize())a=a.getFirstChild(),e++;else for(d=null;null===d&&null!==a;)d=a.getNextSibling(),null===d?(a=a.getParent(),e--):a=d;null!==a&&a.is(b)&&c.push({depth:e,node:a});return c};LexicalUtils_prod.$findMatchingParent=r;
    	LexicalUtils_prod.$getNearestBlockElementAncestorOrThrow=function(a){a=r(a,b=>h.$isElementNode(b)&&!b.isInline());h.$isElementNode(a)||p(4);return a};LexicalUtils_prod.$getNearestNodeOfType=function(a,b){for(;null!=a;){if(a instanceof b)return a;a=a.getParent();}return null};
    	LexicalUtils_prod.$insertNodeToNearestRoot=function(a){var b=h.$getSelection();if(h.$isRangeSelection(b)){var {focus:c}=b;b=c.getNode();c=c.offset;if(h.$isRootOrShadowRoot(b))c=b.getChildAtIndex(c),null==c?b.append(a):c.insertBefore(a),a.selectNext();else {let e,d;h.$isTextNode(b)?(e=b.getParentOrThrow(),d=b.getIndexWithinParent(),0<c&&(d+=1,b.splitText(c))):(e=b,d=c);[,b]=t(e,d);b.insertBefore(a);b.selectStart();}}else h.$isNodeSelection(b)||h.DEPRECATED_$isGridSelection(b)?(b=b.getNodes(),b[b.length-1].getTopLevelElementOrThrow().insertAfter(a)):
    	h.$getRoot().append(a),b=h.$createParagraphNode(),a.insertAfter(b),b.select();return a.getLatest()};LexicalUtils_prod.$restoreEditorState=function(a,b){let c=new Map(b._nodeMap),e=a._pendingEditorState;e&&(e._nodeMap=c);a._dirtyType=2;a=b._selection;h.$setSelection(null===a?null:a.clone());};LexicalUtils_prod.$splitNode=t;LexicalUtils_prod.$wrapNodeInElement=function(a,b){b=b();a.replace(b);b.append(a);return b};
    	LexicalUtils_prod.addClassNamesToElement=function(a,...b){b.forEach(c=>{"string"===typeof c&&(c=c.split(" ").filter(e=>""!==e),a.classList.add(...c));});};LexicalUtils_prod.isMimeType=q;
    	LexicalUtils_prod.mediaFileReader=function(a,b){let c=a[Symbol.iterator]();return new Promise((e,d)=>{let g=[],f=()=>{const {done:m,value:l}=c.next();if(m)return e(g);const k=new FileReader;k.addEventListener("error",d);k.addEventListener("load",()=>{const n=k.result;"string"===typeof n&&g.push({file:l,result:n});f();});q(l,b)?k.readAsDataURL(l):f();};f();})};LexicalUtils_prod.mergeRegister=function(...a){return ()=>{a.forEach(b=>b());}};
    	LexicalUtils_prod.registerNestedElementResolver=function(a,b,c,e){return a.registerNodeTransform(b,d=>{a:{var g=d.getChildren();for(var f=0;f<g.length;f++)if(g[f]instanceof b){g=null;break a}for(g=d;null!==g;)if(f=g,g=g.getParent(),g instanceof b){g={child:f,parent:g};break a}g=null;}if(null!==g){const {child:m,parent:l}=g;if(m.is(d)){e(l,d);d=m.getNextSiblings();g=d.length;l.insertAfter(m);if(0!==g){f=c(l);m.insertAfter(f);for(let k=0;k<g;k++)f.append(d[k]);}l.canBeEmpty()||0!==l.getChildrenSize()||l.remove();}}})};
    	LexicalUtils_prod.removeClassNamesFromElement=function(a,...b){b.forEach(c=>{"string"===typeof c&&a.classList.remove(...c.split(" "));});};
    	return LexicalUtils_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalUtils = process.env.NODE_ENV === 'development' ? requireLexicalUtils_dev() : requireLexicalUtils_prod();
    var LexicalUtils_1 = LexicalUtils;

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalList_dev;

    function requireLexicalList_dev () {
    	if (hasRequiredLexicalList_dev) return LexicalList_dev;
    	hasRequiredLexicalList_dev = 1;

    	var lexical = Lexical_1;
    	var utils = LexicalUtils_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function $getListDepth(listNode) {
    	  let depth = 1;
    	  let parent = listNode.getParent();

    	  while (parent != null) {
    	    if ($isListItemNode(parent)) {
    	      const parentList = parent.getParent();

    	      if ($isListNode(parentList)) {
    	        depth++;
    	        parent = parentList.getParent();
    	        continue;
    	      }

    	      {
    	        throw Error(`A ListItemNode must have a ListNode for a parent.`);
    	      }
    	    }

    	    return depth;
    	  }

    	  return depth;
    	}
    	function $getTopListNode(listItem) {
    	  let list = listItem.getParent();

    	  if (!$isListNode(list)) {
    	    {
    	      throw Error(`A ListItemNode must have a ListNode for a parent.`);
    	    }
    	  }

    	  let parent = list;

    	  while (parent !== null) {
    	    parent = parent.getParent();

    	    if ($isListNode(parent)) {
    	      list = parent;
    	    }
    	  }

    	  return list;
    	}

    	function $getAllListItems(node) {
    	  let listItemNodes = [];
    	  const listChildren = node.getChildren().filter($isListItemNode);

    	  for (let i = 0; i < listChildren.length; i++) {
    	    const listItemNode = listChildren[i];
    	    const firstChild = listItemNode.getFirstChild();

    	    if ($isListNode(firstChild)) {
    	      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
    	    } else {
    	      listItemNodes.push(listItemNode);
    	    }
    	  }

    	  return listItemNodes;
    	}
    	function isNestedListNode(node) {
    	  return $isListItemNode(node) && $isListNode(node.getFirstChild());
    	} // TODO: rewrite with $findMatchingParent or *nodeOfType

    	function findNearestListItemNode(node) {
    	  let currentNode = node;

    	  while (currentNode !== null) {
    	    if ($isListItemNode(currentNode)) {
    	      return currentNode;
    	    }

    	    currentNode = currentNode.getParent();
    	  }

    	  return null;
    	}
    	function getUniqueListItemNodes(nodeList) {
    	  const keys = new Set();

    	  for (let i = 0; i < nodeList.length; i++) {
    	    const node = nodeList[i];

    	    if ($isListItemNode(node)) {
    	      keys.add(node);
    	    }
    	  }

    	  return Array.from(keys);
    	}
    	function $removeHighestEmptyListParent(sublist) {
    	  // Nodes may be repeatedly indented, to create deeply nested lists that each
    	  // contain just one bullet.
    	  // Our goal is to remove these (empty) deeply nested lists. The easiest
    	  // way to do that is crawl back up the tree until we find a node that has siblings
    	  // (e.g. is actually part of the list contents) and delete that, or delete
    	  // the root of the list (if no list nodes have siblings.)
    	  let emptyListPtr = sublist;

    	  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
    	    const parent = emptyListPtr.getParent();

    	    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {
    	      break;
    	    }

    	    emptyListPtr = parent;
    	  }

    	  emptyListPtr.remove();
    	}
    	function wrapInListItem(node) {
    	  const listItemWrapper = $createListItemNode();
    	  return listItemWrapper.append(node);
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	function $isSelectingEmptyListItem(anchorNode, nodes) {
    	  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
    	}

    	function $getListItemValue(listItem) {
    	  const list = listItem.getParent();
    	  let value = 1;

    	  if (list != null) {
    	    if (!$isListNode(list)) {
    	      {
    	        throw Error(`$getListItemValue: list node is not parent of list item node`);
    	      }
    	    } else {
    	      value = list.getStart();
    	    }
    	  }

    	  const siblings = listItem.getPreviousSiblings();

    	  for (let i = 0; i < siblings.length; i++) {
    	    const sibling = siblings[i];

    	    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {
    	      value++;
    	    }
    	  }

    	  return value;
    	}

    	function insertList(editor, listType) {
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
    	      const nodes = selection.getNodes();
    	      const anchor = selection.anchor;
    	      const anchorNode = anchor.getNode();
    	      const anchorNodeParent = anchorNode.getParent();

    	      if ($isSelectingEmptyListItem(anchorNode, nodes)) {
    	        const list = $createListNode(listType);

    	        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {
    	          anchorNode.replace(list);
    	          const listItem = $createListItemNode();

    	          if (lexical.$isElementNode(anchorNode)) {
    	            listItem.setFormat(anchorNode.getFormatType());
    	            listItem.setIndent(anchorNode.getIndent());
    	          }

    	          list.append(listItem);
    	        } else if ($isListItemNode(anchorNode)) {
    	          const parent = anchorNode.getParentOrThrow();
    	          append(list, parent.getChildren());
    	          parent.replace(list);
    	        }

    	        return;
    	      } else {
    	        const handled = new Set();

    	        for (let i = 0; i < nodes.length; i++) {
    	          const node = nodes[i];

    	          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {
    	            createListOrMerge(node, listType);
    	            continue;
    	          }

    	          if (lexical.$isLeafNode(node)) {
    	            let parent = node.getParent();

    	            while (parent != null) {
    	              const parentKey = parent.getKey();

    	              if ($isListNode(parent)) {
    	                if (!handled.has(parentKey)) {
    	                  const newListNode = $createListNode(listType);
    	                  append(newListNode, parent.getChildren());
    	                  parent.replace(newListNode);
    	                  updateChildrenListItemValue(newListNode);
    	                  handled.add(parentKey);
    	                }

    	                break;
    	              } else {
    	                const nextParent = parent.getParent();

    	                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
    	                  handled.add(parentKey);
    	                  createListOrMerge(parent, listType);
    	                  break;
    	                }

    	                parent = nextParent;
    	              }
    	            }
    	          }
    	        }
    	      }
    	    }
    	  });
    	}

    	function append(node, nodesToAppend) {
    	  node.splice(node.getChildrenSize(), 0, nodesToAppend);
    	}

    	function createListOrMerge(node, listType) {
    	  if ($isListNode(node)) {
    	    return node;
    	  }

    	  const previousSibling = node.getPreviousSibling();
    	  const nextSibling = node.getNextSibling();
    	  const listItem = $createListItemNode();
    	  listItem.setFormat(node.getFormatType());
    	  listItem.setIndent(node.getIndent());
    	  append(listItem, node.getChildren());

    	  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
    	    previousSibling.append(listItem);
    	    node.remove(); // if the same type of list is on both sides, merge them.

    	    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
    	      append(previousSibling, nextSibling.getChildren());
    	      nextSibling.remove();
    	    }

    	    return previousSibling;
    	  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
    	    nextSibling.getFirstChildOrThrow().insertBefore(listItem);
    	    node.remove();
    	    return nextSibling;
    	  } else {
    	    const list = $createListNode(listType);
    	    list.append(listItem);
    	    node.replace(list);
    	    updateChildrenListItemValue(list);
    	    return list;
    	  }
    	}

    	function removeList(editor) {
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection)) {
    	      const listNodes = new Set();
    	      const nodes = selection.getNodes();
    	      const anchorNode = selection.anchor.getNode();

    	      if ($isSelectingEmptyListItem(anchorNode, nodes)) {
    	        listNodes.add($getTopListNode(anchorNode));
    	      } else {
    	        for (let i = 0; i < nodes.length; i++) {
    	          const node = nodes[i];

    	          if (lexical.$isLeafNode(node)) {
    	            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);

    	            if (listItemNode != null) {
    	              listNodes.add($getTopListNode(listItemNode));
    	            }
    	          }
    	        }
    	      }

    	      for (const listNode of listNodes) {
    	        let insertionPoint = listNode;
    	        const listItems = $getAllListItems(listNode);

    	        for (const listItemNode of listItems) {
    	          const paragraph = lexical.$createParagraphNode();
    	          append(paragraph, listItemNode.getChildren());
    	          insertionPoint.insertAfter(paragraph);
    	          insertionPoint = paragraph; // When the anchor and focus fall on the textNode
    	          // we don't have to change the selection because the textNode will be appended to
    	          // the newly generated paragraph.
    	          // When selection is in empty nested list item, selection is actually on the listItemNode.
    	          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph
    	          // we should manually set the selection's focus and anchor to the newly generated paragraph.

    	          if (listItemNode.__key === selection.anchor.key) {
    	            selection.anchor.set(paragraph.getKey(), 0, 'element');
    	          }

    	          if (listItemNode.__key === selection.focus.key) {
    	            selection.focus.set(paragraph.getKey(), 0, 'element');
    	          }

    	          listItemNode.remove();
    	        }

    	        listNode.remove();
    	      }
    	    }
    	  });
    	}
    	function updateChildrenListItemValue(list, children) {
    	  const childrenOrExisting = children || list.getChildren();

    	  if (childrenOrExisting !== undefined) {
    	    for (let i = 0; i < childrenOrExisting.length; i++) {
    	      const child = childrenOrExisting[i];

    	      if ($isListItemNode(child)) {
    	        const prevValue = child.getValue();
    	        const nextValue = $getListItemValue(child);

    	        if (prevValue !== nextValue) {
    	          child.setValue(nextValue);
    	        }
    	      }
    	    }
    	  }
    	}
    	function $handleIndent(listItemNodes) {
    	  // go through each node and decide where to move it.
    	  const removed = new Set();
    	  listItemNodes.forEach(listItemNode => {
    	    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
    	      return;
    	    }

    	    const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards

    	    const nextSibling = listItemNode.getNextSibling();
    	    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.

    	    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
    	      const innerList = previousSibling.getFirstChild();

    	      if ($isListNode(innerList)) {
    	        innerList.append(listItemNode);
    	        const nextInnerList = nextSibling.getFirstChild();

    	        if ($isListNode(nextInnerList)) {
    	          const children = nextInnerList.getChildren();
    	          append(innerList, children);
    	          nextSibling.remove();
    	          removed.add(nextSibling.getKey());
    	        }

    	        updateChildrenListItemValue(innerList);
    	      }
    	    } else if (isNestedListNode(nextSibling)) {
    	      // if the ListItemNode is next to a nested ListNode, merge them
    	      const innerList = nextSibling.getFirstChild();

    	      if ($isListNode(innerList)) {
    	        const firstChild = innerList.getFirstChild();

    	        if (firstChild !== null) {
    	          firstChild.insertBefore(listItemNode);
    	        }

    	        updateChildrenListItemValue(innerList);
    	      }
    	    } else if (isNestedListNode(previousSibling)) {
    	      const innerList = previousSibling.getFirstChild();

    	      if ($isListNode(innerList)) {
    	        innerList.append(listItemNode);
    	        updateChildrenListItemValue(innerList);
    	      }
    	    } else {
    	      // otherwise, we need to create a new nested ListNode
    	      if ($isListNode(parent)) {
    	        const newListItem = $createListItemNode();
    	        const newList = $createListNode(parent.getListType());
    	        newListItem.append(newList);
    	        newList.append(listItemNode);

    	        if (previousSibling) {
    	          previousSibling.insertAfter(newListItem);
    	        } else if (nextSibling) {
    	          nextSibling.insertBefore(newListItem);
    	        } else {
    	          parent.append(newListItem);
    	        }
    	      }
    	    }

    	    if ($isListNode(parent)) {
    	      updateChildrenListItemValue(parent);
    	    }
    	  });
    	}
    	function $handleOutdent(listItemNodes) {
    	  // go through each node and decide where to move it.
    	  listItemNodes.forEach(listItemNode => {
    	    if (isNestedListNode(listItemNode)) {
    	      return;
    	    }

    	    const parentList = listItemNode.getParent();
    	    const grandparentListItem = parentList ? parentList.getParent() : undefined;
    	    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.

    	    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
    	      // if it's the first child in it's parent list, insert it into the
    	      // great grandparent list before the grandparent
    	      const firstChild = parentList ? parentList.getFirstChild() : undefined;
    	      const lastChild = parentList ? parentList.getLastChild() : undefined;

    	      if (listItemNode.is(firstChild)) {
    	        grandparentListItem.insertBefore(listItemNode);

    	        if (parentList.isEmpty()) {
    	          grandparentListItem.remove();
    	        } // if it's the last child in it's parent list, insert it into the
    	        // great grandparent list after the grandparent.

    	      } else if (listItemNode.is(lastChild)) {
    	        grandparentListItem.insertAfter(listItemNode);

    	        if (parentList.isEmpty()) {
    	          grandparentListItem.remove();
    	        }
    	      } else {
    	        // otherwise, we need to split the siblings into two new nested lists
    	        const listType = parentList.getListType();
    	        const previousSiblingsListItem = $createListItemNode();
    	        const previousSiblingsList = $createListNode(listType);
    	        previousSiblingsListItem.append(previousSiblingsList);
    	        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));
    	        const nextSiblingsListItem = $createListItemNode();
    	        const nextSiblingsList = $createListNode(listType);
    	        nextSiblingsListItem.append(nextSiblingsList);
    	        append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.

    	        grandparentListItem.insertBefore(previousSiblingsListItem);
    	        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.

    	        grandparentListItem.replace(listItemNode);
    	      }

    	      updateChildrenListItemValue(parentList);
    	      updateChildrenListItemValue(greatGrandparentList);
    	    }
    	  });
    	}

    	function maybeIndentOrOutdent(direction) {
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection)) {
    	    return;
    	  }

    	  const selectedNodes = selection.getNodes();
    	  let listItemNodes = [];

    	  if (selectedNodes.length === 0) {
    	    selectedNodes.push(selection.anchor.getNode());
    	  }

    	  if (selectedNodes.length === 1) {
    	    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to
    	    // find whether this is part of a ListItemNode
    	    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);

    	    if (nearestListItemNode !== null) {
    	      listItemNodes = [nearestListItemNode];
    	    }
    	  } else {
    	    listItemNodes = getUniqueListItemNodes(selectedNodes);
    	  }

    	  if (listItemNodes.length > 0) {
    	    if (direction === 'indent') {
    	      $handleIndent(listItemNodes);
    	    } else {
    	      $handleOutdent(listItemNodes);
    	    }
    	  }
    	}

    	function indentList() {
    	  maybeIndentOrOutdent('indent');
    	}
    	function outdentList() {
    	  maybeIndentOrOutdent('outdent');
    	}
    	function $handleListInsertParagraph() {
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
    	    return false;
    	  } // Only run this code on empty list items


    	  const anchor = selection.anchor.getNode();

    	  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {
    	    return false;
    	  }

    	  const topListNode = $getTopListNode(anchor);
    	  const parent = anchor.getParent();

    	  if (!$isListNode(parent)) {
    	    throw Error(`A ListItemNode must have a ListNode for a parent.`);
    	  }

    	  const grandparent = parent.getParent();
    	  let replacementNode;

    	  if (lexical.$isRootOrShadowRoot(grandparent)) {
    	    replacementNode = lexical.$createParagraphNode();
    	    topListNode.insertAfter(replacementNode);
    	  } else if ($isListItemNode(grandparent)) {
    	    replacementNode = $createListItemNode();
    	    grandparent.insertAfter(replacementNode);
    	  } else {
    	    return false;
    	  }

    	  replacementNode.select();
    	  const nextSiblings = anchor.getNextSiblings();

    	  if (nextSiblings.length > 0) {
    	    const newList = $createListNode(parent.getListType());

    	    if (lexical.$isParagraphNode(replacementNode)) {
    	      replacementNode.insertAfter(newList);
    	    } else {
    	      const newListItem = $createListItemNode();
    	      newListItem.append(newList);
    	      replacementNode.insertAfter(newListItem);
    	    }

    	    nextSiblings.forEach(sibling => {
    	      sibling.remove();
    	      newList.append(sibling);
    	    });
    	  } // Don't leave hanging nested empty lists


    	  $removeHighestEmptyListParent(anchor);
    	  return true;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class ListItemNode extends lexical.ElementNode {
    	  /** @internal */

    	  /** @internal */
    	  static getType() {
    	    return 'listitem';
    	  }

    	  static clone(node) {
    	    return new ListItemNode(node.__value, node.__checked, node.__key);
    	  }

    	  constructor(value, checked, key) {
    	    super(key);
    	    this.__value = value === undefined ? 1 : value;
    	    this.__checked = checked;
    	  }

    	  createDOM(config) {
    	    const element = document.createElement('li');
    	    const parent = this.getParent();

    	    if ($isListNode(parent)) {
    	      updateChildrenListItemValue(parent);
    	      updateListItemChecked(element, this, null, parent);
    	    }

    	    element.value = this.__value;
    	    $setListItemThemeClassNames(element, config.theme, this);
    	    return element;
    	  }

    	  updateDOM(prevNode, dom, config) {
    	    const parent = this.getParent();

    	    if ($isListNode(parent)) {
    	      updateChildrenListItemValue(parent);
    	      updateListItemChecked(dom, this, prevNode, parent);
    	    } // @ts-expect-error - this is always HTMLListItemElement


    	    dom.value = this.__value;
    	    $setListItemThemeClassNames(dom, config.theme, this);
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      li: node => ({
    	        conversion: convertListItemElement,
    	        priority: 0
    	      })
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = new ListItemNode(serializedNode.value, serializedNode.checked);
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      checked: this.getChecked(),
    	      type: 'listitem',
    	      value: this.getValue(),
    	      version: 1
    	    };
    	  }

    	  append(...nodes) {
    	    for (let i = 0; i < nodes.length; i++) {
    	      const node = nodes[i];

    	      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {
    	        const children = node.getChildren();
    	        this.append(...children);
    	        node.remove();
    	      } else {
    	        super.append(node);
    	      }
    	    }

    	    return this;
    	  }

    	  replace(replaceWithNode, includeChildren) {
    	    if ($isListItemNode(replaceWithNode)) {
    	      return super.replace(replaceWithNode);
    	    }

    	    const list = this.getParentOrThrow();

    	    if ($isListNode(list)) {
    	      const childrenKeys = list.getChildrenKeys();
    	      const childrenLength = childrenKeys.length;
    	      const index = childrenKeys.indexOf(this.__key);

    	      if (index === 0) {
    	        list.insertBefore(replaceWithNode);
    	      } else if (index === childrenLength - 1) {
    	        list.insertAfter(replaceWithNode);
    	      } else {
    	        // Split the list
    	        const newList = $createListNode(list.getListType());
    	        const children = list.getChildren();

    	        for (let i = index + 1; i < childrenLength; i++) {
    	          const child = children[i];
    	          newList.append(child);
    	        }

    	        list.insertAfter(replaceWithNode);
    	        replaceWithNode.insertAfter(newList);
    	      }

    	      if (includeChildren) {
    	        this.getChildren().forEach(child => {
    	          replaceWithNode.append(child);
    	        });
    	      }

    	      this.remove();

    	      if (childrenLength === 1) {
    	        list.remove();
    	      }
    	    }

    	    return replaceWithNode;
    	  }

    	  insertAfter(node, restoreSelection = true) {
    	    const listNode = this.getParentOrThrow();

    	    if (!$isListNode(listNode)) {
    	      {
    	        throw Error(`insertAfter: list node is not parent of list item node`);
    	      }
    	    }

    	    const siblings = this.getNextSiblings();

    	    if ($isListItemNode(node)) {
    	      const after = super.insertAfter(node, restoreSelection);
    	      const afterListNode = node.getParentOrThrow();

    	      if ($isListNode(afterListNode)) {
    	        updateChildrenListItemValue(afterListNode);
    	      }

    	      return after;
    	    } // Attempt to merge if the list is of the same type.


    	    if ($isListNode(node) && node.getListType() === listNode.getListType()) {
    	      let child = node;
    	      const children = node.getChildren();

    	      for (let i = children.length - 1; i >= 0; i--) {
    	        child = children[i];
    	        this.insertAfter(child, restoreSelection);
    	      }

    	      return child;
    	    } // Otherwise, split the list
    	    // Split the lists and insert the node in between them


    	    listNode.insertAfter(node, restoreSelection);

    	    if (siblings.length !== 0) {
    	      const newListNode = $createListNode(listNode.getListType());
    	      siblings.forEach(sibling => newListNode.append(sibling));
    	      node.insertAfter(newListNode, restoreSelection);
    	    }

    	    return node;
    	  }

    	  remove(preserveEmptyParent) {
    	    const nextSibling = this.getNextSibling();
    	    super.remove(preserveEmptyParent);

    	    if (nextSibling !== null) {
    	      const parent = nextSibling.getParent();

    	      if ($isListNode(parent)) {
    	        updateChildrenListItemValue(parent);
    	      }
    	    }
    	  }

    	  insertNewAfter(_, restoreSelection = true) {
    	    const newElement = $createListItemNode(this.__checked == null ? undefined : false);
    	    this.insertAfter(newElement, restoreSelection);
    	    return newElement;
    	  }

    	  collapseAtStart(selection) {
    	    const paragraph = lexical.$createParagraphNode();
    	    const children = this.getChildren();
    	    children.forEach(child => paragraph.append(child));
    	    const listNode = this.getParentOrThrow();
    	    const listNodeParent = listNode.getParentOrThrow();
    	    const isIndented = $isListItemNode(listNodeParent);

    	    if (listNode.getChildrenSize() === 1) {
    	      if (isIndented) {
    	        // if the list node is nested, we just want to remove it,
    	        // effectively unindenting it.
    	        listNode.remove();
    	        listNodeParent.select();
    	      } else {
    	        listNode.insertBefore(paragraph);
    	        listNode.remove(); // If we have selection on the list item, we'll need to move it
    	        // to the paragraph

    	        const anchor = selection.anchor;
    	        const focus = selection.focus;
    	        const key = paragraph.getKey();

    	        if (anchor.type === 'element' && anchor.getNode().is(this)) {
    	          anchor.set(key, anchor.offset, 'element');
    	        }

    	        if (focus.type === 'element' && focus.getNode().is(this)) {
    	          focus.set(key, focus.offset, 'element');
    	        }
    	      }
    	    } else {
    	      listNode.insertBefore(paragraph);
    	      this.remove();
    	    }

    	    return true;
    	  }

    	  getValue() {
    	    const self = this.getLatest();
    	    return self.__value;
    	  }

    	  setValue(value) {
    	    const self = this.getWritable();
    	    self.__value = value;
    	  }

    	  getChecked() {
    	    const self = this.getLatest();
    	    return self.__checked;
    	  }

    	  setChecked(checked) {
    	    const self = this.getWritable();
    	    self.__checked = checked;
    	  }

    	  toggleChecked() {
    	    this.setChecked(!this.__checked);
    	  }

    	  getIndent() {
    	    // If we don't have a parent, we are likely serializing
    	    const parent = this.getParent();

    	    if (parent === null) {
    	      return this.getLatest().__indent;
    	    } // ListItemNode should always have a ListNode for a parent.


    	    let listNodeParent = parent.getParentOrThrow();
    	    let indentLevel = 0;

    	    while ($isListItemNode(listNodeParent)) {
    	      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
    	      indentLevel++;
    	    }

    	    return indentLevel;
    	  }

    	  setIndent(indent) {
    	    let currentIndent = this.getIndent();

    	    while (currentIndent !== indent) {
    	      if (currentIndent < indent) {
    	        $handleIndent([this]);
    	        currentIndent++;
    	      } else {
    	        $handleOutdent([this]);
    	        currentIndent--;
    	      }
    	    }

    	    return this;
    	  }

    	  canIndent() {
    	    // Indent/outdent is handled specifically in the RichText logic.
    	    return false;
    	  }

    	  insertBefore(nodeToInsert) {
    	    if ($isListItemNode(nodeToInsert)) {
    	      const parent = this.getParentOrThrow();

    	      if ($isListNode(parent)) {
    	        const siblings = this.getNextSiblings();
    	        updateChildrenListItemValue(parent, siblings);
    	      }
    	    }

    	    return super.insertBefore(nodeToInsert);
    	  }

    	  canInsertAfter(node) {
    	    return $isListItemNode(node);
    	  }

    	  canReplaceWith(replacement) {
    	    return $isListItemNode(replacement);
    	  }

    	  canMergeWith(node) {
    	    return lexical.$isParagraphNode(node) || $isListItemNode(node);
    	  }

    	  extractWithChild(child, selection) {
    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    const anchorNode = selection.anchor.getNode();
    	    const focusNode = selection.focus.getNode();
    	    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
    	  }

    	}

    	function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
    	  const classesToAdd = [];
    	  const classesToRemove = [];
    	  const listTheme = editorThemeClasses.list;
    	  const listItemClassName = listTheme ? listTheme.listitem : undefined;
    	  let nestedListItemClassName;

    	  if (listTheme && listTheme.nested) {
    	    nestedListItemClassName = listTheme.nested.listitem;
    	  }

    	  if (listItemClassName !== undefined) {
    	    const listItemClasses = listItemClassName.split(' ');
    	    classesToAdd.push(...listItemClasses);
    	  }

    	  if (listTheme) {
    	    const parentNode = node.getParent();
    	    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';
    	    const checked = node.getChecked();

    	    if (!isCheckList || checked) {
    	      classesToRemove.push(listTheme.listitemUnchecked);
    	    }

    	    if (!isCheckList || !checked) {
    	      classesToRemove.push(listTheme.listitemChecked);
    	    }

    	    if (isCheckList) {
    	      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
    	    }
    	  }

    	  if (nestedListItemClassName !== undefined) {
    	    const nestedListItemClasses = nestedListItemClassName.split(' ');

    	    if (node.getChildren().some(child => $isListNode(child))) {
    	      classesToAdd.push(...nestedListItemClasses);
    	    } else {
    	      classesToRemove.push(...nestedListItemClasses);
    	    }
    	  }

    	  if (classesToRemove.length > 0) {
    	    utils.removeClassNamesFromElement(dom, ...classesToRemove);
    	  }

    	  if (classesToAdd.length > 0) {
    	    utils.addClassNamesToElement(dom, ...classesToAdd);
    	  }
    	}

    	function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
    	  const isCheckList = listNode.getListType() === 'check';

    	  if (isCheckList) {
    	    // Only add attributes for leaf list items
    	    if ($isListNode(listItemNode.getFirstChild())) {
    	      dom.removeAttribute('role');
    	      dom.removeAttribute('tabIndex');
    	      dom.removeAttribute('aria-checked');
    	    } else {
    	      dom.setAttribute('role', 'checkbox');
    	      dom.setAttribute('tabIndex', '-1');

    	      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
    	        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');
    	      }
    	    }
    	  } else {
    	    // Clean up checked state
    	    if (listItemNode.getChecked() != null) {
    	      listItemNode.setChecked(undefined);
    	    }
    	  }
    	}

    	function convertListItemElement(domNode) {
    	  const checked = domNode instanceof HTMLElement && domNode.getAttribute('aria-checked') === 'true';
    	  return {
    	    node: $createListItemNode(checked)
    	  };
    	}

    	function $createListItemNode(checked) {
    	  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));
    	}
    	function $isListItemNode(node) {
    	  return node instanceof ListItemNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class ListNode extends lexical.ElementNode {
    	  /** @internal */

    	  /** @internal */

    	  /** @internal */
    	  static getType() {
    	    return 'list';
    	  }

    	  static clone(node) {
    	    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
    	    return new ListNode(listType, node.__start, node.__key);
    	  }

    	  constructor(listType, start, key) {
    	    super(key);

    	    const _listType = TAG_TO_LIST_TYPE[listType] || listType;

    	    this.__listType = _listType;
    	    this.__tag = _listType === 'number' ? 'ol' : 'ul';
    	    this.__start = start;
    	  }

    	  getTag() {
    	    return this.__tag;
    	  }

    	  getListType() {
    	    return this.__listType;
    	  }

    	  getStart() {
    	    return this.__start;
    	  } // View


    	  createDOM(config, _editor) {
    	    const tag = this.__tag;
    	    const dom = document.createElement(tag);

    	    if (this.__start !== 1) {
    	      dom.setAttribute('start', String(this.__start));
    	    } // @ts-expect-error Internal field.


    	    dom.__lexicalListType = this.__listType;
    	    setListThemeClassNames(dom, config.theme, this);
    	    return dom;
    	  }

    	  updateDOM(prevNode, dom, config) {
    	    if (prevNode.__tag !== this.__tag) {
    	      return true;
    	    }

    	    setListThemeClassNames(dom, config.theme, this);
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      ol: node => ({
    	        conversion: convertListNode,
    	        priority: 0
    	      }),
    	      ul: node => ({
    	        conversion: convertListNode,
    	        priority: 0
    	      })
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createListNode(serializedNode.listType, serializedNode.start);
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportDOM(editor) {
    	    const element = document.createElement(this.__tag);

    	    if (this.__start !== 1) {
    	      element.setAttribute('start', String(this.__start));
    	    }

    	    if (this.__listType === 'check') {
    	      element.setAttribute('__lexicalListType', 'check');
    	    }

    	    return {
    	      element
    	    };
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      listType: this.getListType(),
    	      start: this.getStart(),
    	      tag: this.getTag(),
    	      type: 'list',
    	      version: 1
    	    };
    	  }

    	  canBeEmpty() {
    	    return false;
    	  }

    	  canIndent() {
    	    return false;
    	  }

    	  append(...nodesToAppend) {
    	    for (let i = 0; i < nodesToAppend.length; i++) {
    	      const currentNode = nodesToAppend[i];

    	      if ($isListItemNode(currentNode)) {
    	        super.append(currentNode);
    	      } else {
    	        const listItemNode = $createListItemNode();

    	        if ($isListNode(currentNode)) {
    	          listItemNode.append(currentNode);
    	        } else if (lexical.$isElementNode(currentNode)) {
    	          const textNode = lexical.$createTextNode(currentNode.getTextContent());
    	          listItemNode.append(textNode);
    	        } else {
    	          listItemNode.append(currentNode);
    	        }

    	        super.append(listItemNode);
    	      }
    	    }

    	    return this;
    	  }

    	  extractWithChild(child) {
    	    return $isListItemNode(child);
    	  }

    	}

    	function setListThemeClassNames(dom, editorThemeClasses, node) {
    	  const classesToAdd = [];
    	  const classesToRemove = [];
    	  const listTheme = editorThemeClasses.list;

    	  if (listTheme !== undefined) {
    	    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
    	    const listDepth = $getListDepth(node) - 1;
    	    const normalizedListDepth = listDepth % listLevelsClassNames.length;
    	    const listLevelClassName = listLevelsClassNames[normalizedListDepth];
    	    const listClassName = listTheme[node.__tag];
    	    let nestedListClassName;
    	    const nestedListTheme = listTheme.nested;

    	    if (nestedListTheme !== undefined && nestedListTheme.list) {
    	      nestedListClassName = nestedListTheme.list;
    	    }

    	    if (listClassName !== undefined) {
    	      classesToAdd.push(listClassName);
    	    }

    	    if (listLevelClassName !== undefined) {
    	      const listItemClasses = listLevelClassName.split(' ');
    	      classesToAdd.push(...listItemClasses);

    	      for (let i = 0; i < listLevelsClassNames.length; i++) {
    	        if (i !== normalizedListDepth) {
    	          classesToRemove.push(node.__tag + i);
    	        }
    	      }
    	    }

    	    if (nestedListClassName !== undefined) {
    	      const nestedListItemClasses = nestedListClassName.split(' ');

    	      if (listDepth > 1) {
    	        classesToAdd.push(...nestedListItemClasses);
    	      } else {
    	        classesToRemove.push(...nestedListItemClasses);
    	      }
    	    }
    	  }

    	  if (classesToRemove.length > 0) {
    	    utils.removeClassNamesFromElement(dom, ...classesToRemove);
    	  }

    	  if (classesToAdd.length > 0) {
    	    utils.addClassNamesToElement(dom, ...classesToAdd);
    	  }
    	}
    	/*
    	 * This function normalizes the children of a ListNode after the conversion from HTML,
    	 * ensuring that they are all ListItemNodes and contain either a single nested ListNode
    	 * or some other inline content.
    	 */


    	function normalizeChildren(nodes) {
    	  const normalizedListItems = [];

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];

    	    if ($isListItemNode(node)) {
    	      normalizedListItems.push(node);
    	      node.getChildren().forEach(child => {
    	        if ($isListNode(child)) {
    	          normalizedListItems.push(wrapInListItem(child));
    	        }
    	      });
    	    } else {
    	      normalizedListItems.push(wrapInListItem(node));
    	    }
    	  }

    	  return normalizedListItems;
    	}

    	function convertListNode(domNode) {
    	  const nodeName = domNode.nodeName.toLowerCase();
    	  let node = null;

    	  if (nodeName === 'ol') {
    	    node = $createListNode('number');
    	  } else if (nodeName === 'ul') {
    	    if (domNode instanceof HTMLElement && domNode.getAttribute('__lexicallisttype') === 'check') {
    	      node = $createListNode('check');
    	    } else {
    	      node = $createListNode('bullet');
    	    }
    	  }

    	  return {
    	    after: normalizeChildren,
    	    node
    	  };
    	}

    	const TAG_TO_LIST_TYPE = {
    	  ol: 'number',
    	  ul: 'bullet'
    	};
    	function $createListNode(listType, start = 1) {
    	  return lexical.$applyNodeReplacement(new ListNode(listType, start));
    	}
    	function $isListNode(node) {
    	  return node instanceof ListNode;
    	}

    	/** @module @lexical/list */
    	const INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');
    	const INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');
    	const INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');
    	const REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');

    	LexicalList_dev.$createListItemNode = $createListItemNode;
    	LexicalList_dev.$createListNode = $createListNode;
    	LexicalList_dev.$getListDepth = $getListDepth;
    	LexicalList_dev.$handleListInsertParagraph = $handleListInsertParagraph;
    	LexicalList_dev.$isListItemNode = $isListItemNode;
    	LexicalList_dev.$isListNode = $isListNode;
    	LexicalList_dev.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;
    	LexicalList_dev.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;
    	LexicalList_dev.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;
    	LexicalList_dev.ListItemNode = ListItemNode;
    	LexicalList_dev.ListNode = ListNode;
    	LexicalList_dev.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;
    	LexicalList_dev.indentList = indentList;
    	LexicalList_dev.insertList = insertList;
    	LexicalList_dev.outdentList = outdentList;
    	LexicalList_dev.removeList = removeList;
    	return LexicalList_dev;
    }

    var LexicalList_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalList_prod;

    function requireLexicalList_prod () {
    	if (hasRequiredLexicalList_prod) return LexicalList_prod;
    	hasRequiredLexicalList_prod = 1;
    var h=Lexical_1,k=LexicalUtils_1;function m(a){throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or `+"use the non-minified dev environment for full errors and additional helpful warnings.");}function n(a){let b=1;for(a=a.getParent();null!=a;){if(p(a)){a=a.getParent();if(q(a)){b++;a=a.getParent();continue}m(40);}break}return b}
    	function r(a){a=a.getParent();q(a)||m(40);let b=a;for(;null!==b;)b=b.getParent(),q(b)&&(a=b);return a}function t(a){let b=[];a=a.getChildren().filter(p);for(let c=0;c<a.length;c++){let d=a[c],e=d.getFirstChild();q(e)?b=b.concat(t(e)):b.push(d);}return b}function u(a){return p(a)&&q(a.getFirstChild())}function v(a){for(;null==a.getNextSibling()&&null==a.getPreviousSibling();){let b=a.getParent();if(null==b||!p(a)&&!q(a))break;a=b;}a.remove();}function w(a){return z().append(a)}
    	function A(a,b){return p(a)&&(0===b.length||1===b.length&&a.is(b[0])&&0===a.getChildrenSize())}function C(a,b){a.splice(a.getChildrenSize(),0,b);}
    	function D(a,b){if(q(a))return a;let c=a.getPreviousSibling(),d=a.getNextSibling(),e=z();e.setFormat(a.getFormatType());e.setIndent(a.getIndent());C(e,a.getChildren());if(q(c)&&b===c.getListType())return c.append(e),a.remove(),q(d)&&b===d.getListType()&&(C(c,d.getChildren()),d.remove()),c;if(q(d)&&b===d.getListType())return d.getFirstChildOrThrow().insertBefore(e),a.remove(),d;b=E(b);b.append(e);a.replace(b);F(b);return b}
    	function F(a,b){a=b||a.getChildren();if(void 0!==a)for(b=0;b<a.length;b++){let f=a[b];if(p(f)){let g=f.getValue();var c=f,d=c.getParent(),e=1;null!=d&&(q(d)?e=d.getStart():m(44));c=c.getPreviousSiblings();for(d=0;d<c.length;d++){let l=c[d];p(l)&&!q(l.getFirstChild())&&e++;}g!==e&&f.setValue(e);}}}
    	function G(a){let b=new Set;a.forEach(c=>{if(!u(c)&&!b.has(c.getKey())){var d=c.getParent(),e=c.getNextSibling(),f=c.getPreviousSibling();if(u(e)&&u(f))f=f.getFirstChild(),q(f)&&(f.append(c),c=e.getFirstChild(),q(c)&&(c=c.getChildren(),C(f,c),e.remove(),b.add(e.getKey())),F(f));else if(u(e))e=e.getFirstChild(),q(e)&&(f=e.getFirstChild(),null!==f&&f.insertBefore(c),F(e));else if(u(f))e=f.getFirstChild(),q(e)&&(e.append(c),F(e));else if(q(d)){let g=z(),l=E(d.getListType());g.append(l);l.append(c);f?
    	f.insertAfter(g):e?e.insertBefore(g):d.append(g);}q(d)&&F(d);}});}
    	function H(a){a.forEach(b=>{if(!u(b)){var c=b.getParent(),d=c?c.getParent():void 0,e=d?d.getParent():void 0;if(q(e)&&p(d)&&q(c)){var f=c?c.getFirstChild():void 0,g=c?c.getLastChild():void 0;if(b.is(f))d.insertBefore(b),c.isEmpty()&&d.remove();else if(b.is(g))d.insertAfter(b),c.isEmpty()&&d.remove();else {var l=c.getListType();f=z();let x=E(l);f.append(x);b.getPreviousSiblings().forEach(y=>x.append(y));g=z();l=E(l);g.append(l);C(l,b.getNextSiblings());d.insertBefore(f);d.insertAfter(g);d.replace(b);}F(c);
    	F(e);}}});}function I(a){var b=h.$getSelection();if(h.$isRangeSelection(b)){var c=b.getNodes(),d=[];0===c.length&&c.push(b.anchor.getNode());if(1===c.length){a:{for(c=c[0];null!==c;){if(p(c))break a;c=c.getParent();}c=null;}null!==c&&(d=[c]);}else {d=new Set;for(b=0;b<c.length;b++){let e=c[b];p(e)&&d.add(e);}d=Array.from(d);}0<d.length&&("indent"===a?G(d):H(d));}}
    	class J extends h.ElementNode{static getType(){return "listitem"}static clone(a){return new J(a.__value,a.__checked,a.__key)}constructor(a,b,c){super(c);this.__value=void 0===a?1:a;this.__checked=b;}createDOM(a){let b=document.createElement("li"),c=this.getParent();q(c)&&(F(c),K(b,this,null,c));b.value=this.__value;L(b,a.theme,this);return b}updateDOM(a,b,c){let d=this.getParent();q(d)&&(F(d),K(b,this,a,d));b.value=this.__value;L(b,c.theme,this);return !1}static importDOM(){return {li:()=>({conversion:M,
    	priority:0})}}static importJSON(a){let b=new J(a.value,a.checked);b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {...super.exportJSON(),checked:this.getChecked(),type:"listitem",value:this.getValue(),version:1}}append(...a){for(let b=0;b<a.length;b++){let c=a[b];if(h.$isElementNode(c)&&this.canMergeWith(c)){let d=c.getChildren();this.append(...d);c.remove();}else super.append(c);}return this}replace(a,b){if(p(a))return super.replace(a);let c=this.getParentOrThrow();
    	if(q(c)){var d=c.getChildrenKeys();let f=d.length;var e=d.indexOf(this.__key);if(0===e)c.insertBefore(a);else if(e===f-1)c.insertAfter(a);else {d=E(c.getListType());let g=c.getChildren();for(e+=1;e<f;e++)d.append(g[e]);c.insertAfter(a);a.insertAfter(d);}b&&this.getChildren().forEach(g=>{a.append(g);});this.remove();1===f&&c.remove();}return a}insertAfter(a,b=!0){var c=this.getParentOrThrow();q(c)||m(39);var d=this.getNextSiblings();if(p(a))return b=super.insertAfter(a,b),a=a.getParentOrThrow(),q(a)&&
    	F(a),b;if(q(a)&&a.getListType()===c.getListType()){c=a;a=a.getChildren();for(d=a.length-1;0<=d;d--)c=a[d],this.insertAfter(c,b);return c}c.insertAfter(a,b);if(0!==d.length){let e=E(c.getListType());d.forEach(f=>e.append(f));a.insertAfter(e,b);}return a}remove(a){let b=this.getNextSibling();super.remove(a);null!==b&&(a=b.getParent(),q(a)&&F(a));}insertNewAfter(a,b=!0){a=z(null==this.__checked?void 0:!1);this.insertAfter(a,b);return a}collapseAtStart(a){let b=h.$createParagraphNode();this.getChildren().forEach(f=>
    	b.append(f));var c=this.getParentOrThrow(),d=c.getParentOrThrow();let e=p(d);1===c.getChildrenSize()?e?(c.remove(),d.select()):(c.insertBefore(b),c.remove(),c=a.anchor,a=a.focus,d=b.getKey(),"element"===c.type&&c.getNode().is(this)&&c.set(d,c.offset,"element"),"element"===a.type&&a.getNode().is(this)&&a.set(d,a.offset,"element")):(c.insertBefore(b),this.remove());return !0}getValue(){return this.getLatest().__value}setValue(a){this.getWritable().__value=a;}getChecked(){return this.getLatest().__checked}setChecked(a){this.getWritable().__checked=
    	a;}toggleChecked(){this.setChecked(!this.__checked);}getIndent(){var a=this.getParent();if(null===a)return this.getLatest().__indent;a=a.getParentOrThrow();let b=0;for(;p(a);)a=a.getParentOrThrow().getParentOrThrow(),b++;return b}setIndent(a){let b=this.getIndent();for(;b!==a;)b<a?(G([this]),b++):(H([this]),b--);return this}canIndent(){return !1}insertBefore(a){if(p(a)){let b=this.getParentOrThrow();if(q(b)){let c=this.getNextSiblings();F(b,c);}}return super.insertBefore(a)}canInsertAfter(a){return p(a)}canReplaceWith(a){return p(a)}canMergeWith(a){return h.$isParagraphNode(a)||
    	p(a)}extractWithChild(a,b){if(!h.$isRangeSelection(b))return !1;a=b.anchor.getNode();let c=b.focus.getNode();return this.isParentOf(a)&&this.isParentOf(c)&&this.getTextContent().length===b.getTextContent().length}}
    	function L(a,b,c){let d=[],e=[];var f=(b=b.list)?b.listitem:void 0;if(b&&b.nested)var g=b.nested.listitem;void 0!==f&&(f=f.split(" "),d.push(...f));if(b){f=c.getParent();f=q(f)&&"check"===f.getListType();let l=c.getChecked();f&&!l||e.push(b.listitemUnchecked);f&&l||e.push(b.listitemChecked);f&&d.push(l?b.listitemChecked:b.listitemUnchecked);}void 0!==g&&(g=g.split(" "),c.getChildren().some(l=>q(l))?d.push(...g):e.push(...g));0<e.length&&k.removeClassNamesFromElement(a,...e);0<d.length&&k.addClassNamesToElement(a,
    	...d);}function K(a,b,c,d){"check"===d.getListType()?q(b.getFirstChild())?(a.removeAttribute("role"),a.removeAttribute("tabIndex"),a.removeAttribute("aria-checked")):(a.setAttribute("role","checkbox"),a.setAttribute("tabIndex","-1"),c&&b.__checked===c.__checked||a.setAttribute("aria-checked",b.getChecked()?"true":"false")):null!=b.getChecked()&&b.setChecked(void 0);}function M(a){a=a instanceof HTMLElement&&"true"===a.getAttribute("aria-checked");return {node:z(a)}}
    	function z(a){return h.$applyNodeReplacement(new J(void 0,a))}function p(a){return a instanceof J}
    	class N extends h.ElementNode{static getType(){return "list"}static clone(a){return new N(a.__listType||O[a.__tag],a.__start,a.__key)}constructor(a,b,c){super(c);this.__listType=a=O[a]||a;this.__tag="number"===a?"ol":"ul";this.__start=b;}getTag(){return this.__tag}getListType(){return this.__listType}getStart(){return this.__start}createDOM(a){let b=document.createElement(this.__tag);1!==this.__start&&b.setAttribute("start",String(this.__start));b.__lexicalListType=this.__listType;P(b,a.theme,this);
    	return b}updateDOM(a,b,c){if(a.__tag!==this.__tag)return !0;P(b,c.theme,this);return !1}static importDOM(){return {ol:()=>({conversion:Q,priority:0}),ul:()=>({conversion:Q,priority:0})}}static importJSON(a){let b=E(a.listType,a.start);b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportDOM(){let a=document.createElement(this.__tag);1!==this.__start&&a.setAttribute("start",String(this.__start));"check"===this.__listType&&a.setAttribute("__lexicalListType","check");return {element:a}}exportJSON(){return {...super.exportJSON(),
    	listType:this.getListType(),start:this.getStart(),tag:this.getTag(),type:"list",version:1}}canBeEmpty(){return !1}canIndent(){return !1}append(...a){for(let c=0;c<a.length;c++){var b=a[c];if(p(b))super.append(b);else {let d=z();q(b)?d.append(b):h.$isElementNode(b)?(b=h.$createTextNode(b.getTextContent()),d.append(b)):d.append(b);super.append(d);}}return this}extractWithChild(a){return p(a)}}
    	function P(a,b,c){let d=[],e=[];var f=b.list;if(void 0!==f){let l=f[`${c.__tag}Depth`]||[];b=n(c)-1;let x=b%l.length;var g=l[x];let y=f[c.__tag],B;f=f.nested;void 0!==f&&f.list&&(B=f.list);void 0!==y&&d.push(y);if(void 0!==g)for(g=g.split(" "),d.push(...g),g=0;g<l.length;g++)g!==x&&e.push(c.__tag+g);void 0!==B&&(c=B.split(" "),1<b?d.push(...c):e.push(...c));}0<e.length&&k.removeClassNamesFromElement(a,...e);0<d.length&&k.addClassNamesToElement(a,...d);}
    	function R(a){let b=[];for(let c=0;c<a.length;c++){let d=a[c];p(d)?(b.push(d),d.getChildren().forEach(e=>{q(e)&&b.push(w(e));})):b.push(w(d));}return b}function Q(a){let b=a.nodeName.toLowerCase(),c=null;"ol"===b?c=E("number"):"ul"===b&&(c=a instanceof HTMLElement&&"check"===a.getAttribute("__lexicallisttype")?E("check"):E("bullet"));return {after:R,node:c}}let O={ol:"number",ul:"bullet"};function E(a,b=1){return h.$applyNodeReplacement(new N(a,b))}function q(a){return a instanceof N}
    	let S=h.createCommand("INSERT_UNORDERED_LIST_COMMAND"),T=h.createCommand("INSERT_ORDERED_LIST_COMMAND"),U=h.createCommand("INSERT_CHECK_LIST_COMMAND"),V=h.createCommand("REMOVE_LIST_COMMAND");LexicalList_prod.$createListItemNode=z;LexicalList_prod.$createListNode=E;LexicalList_prod.$getListDepth=n;
    	LexicalList_prod.$handleListInsertParagraph=function(){var a=h.$getSelection();if(!h.$isRangeSelection(a)||!a.isCollapsed())return !1;a=a.anchor.getNode();if(!p(a)||""!==a.getTextContent())return !1;var b=r(a),c=a.getParent();q(c)||m(40);let d=c.getParent(),e;if(h.$isRootOrShadowRoot(d))e=h.$createParagraphNode(),b.insertAfter(e);else if(p(d))e=z(),d.insertAfter(e);else return !1;e.select();b=a.getNextSiblings();if(0<b.length){let f=E(c.getListType());h.$isParagraphNode(e)?e.insertAfter(f):(c=z(),c.append(f),
    	e.insertAfter(c));b.forEach(g=>{g.remove();f.append(g);});}v(a);return !0};LexicalList_prod.$isListItemNode=p;LexicalList_prod.$isListNode=q;LexicalList_prod.INSERT_CHECK_LIST_COMMAND=U;LexicalList_prod.INSERT_ORDERED_LIST_COMMAND=T;LexicalList_prod.INSERT_UNORDERED_LIST_COMMAND=S;LexicalList_prod.ListItemNode=J;LexicalList_prod.ListNode=N;LexicalList_prod.REMOVE_LIST_COMMAND=V;LexicalList_prod.indentList=function(){I("indent");};
    	LexicalList_prod.insertList=function(a,b){a.update(()=>{var c=h.$getSelection();if(h.$isRangeSelection(c)||h.DEPRECATED_$isGridSelection(c)){var d=c.getNodes();c=c.anchor.getNode();var e=c.getParent();if(A(c,d))d=E(b),h.$isRootOrShadowRoot(e)?(c.replace(d),e=z(),h.$isElementNode(c)&&(e.setFormat(c.getFormatType()),e.setIndent(c.getIndent())),d.append(e)):p(c)&&(c=c.getParentOrThrow(),C(d,c.getChildren()),c.replace(d));else for(c=new Set,e=0;e<d.length;e++){var f=d[e];if(h.$isElementNode(f)&&f.isEmpty()&&!c.has(f.getKey()))D(f,
    	b);else if(h.$isLeafNode(f))for(f=f.getParent();null!=f;){let l=f.getKey();if(q(f)){if(!c.has(l)){var g=E(b);C(g,f.getChildren());f.replace(g);F(g);c.add(l);}break}else {g=f.getParent();if(h.$isRootOrShadowRoot(g)&&!c.has(l)){c.add(l);D(f,b);break}f=g;}}}}});};LexicalList_prod.outdentList=function(){I("outdent");};
    	LexicalList_prod.removeList=function(a){a.update(()=>{let b=h.$getSelection();if(h.$isRangeSelection(b)){var c=new Set,d=b.getNodes(),e=b.anchor.getNode();if(A(e,d))c.add(r(e));else for(e=0;e<d.length;e++){var f=d[e];h.$isLeafNode(f)&&(f=k.$getNearestNodeOfType(f,J),null!=f&&c.add(r(f)));}for(let g of c){c=g;d=t(g);for(let l of d)d=h.$createParagraphNode(),C(d,l.getChildren()),c.insertAfter(d),c=d,l.__key===b.anchor.key&&b.anchor.set(d.getKey(),0,"element"),l.__key===b.focus.key&&b.focus.set(d.getKey(),0,"element"),
    	l.remove();g.remove();}}});};
    	return LexicalList_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalList = process.env.NODE_ENV === 'development' ? requireLexicalList_dev() : requireLexicalList_prod();
    var LexicalList_1 = LexicalList;

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalClipboard_dev;

    function requireLexicalClipboard_dev () {
    	if (hasRequiredLexicalClipboard_dev) return LexicalClipboard_dev;
    	hasRequiredLexicalClipboard_dev = 1;

    	var html = requireLexicalHtml();
    	var list = LexicalList_1;
    	var selection = requireLexicalSelection();
    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function $getHtmlContent(editor) {
    	  const selection = lexical.$getSelection();

    	  if (selection == null) {
    	    throw new Error('Expected valid LexicalSelection');
    	  } // If we haven't selected anything


    	  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    	    return '';
    	  }

    	  return html.$generateHtmlFromNodes(editor, selection);
    	} // TODO 0.6.0 Return a blank string instead
    	// TODO 0.6.0 Rename to $getJSON

    	function $getLexicalContent(editor) {
    	  const selection = lexical.$getSelection();

    	  if (selection == null) {
    	    throw new Error('Expected valid LexicalSelection');
    	  } // If we haven't selected anything


    	  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    	    return null;
    	  }

    	  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
    	}
    	function $insertDataTransferForPlainText(dataTransfer, selection) {
    	  const text = dataTransfer.getData('text/plain');

    	  if (text != null) {
    	    selection.insertRawText(text);
    	  }
    	}
    	function $insertDataTransferForRichText(dataTransfer, selection, editor) {
    	  const lexicalString = dataTransfer.getData('application/x-lexical-editor');

    	  if (lexicalString) {
    	    try {
    	      const payload = JSON.parse(lexicalString);

    	      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
    	        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
    	        return $insertGeneratedNodes(editor, nodes, selection);
    	      } // eslint-disable-next-line no-empty

    	    } catch {}
    	  }

    	  const htmlString = dataTransfer.getData('text/html');

    	  if (htmlString) {
    	    try {
    	      const parser = new DOMParser();
    	      const dom = parser.parseFromString(htmlString, 'text/html');
    	      const nodes = html.$generateNodesFromDOM(editor, dom);
    	      return $insertGeneratedNodes(editor, nodes, selection); // eslint-disable-next-line no-empty
    	    } catch {}
    	  } // Multi-line plain text in rich text mode pasted as separate paragraphs
    	  // instead of single paragraph with linebreaks.


    	  const text = dataTransfer.getData('text/plain');

    	  if (text != null) {
    	    if (lexical.$isRangeSelection(selection)) {
    	      const lines = text.split(/\r?\n/);
    	      const linesLength = lines.length;

    	      for (let i = 0; i < linesLength; i++) {
    	        selection.insertText(lines[i]);

    	        if (i < linesLength - 1) {
    	          selection.insertParagraph();
    	        }
    	      }
    	    } else {
    	      selection.insertRawText(text);
    	    }
    	  }
    	}
    	function $insertGeneratedNodes(editor, nodes, selection) {
    	  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;

    	  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {
    	    $mergeGridNodesStrategy(nodes, selection, false, editor);
    	    return;
    	  }

    	  $basicInsertStrategy(nodes, selection);
    	  return;
    	}

    	function $basicInsertStrategy(nodes, selection) {
    	  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level
    	  const topLevelBlocks = [];
    	  let currentBlock = null;
    	  let list$1 = null;

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];
    	    /**
    	     * There's no good way to add this to importDOM or importJSON directly,
    	     * so this is here in order to safely correct faulty clipboard data
    	     * that we can't control and avoid crashing the app.
    	     * https://github.com/facebook/lexical/issues/2405
    	     */

    	    if (list.$isListItemNode(node)) {
    	      if (list$1 == null) {
    	        list$1 = list.$createListNode('bullet');
    	        topLevelBlocks.push(list$1);
    	      }

    	      list$1.append(node);
    	      continue;
    	    } else if (list$1 != null) {
    	      list$1 = null;
    	    }

    	    const isLineBreakNode = lexical.$isLineBreakNode(node);

    	    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node)) {
    	      if (currentBlock === null) {
    	        currentBlock = lexical.$createParagraphNode();
    	        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to
    	        // add an empty ParagraphNode to the topLevelBlocks.

    	        if (isLineBreakNode) {
    	          continue;
    	        }
    	      }

    	      if (currentBlock !== null) {
    	        currentBlock.append(node);
    	      }
    	    } else {
    	      topLevelBlocks.push(node);
    	      currentBlock = null;
    	    }
    	  }

    	  if (lexical.$isRangeSelection(selection)) {
    	    selection.insertNodes(topLevelBlocks);
    	  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {
    	    // If there's an active grid selection and a non grid is pasted, add to the anchor.
    	    const anchorCell = selection.anchor.getNode();

    	    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {
    	      {
    	        throw Error(`Expected Grid Cell in Grid Selection`);
    	      }
    	    }

    	    anchorCell.append(...topLevelBlocks);
    	  }
    	}

    	function $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {
    	  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {
    	    {
    	      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);
    	    }
    	  }

    	  const newGrid = nodes[0];
    	  const newGridRows = newGrid.getChildren();
    	  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();
    	  const newRowCount = newGrid.getChildrenSize();
    	  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));
    	  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));
    	  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));

    	  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {
    	    {
    	      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);
    	    }
    	  }

    	  const startY = gridRowNode.getIndexWithinParent();
    	  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);
    	  const startX = gridCellNode.getIndexWithinParent();
    	  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);
    	  const fromX = Math.min(startX, stopX);
    	  const fromY = Math.min(startY, stopY);
    	  const toX = Math.max(startX, stopX);
    	  const toY = Math.max(startY, stopY);
    	  const gridRowNodes = gridNode.getChildren();
    	  let newRowIdx = 0;
    	  let newAnchorCellKey;
    	  let newFocusCellKey;

    	  for (let r = fromY; r <= toY; r++) {
    	    const currentGridRowNode = gridRowNodes[r];

    	    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {
    	      {
    	        throw Error(`getNodes: expected to find GridRowNode`);
    	      }
    	    }

    	    const newGridRowNode = newGridRows[newRowIdx];

    	    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {
    	      {
    	        throw Error(`getNodes: expected to find GridRowNode`);
    	      }
    	    }

    	    const gridCellNodes = currentGridRowNode.getChildren();
    	    const newGridCellNodes = newGridRowNode.getChildren();
    	    let newColumnIdx = 0;

    	    for (let c = fromX; c <= toX; c++) {
    	      const currentGridCellNode = gridCellNodes[c];

    	      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {
    	        {
    	          throw Error(`getNodes: expected to find GridCellNode`);
    	        }
    	      }

    	      const newGridCellNode = newGridCellNodes[newColumnIdx];

    	      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {
    	        {
    	          throw Error(`getNodes: expected to find GridCellNode`);
    	        }
    	      }

    	      if (r === fromY && c === fromX) {
    	        newAnchorCellKey = currentGridCellNode.getKey();
    	      } else if (r === toY && c === toX) {
    	        newFocusCellKey = currentGridCellNode.getKey();
    	      }

    	      const originalChildren = currentGridCellNode.getChildren();
    	      newGridCellNode.getChildren().forEach(child => {
    	        if (lexical.$isTextNode(child)) {
    	          const paragraphNode = lexical.$createParagraphNode();
    	          paragraphNode.append(child);
    	          currentGridCellNode.append(child);
    	        } else {
    	          currentGridCellNode.append(child);
    	        }
    	      });
    	      originalChildren.forEach(n => n.remove());
    	      newColumnIdx++;
    	    }

    	    newRowIdx++;
    	  }

    	  if (newAnchorCellKey && newFocusCellKey) {
    	    const newGridSelection = lexical.DEPRECATED_$createGridSelection();
    	    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);
    	    lexical.$setSelection(newGridSelection);
    	    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);
    	  }
    	}

    	function exportNodeToJSON(node) {
    	  const serializedNode = node.exportJSON();
    	  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType

    	  if (serializedNode.type !== nodeClass.getType()) {
    	    {
    	      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    	    }
    	  } // @ts-expect-error TODO Replace Class utility type with InstanceType


    	  const serializedChildren = serializedNode.children;

    	  if (lexical.$isElementNode(node)) {
    	    if (!Array.isArray(serializedChildren)) {
    	      {
    	        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
    	      }
    	    }
    	  }

    	  return serializedNode;
    	}

    	function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {
    	  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;
    	  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');
    	  let target = currentNode;

    	  if (selection$1 !== null) {
    	    let clone = selection.$cloneWithProperties(currentNode);
    	    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
    	    target = clone;
    	  }

    	  const children = lexical.$isElementNode(target) ? target.getChildren() : [];
    	  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method
    	  // which uses getLatest() to get the text from the original node with the same key.
    	  // This is a deeper issue with the word "clone" here, it's still a reference to the
    	  // same node as far as the LexicalEditor is concerned since it shares a key.
    	  // We need a way to create a clone of a Node in memory with it's own key, but
    	  // until then this hack will work for the selected text extract use case.

    	  if (lexical.$isTextNode(target)) {
    	    serializedNode.text = target.__text;
    	  }

    	  for (let i = 0; i < children.length; i++) {
    	    const childNode = children[i];
    	    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);

    	    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {
    	      shouldInclude = true;
    	    }
    	  }

    	  if (shouldInclude && !shouldExclude) {
    	    targetArray.push(serializedNode);
    	  } else if (Array.isArray(serializedNode.children)) {
    	    for (let i = 0; i < serializedNode.children.length; i++) {
    	      const serializedChildNode = serializedNode.children[i];
    	      targetArray.push(serializedChildNode);
    	    }
    	  }

    	  return shouldInclude;
    	} // TODO why $ function with Editor instance?


    	function $generateJSONFromSelectedNodes(editor, selection) {
    	  const nodes = [];
    	  const root = lexical.$getRoot();
    	  const topLevelChildren = root.getChildren();

    	  for (let i = 0; i < topLevelChildren.length; i++) {
    	    const topLevelNode = topLevelChildren[i];
    	    $appendNodesToJSON(editor, selection, topLevelNode, nodes);
    	  }

    	  return {
    	    namespace: editor._config.namespace,
    	    nodes
    	  };
    	}
    	function $generateNodesFromSerializedNodes(serializedNodes) {
    	  const nodes = [];

    	  for (let i = 0; i < serializedNodes.length; i++) {
    	    const serializedNode = serializedNodes[i];
    	    const node = lexical.$parseSerializedNode(serializedNode);

    	    if (lexical.$isTextNode(node)) {
    	      selection.$addNodeStyle(node);
    	    }

    	    nodes.push(node);
    	  }

    	  return nodes;
    	}
    	const EVENT_LATENCY = 50;
    	let clipboardEventTimeout = null; // TODO custom selection
    	// TODO potentially have a node customizable version for plain text

    	async function copyToClipboard__EXPERIMENTAL(editor, event) {
    	  if (clipboardEventTimeout !== null) {
    	    // Prevent weird race conditions that can happen when this function is run multiple times
    	    // synchronously. In the future, we can do better, we can cancel/override the previously running job.
    	    return false;
    	  }

    	  if (event !== null) {
    	    return new Promise((resolve, reject) => {
    	      editor.update(() => {
    	        resolve($copyToClipboardEvent(editor, event));
    	      });
    	    });
    	  }

    	  const rootElement = editor.getRootElement();
    	  const domSelection = document.getSelection();

    	  if (rootElement === null || domSelection === null) {
    	    return false;
    	  }

    	  const element = document.createElement('span');
    	  element.style.cssText = 'position: fixed; top: -1000px;';
    	  element.append(document.createTextNode('#'));
    	  rootElement.append(element);
    	  const range = new Range();
    	  range.setStart(element, 0);
    	  range.setEnd(element, 1);
    	  domSelection.removeAllRanges();
    	  domSelection.addRange(range);
    	  return new Promise((resolve, reject) => {
    	    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {
    	      if (secondEvent instanceof ClipboardEvent) {
    	        removeListener();

    	        if (clipboardEventTimeout !== null) {
    	          window.clearTimeout(clipboardEventTimeout);
    	          clipboardEventTimeout = null;
    	        }

    	        resolve($copyToClipboardEvent(editor, secondEvent));
    	      } // Block the entire copy flow while we wait for the next ClipboardEvent


    	      return true;
    	    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,
    	    // the listener will be quickly freed so that the user can reuse it again

    	    clipboardEventTimeout = window.setTimeout(() => {
    	      removeListener();
    	      clipboardEventTimeout = null;
    	      resolve(false);
    	    }, EVENT_LATENCY);
    	    document.execCommand('copy');
    	    element.remove();
    	  });
    	} // TODO shouldn't pass editor (pass namespace directly)

    	function $copyToClipboardEvent(editor, event) {
    	  event.preventDefault();
    	  const clipboardData = event.clipboardData;

    	  if (clipboardData === null) {
    	    return false;
    	  }

    	  const selection = lexical.$getSelection();
    	  const htmlString = $getHtmlContent(editor);
    	  const lexicalString = $getLexicalContent(editor);
    	  let plainString = '';

    	  if (selection !== null) {
    	    plainString = selection.getTextContent();
    	  }

    	  if (htmlString !== null) {
    	    clipboardData.setData('text/html', htmlString);
    	  }

    	  if (lexicalString !== null) {
    	    clipboardData.setData('application/x-lexical-editor', lexicalString);
    	  }

    	  clipboardData.setData('text/plain', plainString);
    	  return true;
    	}

    	LexicalClipboard_dev.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;
    	LexicalClipboard_dev.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;
    	LexicalClipboard_dev.$getHtmlContent = $getHtmlContent;
    	LexicalClipboard_dev.$getLexicalContent = $getLexicalContent;
    	LexicalClipboard_dev.$insertDataTransferForPlainText = $insertDataTransferForPlainText;
    	LexicalClipboard_dev.$insertDataTransferForRichText = $insertDataTransferForRichText;
    	LexicalClipboard_dev.$insertGeneratedNodes = $insertGeneratedNodes;
    	LexicalClipboard_dev.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;
    	return LexicalClipboard_dev;
    }

    var LexicalClipboard_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalClipboard_prod;

    function requireLexicalClipboard_prod () {
    	if (hasRequiredLexicalClipboard_prod) return LexicalClipboard_prod;
    	hasRequiredLexicalClipboard_prod = 1;
    var d=requireLexicalHtml(),n=LexicalList_1,r=requireLexicalSelection(),t=LexicalUtils_1,z=Lexical_1;function A(a){throw Error(`Minified Lexical error #${a}; visit https://lexical.dev/docs/error?code=${a} for the full message or `+"use the non-minified dev environment for full errors and additional helpful warnings.");}
    	function B(a){let b=z.$getSelection();if(null==b)throw Error("Expected valid LexicalSelection");return z.$isRangeSelection(b)&&b.isCollapsed()||0===b.getNodes().length?"":d.$generateHtmlFromNodes(a,b)}function C(a){let b=z.$getSelection();if(null==b)throw Error("Expected valid LexicalSelection");return z.$isRangeSelection(b)&&b.isCollapsed()||0===b.getNodes().length?null:JSON.stringify(D(a,b))}
    	function E(a,b,c){(z.DEPRECATED_$isGridSelection(c)||null!==t.$findMatchingParent(c.anchor.getNode(),g=>z.DEPRECATED_$isGridCellNode(g))&&null!==t.$findMatchingParent(c.focus.getNode(),g=>z.DEPRECATED_$isGridCellNode(g)))&&1===b.length&&z.DEPRECATED_$isGridNode(b[0])?F(b,c,!1,a):I(b,c);}
    	function I(a,b){let c=[],g=null,e=null;for(let k=0;k<a.length;k++){let f=a[k];if(n.$isListItemNode(f)){null==e&&(e=n.$createListNode("bullet"),c.push(e));e.append(f);continue}else null!=e&&(e=null);let h=z.$isLineBreakNode(f);if(h||z.$isDecoratorNode(f)&&f.isInline()||z.$isElementNode(f)&&f.isInline()||z.$isTextNode(f)){if(null===g&&(g=z.$createParagraphNode(),c.push(g),h))continue;null!==g&&g.append(f);}else c.push(f),g=null;}z.$isRangeSelection(b)?b.insertNodes(c):z.DEPRECATED_$isGridSelection(b)&&
    	(a=b.anchor.getNode(),z.DEPRECATED_$isGridCellNode(a)||A(41),a.append(...c));}
    	function F(a,b,c,g){1===a.length&&z.DEPRECATED_$isGridNode(a[0])||A(42);var e=a[0];a=e.getChildren();c=e.getFirstChildOrThrow().getChildrenSize();var k=e.getChildrenSize(),f=t.$findMatchingParent(b.anchor.getNode(),l=>z.DEPRECATED_$isGridCellNode(l));b=(e=f&&t.$findMatchingParent(f,l=>z.DEPRECATED_$isGridRowNode(l)))&&t.$findMatchingParent(e,l=>z.DEPRECATED_$isGridNode(l));z.DEPRECATED_$isGridCellNode(f)&&z.DEPRECATED_$isGridRowNode(e)&&z.DEPRECATED_$isGridNode(b)||A(43);var h=e.getIndexWithinParent(),
    	p=Math.min(b.getChildrenSize()-1,h+k-1);k=f.getIndexWithinParent();f=Math.min(e.getChildrenSize()-1,k+c-1);c=Math.min(k,f);e=Math.min(h,p);k=Math.max(k,f);h=Math.max(h,p);p=b.getChildren();f=0;let m,q;for(let l=e;l<=h;l++){var x=p[l];z.DEPRECATED_$isGridRowNode(x)||A(24);var y=a[f];z.DEPRECATED_$isGridRowNode(y)||A(24);x=x.getChildren();y=y.getChildren();let G=0;for(let u=c;u<=k;u++){let v=x[u];z.DEPRECATED_$isGridCellNode(v)||A(25);let H=y[G];z.DEPRECATED_$isGridCellNode(H)||A(25);l===e&&u===c?m=
    	v.getKey():l===h&&u===k&&(q=v.getKey());let N=v.getChildren();H.getChildren().forEach(w=>{z.$isTextNode(w)&&z.$createParagraphNode().append(w);v.append(w);});N.forEach(w=>w.remove());G++;}f++;}m&&q&&(a=z.DEPRECATED_$createGridSelection(),a.set(b.getKey(),m,q),z.$setSelection(a),g.dispatchCommand(z.SELECTION_CHANGE_COMMAND,void 0));}
    	function J(a,b,c,g=[]){let e=null!=b?c.isSelected():!0,k=z.$isElementNode(c)&&c.excludeFromCopy("html");var f=c;if(null!==b){var h=r.$cloneWithProperties(c);f=h=z.$isTextNode(h)&&null!=b?r.$sliceSelectedTextNodeContent(b,h):h;}let p=z.$isElementNode(f)?f.getChildren():[];var m=f;h=m.exportJSON();h.type!==m.constructor.getType()&&A(58);var q=h.children;z.$isElementNode(m)&&(Array.isArray(q)||A(59));z.$isTextNode(f)&&(h.text=f.__text);for(f=0;f<p.length;f++)m=p[f],q=J(a,b,m,h.children),!e&&z.$isElementNode(c)&&
    	q&&c.extractWithChild(m,b,"clone")&&(e=!0);if(e&&!k)g.push(h);else if(Array.isArray(h.children))for(a=0;a<h.children.length;a++)g.push(h.children[a]);return e}function D(a,b){let c=[],g=z.$getRoot().getChildren();for(let e=0;e<g.length;e++)J(a,b,g[e],c);return {namespace:a._config.namespace,nodes:c}}function K(a){let b=[];for(let c=0;c<a.length;c++){let g=z.$parseSerializedNode(a[c]);z.$isTextNode(g)&&r.$addNodeStyle(g);b.push(g);}return b}let L=null;
    	function M(a,b){b.preventDefault();b=b.clipboardData;if(null===b)return !1;let c=z.$getSelection(),g=B(a);a=C(a);let e="";null!==c&&(e=c.getTextContent());null!==g&&b.setData("text/html",g);null!==a&&b.setData("application/x-lexical-editor",a);b.setData("text/plain",e);return !0}LexicalClipboard_prod.$generateJSONFromSelectedNodes=D;LexicalClipboard_prod.$generateNodesFromSerializedNodes=K;LexicalClipboard_prod.$getHtmlContent=B;LexicalClipboard_prod.$getLexicalContent=C;
    	LexicalClipboard_prod.$insertDataTransferForPlainText=function(a,b){a=a.getData("text/plain");null!=a&&b.insertRawText(a);};
    	LexicalClipboard_prod.$insertDataTransferForRichText=function(a,b,c){var g=a.getData("application/x-lexical-editor");if(g)try{let k=JSON.parse(g);if(k.namespace===c._config.namespace&&Array.isArray(k.nodes)){let f=K(k.nodes);return E(c,f,b)}}catch{}if(g=a.getData("text/html"))try{var e=(new DOMParser).parseFromString(g,"text/html");let k=d.$generateNodesFromDOM(c,e);return E(c,k,b)}catch{}a=a.getData("text/plain");if(null!=a)if(z.$isRangeSelection(b))for(a=a.split(/\r?\n/),c=a.length,e=0;e<c;e++)b.insertText(a[e]),
    	e<c-1&&b.insertParagraph();else b.insertRawText(a);};LexicalClipboard_prod.$insertGeneratedNodes=E;
    	LexicalClipboard_prod.copyToClipboard__EXPERIMENTAL=async function(a,b){if(null!==L)return !1;if(null!==b)return new Promise(k=>{a.update(()=>{k(M(a,b));});});var c=a.getRootElement();let g=document.getSelection();if(null===c||null===g)return !1;let e=document.createElement("span");e.style.cssText="position: fixed; top: -1000px;";e.append(document.createTextNode("#"));c.append(e);c=new Range;c.setStart(e,0);c.setEnd(e,1);g.removeAllRanges();g.addRange(c);return new Promise(k=>{let f=a.registerCommand(z.COPY_COMMAND,
    	h=>{h instanceof ClipboardEvent&&(f(),null!==L&&(window.clearTimeout(L),L=null),k(M(a,h)));return !0},z.COMMAND_PRIORITY_CRITICAL);L=window.setTimeout(()=>{f();L=null;k(!1);},50);document.execCommand("copy");e.remove();})};
    	return LexicalClipboard_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var LexicalClipboard_1;
    var hasRequiredLexicalClipboard;

    function requireLexicalClipboard () {
    	if (hasRequiredLexicalClipboard) return LexicalClipboard_1;
    	hasRequiredLexicalClipboard = 1;
    	const LexicalClipboard = process.env.NODE_ENV === 'development' ? requireLexicalClipboard_dev() : requireLexicalClipboard_prod();
    	LexicalClipboard_1 = LexicalClipboard;
    	return LexicalClipboard_1;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalPlainText_dev;

    function requireLexicalPlainText_dev () {
    	if (hasRequiredLexicalPlainText_dev) return LexicalPlainText_dev;
    	hasRequiredLexicalPlainText_dev = 1;

    	var clipboard = requireLexicalClipboard();
    	var selection = requireLexicalSelection();
    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;
    	const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;
    	const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    	const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.

    	/** @module @lexical/plain-text */

    	function onCopyForPlainText(event, editor) {
    	  editor.update(() => {
    	    const clipboardData = event instanceof KeyboardEvent ? null : event.clipboardData;
    	    const selection = lexical.$getSelection();

    	    if (selection !== null && clipboardData != null) {
    	      event.preventDefault();
    	      const htmlString = clipboard.$getHtmlContent(editor);

    	      if (htmlString !== null) {
    	        clipboardData.setData('text/html', htmlString);
    	      }

    	      clipboardData.setData('text/plain', selection.getTextContent());
    	    }
    	  });
    	}

    	function onPasteForPlainText(event, editor) {
    	  event.preventDefault();
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();
    	    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;

    	    if (clipboardData != null && lexical.$isRangeSelection(selection)) {
    	      clipboard.$insertDataTransferForPlainText(clipboardData, selection);
    	    }
    	  }, {
    	    tag: 'paste'
    	  });
    	}

    	function onCutForPlainText(event, editor) {
    	  onCopyForPlainText(event, editor);
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection)) {
    	      selection.removeText();
    	    }
    	  });
    	}

    	function registerPlainText(editor) {
    	  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteCharacter(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteWord(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteLine(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    if (typeof eventOrText === 'string') {
    	      selection.insertText(eventOrText);
    	    } else {
    	      const dataTransfer = eventOrText.dataTransfer;

    	      if (dataTransfer != null) {
    	        clipboard.$insertDataTransferForPlainText(dataTransfer, selection);
    	      } else {
    	        const data = eventOrText.data;

    	        if (data) {
    	          selection.insertText(data);
    	        }
    	      }
    	    }

    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.removeText();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.insertLineBreak(selectStart);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.insertLineBreak();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, payload => {
    	    const selection$1 = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection$1)) {
    	      return false;
    	    }

    	    const event = payload;
    	    const isHoldingShift = event.shiftKey;

    	    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
    	      event.preventDefault();
    	      selection.$moveCharacter(selection$1, isHoldingShift, true);
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, payload => {
    	    const selection$1 = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection$1)) {
    	      return false;
    	    }

    	    const event = payload;
    	    const isHoldingShift = event.shiftKey;

    	    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
    	      event.preventDefault();
    	      selection.$moveCharacter(selection$1, isHoldingShift, false);
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    event.preventDefault();
    	    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    event.preventDefault();
    	    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    if (event !== null) {
    	      // If we have beforeinput, then we can avoid blocking
    	      // the default behavior. This ensures that the iOS can
    	      // intercept that we're actually inserting a paragraph,
    	      // and autocomplete, autocapitalize etc work as intended.
    	      // This can also cause a strange performance issue in
    	      // Safari, where there is a noticeable pause due to
    	      // preventing the key down of enter.
    	      if ((IS_IOS || IS_SAFARI) && CAN_USE_BEFORE_INPUT) {
    	        return false;
    	      }

    	      event.preventDefault();
    	    }

    	    return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    onCopyForPlainText(event, editor);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    onCutForPlainText(event, editor);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    onPasteForPlainText(event, editor);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    } // TODO: Make drag and drop work at some point.


    	    event.preventDefault();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    } // TODO: Make drag and drop work at some point.


    	    event.preventDefault();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR));
    	  return removeListener;
    	}

    	LexicalPlainText_dev.registerPlainText = registerPlainText;
    	return LexicalPlainText_dev;
    }

    var LexicalPlainText_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalPlainText_prod;

    function requireLexicalPlainText_prod () {
    	if (hasRequiredLexicalPlainText_prod) return LexicalPlainText_prod;
    	hasRequiredLexicalPlainText_prod = 1;
    var a=requireLexicalClipboard(),f=requireLexicalSelection(),g=LexicalUtils_1,h=Lexical_1;let k="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,m=k&&"documentMode"in document?document.documentMode:null;	let n=k&&"InputEvent"in window&&!m?"getTargetRanges"in new window.InputEvent("input"):!1,p=k&&/Version\/[\d.]+.*Safari/.test(navigator.userAgent),q=k&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;	function r(d,b){b.update(()=>{let c=d instanceof KeyboardEvent?null:d.clipboardData,e=h.$getSelection();if(null!==e&&null!=c){d.preventDefault();let l=a.$getHtmlContent(b);null!==l&&c.setData("text/html",l);c.setData("text/plain",e.getTextContent());}});}function t(d,b){d.preventDefault();b.update(()=>{let c=h.$getSelection(),e=d instanceof InputEvent||d instanceof KeyboardEvent?null:d.clipboardData;null!=e&&h.$isRangeSelection(c)&&a.$insertDataTransferForPlainText(e,c);},{tag:"paste"});}
    	function u(d,b){r(d,b);b.update(()=>{let c=h.$getSelection();h.$isRangeSelection(c)&&c.removeText();});}
    	LexicalPlainText_prod.registerPlainText=function(d){return g.mergeRegister(d.registerCommand(h.DELETE_CHARACTER_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;c.deleteCharacter(b);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.DELETE_WORD_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;c.deleteWord(b);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.DELETE_LINE_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;c.deleteLine(b);
    	return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.CONTROLLED_TEXT_INSERTION_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;if("string"===typeof b)c.insertText(b);else {const e=b.dataTransfer;null!=e?a.$insertDataTransferForPlainText(e,c):(b=b.data)&&c.insertText(b);}return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.REMOVE_TEXT_COMMAND,()=>{const b=h.$getSelection();if(!h.$isRangeSelection(b))return !1;b.removeText();return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.INSERT_LINE_BREAK_COMMAND,
    	b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;c.insertLineBreak(b);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.INSERT_PARAGRAPH_COMMAND,()=>{const b=h.$getSelection();if(!h.$isRangeSelection(b))return !1;b.insertLineBreak();return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.KEY_ARROW_LEFT_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;const e=b.shiftKey;return f.$shouldOverrideDefaultCharacterSelection(c,!0)?(b.preventDefault(),f.$moveCharacter(c,
    	e,!0),!0):!1},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.KEY_ARROW_RIGHT_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;const e=b.shiftKey;return f.$shouldOverrideDefaultCharacterSelection(c,!1)?(b.preventDefault(),f.$moveCharacter(c,e,!1),!0):!1},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.KEY_BACKSPACE_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;b.preventDefault();return d.dispatchCommand(h.DELETE_CHARACTER_COMMAND,!0)},h.COMMAND_PRIORITY_EDITOR),
    	d.registerCommand(h.KEY_DELETE_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;b.preventDefault();return d.dispatchCommand(h.DELETE_CHARACTER_COMMAND,!1)},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.KEY_ENTER_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;if(null!==b){if((q||p)&&n)return !1;b.preventDefault();}return d.dispatchCommand(h.INSERT_LINE_BREAK_COMMAND,!1)},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.COPY_COMMAND,b=>{const c=h.$getSelection();
    	if(!h.$isRangeSelection(c))return !1;r(b,d);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.CUT_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;u(b,d);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.PASTE_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;t(b,d);return !0},h.COMMAND_PRIORITY_EDITOR),d.registerCommand(h.DROP_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;b.preventDefault();return !0},h.COMMAND_PRIORITY_EDITOR),
    	d.registerCommand(h.DRAGSTART_COMMAND,b=>{const c=h.$getSelection();if(!h.$isRangeSelection(c))return !1;b.preventDefault();return !0},h.COMMAND_PRIORITY_EDITOR))};
    	return LexicalPlainText_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalPlainText = process.env.NODE_ENV === 'development' ? requireLexicalPlainText_dev() : requireLexicalPlainText_prod();
    var LexicalPlainText_1 = LexicalPlainText;

    /* src/core/plugins/PlainTextPlugin.svelte generated by Svelte v3.55.1 */

    function instance$B($$self) {
    	const editor = getContext('editor');

    	// returns callback to unregister
    	onMount(() => LexicalPlainText_1.registerPlainText(editor));

    	return [];
    }

    class PlainTextPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$B, null, safe_not_equal, {});
    	}
    }

    var LexicalRichText_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalRichText_dev;

    function requireLexicalRichText_dev () {
    	if (hasRequiredLexicalRichText_dev) return LexicalRichText_dev;
    	hasRequiredLexicalRichText_dev = 1;

    	var clipboard = requireLexicalClipboard();
    	var selection = requireLexicalSelection();
    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function caretFromPoint(x, y) {
    	  if (typeof document.caretRangeFromPoint !== 'undefined') {
    	    const range = document.caretRangeFromPoint(x, y);

    	    if (range === null) {
    	      return null;
    	    }

    	    return {
    	      node: range.startContainer,
    	      offset: range.startOffset
    	    }; // @ts-ignore
    	  } else if (document.caretPositionFromPoint !== 'undefined') {
    	    // @ts-ignore FF - no types
    	    const range = document.caretPositionFromPoint(x, y);

    	    if (range === null) {
    	      return null;
    	    }

    	    return {
    	      node: range.offsetNode,
    	      offset: range.offset
    	    };
    	  } else {
    	    // Gracefully handle IE
    	    return null;
    	  }
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;
    	const CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;
    	const IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    	const IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.

    	/** @module @lexical/rich-text */
    	const DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');

    	/** @noInheritDoc */
    	class QuoteNode extends lexical.ElementNode {
    	  static getType() {
    	    return 'quote';
    	  }

    	  static clone(node) {
    	    return new QuoteNode(node.__key);
    	  }

    	  constructor(key) {
    	    super(key);
    	  } // View


    	  createDOM(config) {
    	    const element = document.createElement('blockquote');
    	    utils.addClassNamesToElement(element, config.theme.quote);
    	    return element;
    	  }

    	  updateDOM(prevNode, dom) {
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      blockquote: node => ({
    	        conversion: convertBlockquoteElement,
    	        priority: 0
    	      })
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createQuoteNode();
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      type: 'quote'
    	    };
    	  } // Mutation


    	  insertNewAfter(_, restoreSelection) {
    	    const newBlock = lexical.$createParagraphNode();
    	    const direction = this.getDirection();
    	    newBlock.setDirection(direction);
    	    this.insertAfter(newBlock, restoreSelection);
    	    return newBlock;
    	  }

    	  collapseAtStart() {
    	    const paragraph = lexical.$createParagraphNode();
    	    const children = this.getChildren();
    	    children.forEach(child => paragraph.append(child));
    	    this.replace(paragraph);
    	    return true;
    	  }

    	}
    	function $createQuoteNode() {
    	  return lexical.$applyNodeReplacement(new QuoteNode());
    	}
    	function $isQuoteNode(node) {
    	  return node instanceof QuoteNode;
    	}

    	/** @noInheritDoc */
    	class HeadingNode extends lexical.ElementNode {
    	  /** @internal */
    	  static getType() {
    	    return 'heading';
    	  }

    	  static clone(node) {
    	    return new HeadingNode(node.__tag, node.__key);
    	  }

    	  constructor(tag, key) {
    	    super(key);
    	    this.__tag = tag;
    	  }

    	  getTag() {
    	    return this.__tag;
    	  } // View


    	  createDOM(config) {
    	    const tag = this.__tag;
    	    const element = document.createElement(tag);
    	    const theme = config.theme;
    	    const classNames = theme.heading;

    	    if (classNames !== undefined) {
    	      const className = classNames[tag];
    	      utils.addClassNamesToElement(element, className);
    	    }

    	    return element;
    	  }

    	  updateDOM(prevNode, dom) {
    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      h1: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      h2: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      h3: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      h4: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      h5: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      h6: node => ({
    	        conversion: convertHeadingElement,
    	        priority: 0
    	      }),
    	      p: node => {
    	        // domNode is a <p> since we matched it by nodeName
    	        const paragraph = node;
    	        const firstChild = paragraph.firstChild;

    	        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
    	          return {
    	            conversion: () => ({
    	              node: null
    	            }),
    	            priority: 3
    	          };
    	        }

    	        return null;
    	      },
    	      span: node => {
    	        if (isGoogleDocsTitle(node)) {
    	          return {
    	            conversion: domNode => {
    	              return {
    	                node: $createHeadingNode('h1')
    	              };
    	            },
    	            priority: 3
    	          };
    	        }

    	        return null;
    	      }
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createHeadingNode(serializedNode.tag);
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      tag: this.getTag(),
    	      type: 'heading',
    	      version: 1
    	    };
    	  } // Mutation


    	  insertNewAfter(selection, restoreSelection = true) {
    	    const anchorOffet = selection ? selection.anchor.offset : 0;
    	    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
    	    const direction = this.getDirection();
    	    newElement.setDirection(direction);
    	    this.insertAfter(newElement, restoreSelection);
    	    return newElement;
    	  }

    	  collapseAtStart() {
    	    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
    	    const children = this.getChildren();
    	    children.forEach(child => newElement.append(child));
    	    this.replace(newElement);
    	    return true;
    	  }

    	  extractWithChild() {
    	    return true;
    	  }

    	}

    	function isGoogleDocsTitle(domNode) {
    	  if (domNode.nodeName.toLowerCase() === 'span') {
    	    return domNode.style.fontSize === '26pt';
    	  }

    	  return false;
    	}

    	function convertHeadingElement(domNode) {
    	  const nodeName = domNode.nodeName.toLowerCase();
    	  let node = null;

    	  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {
    	    node = $createHeadingNode(nodeName);
    	  }

    	  return {
    	    node
    	  };
    	}

    	function convertBlockquoteElement() {
    	  const node = $createQuoteNode();
    	  return {
    	    node
    	  };
    	}

    	function $createHeadingNode(headingTag) {
    	  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));
    	}
    	function $isHeadingNode(node) {
    	  return node instanceof HeadingNode;
    	}

    	function onPasteForRichText(event, editor) {
    	  event.preventDefault();
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();
    	    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;

    	    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {
    	      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);
    	    }
    	  }, {
    	    tag: 'paste'
    	  });
    	}

    	async function onCutForRichText(event, editor) {
    	  await clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
    	  editor.update(() => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection)) {
    	      selection.removeText();
    	    } else if (lexical.$isNodeSelection(selection)) {
    	      selection.getNodes().forEach(node => node.remove());
    	    }
    	  });
    	} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,
    	// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We
    	// control this with the first boolean flag.


    	function eventFiles(event) {
    	  let dataTransfer = null;

    	  if (event instanceof DragEvent) {
    	    dataTransfer = event.dataTransfer;
    	  } else if (event instanceof ClipboardEvent) {
    	    dataTransfer = event.clipboardData;
    	  }

    	  if (dataTransfer === null) {
    	    return [false, [], false];
    	  }

    	  const types = dataTransfer.types;
    	  const hasFiles = types.includes('Files');
    	  const hasContent = types.includes('text/html') || types.includes('text/plain');
    	  return [hasFiles, Array.from(dataTransfer.files), hasContent];
    	}

    	function handleIndentAndOutdent(insertTab, indentOrOutdent) {
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection)) {
    	    return;
    	  }

    	  const alreadyHandled = new Set();
    	  const nodes = selection.getNodes();

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];
    	    const key = node.getKey();

    	    if (alreadyHandled.has(key)) {
    	      continue;
    	    }

    	    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);
    	    const parentKey = parentBlock.getKey();

    	    if (parentBlock.canInsertTab()) {
    	      insertTab(node);
    	      alreadyHandled.add(key);
    	    } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
    	      alreadyHandled.add(parentKey);
    	      indentOrOutdent(parentBlock);
    	    }
    	  }
    	}

    	function $isTargetWithinDecorator(target) {
    	  const node = lexical.$getNearestNodeFromDOMNode(target);
    	  return lexical.$isDecoratorNode(node);
    	}

    	function $isSelectionAtEndOfRoot(selection) {
    	  const focus = selection.focus;
    	  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();
    	}

    	function registerRichText(editor) {
    	  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isNodeSelection(selection)) {
    	      selection.clear();
    	      return true;
    	    }

    	    return false;
    	  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteCharacter(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteWord(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.deleteLine(isBackward);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {
    	    const selection = lexical.$getSelection();

    	    if (typeof eventOrText === 'string') {
    	      if (lexical.$isRangeSelection(selection)) {
    	        selection.insertText(eventOrText);
    	      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;
    	    } else {
    	      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {
    	        return false;
    	      }

    	      const dataTransfer = eventOrText.dataTransfer;

    	      if (dataTransfer != null) {
    	        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);
    	      } else if (lexical.$isRangeSelection(selection)) {
    	        const data = eventOrText.data;

    	        if (data) {
    	          selection.insertText(data);
    	        }

    	        return true;
    	      }
    	    }

    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.removeText();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.formatText(format);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {
    	      return false;
    	    }

    	    const nodes = selection.getNodes();

    	    for (const node of nodes) {
    	      const element = utils.$getNearestBlockElementAncestorOrThrow(node);
    	      element.setFormat(format);
    	    }

    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.insertLineBreak(selectStart);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    selection.insertParagraph();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {
    	    handleIndentAndOutdent(() => {
    	      editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, '\t');
    	    }, block => {
    	      const indent = block.getIndent();

    	      if (indent !== 10) {
    	        block.setIndent(indent + 1);
    	      }
    	    });
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {
    	    handleIndentAndOutdent(node => {
    	      if (lexical.$isTextNode(node)) {
    	        const textContent = node.getTextContent();
    	        const character = textContent[textContent.length - 1];

    	        if (character === '\t') {
    	          editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
    	        }
    	      }
    	    }, block => {
    	      const indent = block.getIndent();

    	      if (indent !== 0) {
    	        block.setIndent(indent - 1);
    	      }
    	    });
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {
    	      // If selection is on a node, let's try and move selection
    	      // back to being a range selection.
    	      const nodes = selection.getNodes();

    	      if (nodes.length > 0) {
    	        nodes[0].selectPrevious();
    	        return true;
    	      }
    	    } else if (lexical.$isRangeSelection(selection)) {
    	      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);

    	      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
    	        possibleNode.selectPrevious();
    	        event.preventDefault();
    	        return true;
    	      } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
    	        possibleNode.select();
    	        event.preventDefault();
    	        return true;
    	      }
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (lexical.$isNodeSelection(selection)) {
    	      // If selection is on a node, let's try and move selection
    	      // back to being a range selection.
    	      const nodes = selection.getNodes();

    	      if (nodes.length > 0) {
    	        nodes[0].selectNext(0, 0);
    	        return true;
    	      }
    	    } else if (lexical.$isRangeSelection(selection)) {
    	      if ($isSelectionAtEndOfRoot(selection)) {
    	        event.preventDefault();
    	        return true;
    	      }

    	      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);

    	      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
    	        possibleNode.selectNext();
    	        event.preventDefault();
    	        return true;
    	      }
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {
    	    const selection$1 = lexical.$getSelection();

    	    if (lexical.$isNodeSelection(selection$1)) {
    	      // If selection is on a node, let's try and move selection
    	      // back to being a range selection.
    	      const nodes = selection$1.getNodes();

    	      if (nodes.length > 0) {
    	        event.preventDefault();
    	        nodes[0].selectPrevious();
    	        return true;
    	      }
    	    }

    	    if (!lexical.$isRangeSelection(selection$1)) {
    	      return false;
    	    }

    	    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
    	      const isHoldingShift = event.shiftKey;
    	      event.preventDefault();
    	      selection.$moveCharacter(selection$1, isHoldingShift, true);
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {
    	    const selection$1 = lexical.$getSelection();

    	    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {
    	      // If selection is on a node, let's try and move selection
    	      // back to being a range selection.
    	      const nodes = selection$1.getNodes();

    	      if (nodes.length > 0) {
    	        event.preventDefault();
    	        nodes[0].selectNext(0, 0);
    	        return true;
    	      }
    	    }

    	    if (!lexical.$isRangeSelection(selection$1)) {
    	      return false;
    	    }

    	    const isHoldingShift = event.shiftKey;

    	    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
    	      event.preventDefault();
    	      selection.$moveCharacter(selection$1, isHoldingShift, false);
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {
    	    if ($isTargetWithinDecorator(event.target)) {
    	      return false;
    	    }

    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    event.preventDefault();
    	    const {
    	      anchor
    	    } = selection;
    	    const anchorNode = anchor.getNode();

    	    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {
    	      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);

    	      if (element.getIndent() > 0) {
    	        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);
    	      }
    	    }

    	    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {
    	    if ($isTargetWithinDecorator(event.target)) {
    	      return false;
    	    }

    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    event.preventDefault();
    	    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    if (event !== null) {
    	      // If we have beforeinput, then we can avoid blocking
    	      // the default behavior. This ensures that the iOS can
    	      // intercept that we're actually inserting a paragraph,
    	      // and autocomplete, autocapitalize etc work as intended.
    	      // This can also cause a strange performance issue in
    	      // Safari, where there is a noticeable pause due to
    	      // preventing the key down of enter.
    	      if ((IS_IOS || IS_SAFARI) && CAN_USE_BEFORE_INPUT) {
    	        return false;
    	      }

    	      event.preventDefault();

    	      if (event.shiftKey) {
    	        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
    	      }
    	    }

    	    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    editor.blur();
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {
    	    const [, files] = eventFiles(event);

    	    if (files.length > 0) {
    	      const x = event.clientX;
    	      const y = event.clientY;
    	      const eventRange = caretFromPoint(x, y);

    	      if (eventRange !== null) {
    	        const {
    	          offset: domOffset,
    	          node: domNode
    	        } = eventRange;
    	        const node = lexical.$getNearestNodeFromDOMNode(domNode);

    	        if (node !== null) {
    	          const selection = lexical.$createRangeSelection();

    	          if (lexical.$isTextNode(node)) {
    	            selection.anchor.set(node.getKey(), domOffset, 'text');
    	            selection.focus.set(node.getKey(), domOffset, 'text');
    	          } else {
    	            const parentKey = node.getParentOrThrow().getKey();
    	            const offset = node.getIndexWithinParent() + 1;
    	            selection.anchor.set(parentKey, offset, 'element');
    	            selection.focus.set(parentKey, offset, 'element');
    	          }

    	          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);
    	          lexical.$setSelection(normalizedSelection);
    	        }

    	        editor.dispatchCommand(DRAG_DROP_PASTE, files);
    	      }

    	      event.preventDefault();
    	      return true;
    	    }

    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection)) {
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {
    	    const [isFileTransfer] = eventFiles(event);
    	    const selection = lexical.$getSelection();

    	    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {
    	    const [isFileTransfer] = eventFiles(event);
    	    const selection = lexical.$getSelection();

    	    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    const x = event.clientX;
    	    const y = event.clientY;
    	    const eventRange = caretFromPoint(x, y);

    	    if (eventRange !== null) {
    	      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);

    	      if (lexical.$isDecoratorNode(node)) {
    	        // Show browser caret as the user is dragging the media across the screen. Won't work
    	        // for DecoratorNode nor it's relevant.
    	        event.preventDefault();
    	      }
    	    }

    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {
    	    clipboard.copyToClipboard__EXPERIMENTAL(editor, event instanceof ClipboardEvent ? event : null);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {
    	    onCutForRichText(event, editor);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {
    	    const [, files, hasTextContent] = eventFiles(event);

    	    if (files.length > 0 && !hasTextContent) {
    	      editor.dispatchCommand(DRAG_DROP_PASTE, files);
    	      return true;
    	    }

    	    const selection = lexical.$getSelection();

    	    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
    	      onPasteForRichText(event, editor);
    	      return true;
    	    }

    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR));
    	  return removeListener;
    	}

    	LexicalRichText_dev.$createHeadingNode = $createHeadingNode;
    	LexicalRichText_dev.$createQuoteNode = $createQuoteNode;
    	LexicalRichText_dev.$isHeadingNode = $isHeadingNode;
    	LexicalRichText_dev.$isQuoteNode = $isQuoteNode;
    	LexicalRichText_dev.DRAG_DROP_PASTE = DRAG_DROP_PASTE;
    	LexicalRichText_dev.HeadingNode = HeadingNode;
    	LexicalRichText_dev.QuoteNode = QuoteNode;
    	LexicalRichText_dev.eventFiles = eventFiles;
    	LexicalRichText_dev.registerRichText = registerRichText;
    	return LexicalRichText_dev;
    }

    var LexicalRichText_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalRichText_prod;

    function requireLexicalRichText_prod () {
    	if (hasRequiredLexicalRichText_prod) return LexicalRichText_prod;
    	hasRequiredLexicalRichText_prod = 1;
    var a=requireLexicalClipboard(),g=requireLexicalSelection(),k=LexicalUtils_1,l=Lexical_1;function m(c,b){return "undefined"!==typeof document.caretRangeFromPoint?(c=document.caretRangeFromPoint(c,b),null===c?null:{node:c.startContainer,offset:c.startOffset}):"undefined"!==document.caretPositionFromPoint?(c=document.caretPositionFromPoint(c,b),null===c?null:{node:c.offsetNode,offset:c.offset}):null}
    	let p="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement,q=p&&"documentMode"in document?document.documentMode:null;let r=p&&"InputEvent"in window&&!q?"getTargetRanges"in new window.InputEvent("input"):!1,t=p&&/Version\/[\d.]+.*Safari/.test(navigator.userAgent),u=p&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream;
    let w=l.createCommand("DRAG_DROP_PASTE_FILE");
    	class x extends l.ElementNode{static getType(){return "quote"}static clone(c){return new x(c.__key)}constructor(c){super(c);}createDOM(c){let b=document.createElement("blockquote");k.addClassNamesToElement(b,c.theme.quote);return b}updateDOM(){return !1}static importDOM(){return {blockquote:()=>({conversion:y,priority:0})}}static importJSON(c){let b=z();b.setFormat(c.format);b.setIndent(c.indent);b.setDirection(c.direction);return b}exportJSON(){return {...super.exportJSON(),type:"quote"}}insertNewAfter(c,
    	b){c=l.$createParagraphNode();let d=this.getDirection();c.setDirection(d);this.insertAfter(c,b);return c}collapseAtStart(){let c=l.$createParagraphNode();this.getChildren().forEach(b=>c.append(b));this.replace(c);return !0}}function z(){return l.$applyNodeReplacement(new x)}
    	class A extends l.ElementNode{static getType(){return "heading"}static clone(c){return new A(c.__tag,c.__key)}constructor(c,b){super(b);this.__tag=c;}getTag(){return this.__tag}createDOM(c){let b=this.__tag,d=document.createElement(b);c=c.theme.heading;void 0!==c&&k.addClassNamesToElement(d,c[b]);return d}updateDOM(){return !1}static importDOM(){return {h1:()=>({conversion:B,priority:0}),h2:()=>({conversion:B,priority:0}),h3:()=>({conversion:B,priority:0}),h4:()=>({conversion:B,priority:0}),h5:()=>({conversion:B,
    	priority:0}),h6:()=>({conversion:B,priority:0}),p:c=>{c=c.firstChild;return null!==c&&D(c)?{conversion:()=>({node:null}),priority:3}:null},span:c=>D(c)?{conversion:()=>({node:E("h1")}),priority:3}:null}}static importJSON(c){let b=E(c.tag);b.setFormat(c.format);b.setIndent(c.indent);b.setDirection(c.direction);return b}exportJSON(){return {...super.exportJSON(),tag:this.getTag(),type:"heading",version:1}}insertNewAfter(c,b=!0){c=c?c.anchor.offset:0;c=0<c&&c<this.getTextContentSize()?E(this.getTag()):
    	l.$createParagraphNode();let d=this.getDirection();c.setDirection(d);this.insertAfter(c,b);return c}collapseAtStart(){let c=this.isEmpty()?l.$createParagraphNode():E(this.getTag());this.getChildren().forEach(b=>c.append(b));this.replace(c);return !0}extractWithChild(){return !0}}function D(c){return "span"===c.nodeName.toLowerCase()?"26pt"===c.style.fontSize:!1}function B(c){c=c.nodeName.toLowerCase();let b=null;if("h1"===c||"h2"===c||"h3"===c||"h4"===c||"h5"===c||"h6"===c)b=E(c);return {node:b}}
    	function y(){return {node:z()}}function E(c){return l.$applyNodeReplacement(new A(c))}function F(c,b){c.preventDefault();b.update(()=>{let d=l.$getSelection(),e=c instanceof InputEvent||c instanceof KeyboardEvent?null:c.clipboardData;null!=e&&(l.$isRangeSelection(d)||l.DEPRECATED_$isGridSelection(d))&&a.$insertDataTransferForRichText(e,d,b);},{tag:"paste"});}
    	async function G(c,b){await a.copyToClipboard__EXPERIMENTAL(b,c instanceof ClipboardEvent?c:null);b.update(()=>{let d=l.$getSelection();l.$isRangeSelection(d)?d.removeText():l.$isNodeSelection(d)&&d.getNodes().forEach(e=>e.remove());});}function H(c){let b=null;c instanceof DragEvent?b=c.dataTransfer:c instanceof ClipboardEvent&&(b=c.clipboardData);if(null===b)return [!1,[],!1];var d=b.types;c=d.includes("Files");d=d.includes("text/html")||d.includes("text/plain");return [c,Array.from(b.files),d]}
    	function I(c,b){var d=l.$getSelection();if(l.$isRangeSelection(d)){var e=new Set;d=d.getNodes();for(let f=0;f<d.length;f++){let n=d[f],v=n.getKey();if(e.has(v))continue;let h=k.$getNearestBlockElementAncestorOrThrow(n),C=h.getKey();h.canInsertTab()?(c(n),e.add(v)):h.canIndent()&&!e.has(C)&&(e.add(C),b(h));}}}function J(c){c=l.$getNearestNodeFromDOMNode(c);return l.$isDecoratorNode(c)}LexicalRichText_prod.$createHeadingNode=E;LexicalRichText_prod.$createQuoteNode=z;LexicalRichText_prod.$isHeadingNode=function(c){return c instanceof A};
    	LexicalRichText_prod.$isQuoteNode=function(c){return c instanceof x};LexicalRichText_prod.DRAG_DROP_PASTE=w;LexicalRichText_prod.HeadingNode=A;LexicalRichText_prod.QuoteNode=x;LexicalRichText_prod.eventFiles=H;
    	LexicalRichText_prod.registerRichText=function(c){return k.mergeRegister(c.registerCommand(l.CLICK_COMMAND,()=>{const b=l.$getSelection();return l.$isNodeSelection(b)?(b.clear(),!0):!1},0),c.registerCommand(l.DELETE_CHARACTER_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;d.deleteCharacter(b);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.DELETE_WORD_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;d.deleteWord(b);return !0},l.COMMAND_PRIORITY_EDITOR),
    	c.registerCommand(l.DELETE_LINE_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;d.deleteLine(b);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.CONTROLLED_TEXT_INSERTION_COMMAND,b=>{const d=l.$getSelection();if("string"===typeof b)l.$isRangeSelection(d)?d.insertText(b):l.DEPRECATED_$isGridSelection(d);else {if(!l.$isRangeSelection(d)&&!l.DEPRECATED_$isGridSelection(d))return !1;const e=b.dataTransfer;null!=e?a.$insertDataTransferForRichText(e,d,c):l.$isRangeSelection(d)&&
    	(b=b.data)&&d.insertText(b);}return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.REMOVE_TEXT_COMMAND,()=>{const b=l.$getSelection();if(!l.$isRangeSelection(b))return !1;b.removeText();return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.FORMAT_TEXT_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;d.formatText(b);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.FORMAT_ELEMENT_COMMAND,b=>{var d=l.$getSelection();if(!l.$isRangeSelection(d)&&!l.$isNodeSelection(d))return !1;
    	d=d.getNodes();for(const e of d)k.$getNearestBlockElementAncestorOrThrow(e).setFormat(b);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.INSERT_LINE_BREAK_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;d.insertLineBreak(b);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.INSERT_PARAGRAPH_COMMAND,()=>{const b=l.$getSelection();if(!l.$isRangeSelection(b))return !1;b.insertParagraph();return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.INDENT_CONTENT_COMMAND,
    	()=>{I(()=>{c.dispatchCommand(l.CONTROLLED_TEXT_INSERTION_COMMAND,"\t");},b=>{const d=b.getIndent();10!==d&&b.setIndent(d+1);});return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.OUTDENT_CONTENT_COMMAND,()=>{I(b=>{l.$isTextNode(b)&&(b=b.getTextContent(),"\t"===b[b.length-1]&&c.dispatchCommand(l.DELETE_CHARACTER_COMMAND,!0));},b=>{const d=b.getIndent();0!==d&&b.setIndent(d-1);});return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ARROW_UP_COMMAND,b=>{var d=l.$getSelection();if(l.$isNodeSelection(d)&&
    	!J(b.target)){if(b=d.getNodes(),0<b.length)return b[0].selectPrevious(),!0}else if(l.$isRangeSelection(d)){d=l.$getAdjacentNode(d.focus,!0);if(l.$isDecoratorNode(d)&&!d.isIsolated()&&!d.isInline())return d.selectPrevious(),b.preventDefault(),!0;if(l.$isElementNode(d)&&!d.isInline()&&!d.canBeEmpty())return d.select(),b.preventDefault(),!0}return !1},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ARROW_DOWN_COMMAND,b=>{var d=l.$getSelection();if(l.$isNodeSelection(d)){if(b=d.getNodes(),0<b.length)return b[0].selectNext(0,
    	0),!0}else if(l.$isRangeSelection(d)){let e=d.focus;if("root"===e.key&&e.offset===l.$getRoot().getChildrenSize())return b.preventDefault(),!0;d=l.$getAdjacentNode(d.focus,!1);if(l.$isDecoratorNode(d)&&!d.isIsolated()&&!d.isInline())return d.selectNext(),b.preventDefault(),!0}return !1},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ARROW_LEFT_COMMAND,b=>{const d=l.$getSelection();if(l.$isNodeSelection(d)){var e=d.getNodes();if(0<e.length)return b.preventDefault(),e[0].selectPrevious(),!0}return l.$isRangeSelection(d)?
    	g.$shouldOverrideDefaultCharacterSelection(d,!0)?(e=b.shiftKey,b.preventDefault(),g.$moveCharacter(d,e,!0),!0):!1:!1},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ARROW_RIGHT_COMMAND,b=>{const d=l.$getSelection();if(l.$isNodeSelection(d)&&!J(b.target)){var e=d.getNodes();if(0<e.length)return b.preventDefault(),e[0].selectNext(0,0),!0}if(!l.$isRangeSelection(d))return !1;e=b.shiftKey;return g.$shouldOverrideDefaultCharacterSelection(d,!1)?(b.preventDefault(),g.$moveCharacter(d,e,!1),!0):!1},l.COMMAND_PRIORITY_EDITOR),
    	c.registerCommand(l.KEY_BACKSPACE_COMMAND,b=>{if(J(b.target))return !1;const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;b.preventDefault();({anchor:b}=d);const e=b.getNode();return d.isCollapsed()&&0===b.offset&&!l.$isRootNode(e)&&0<k.$getNearestBlockElementAncestorOrThrow(e).getIndent()?c.dispatchCommand(l.OUTDENT_CONTENT_COMMAND,void 0):c.dispatchCommand(l.DELETE_CHARACTER_COMMAND,!0)},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_DELETE_COMMAND,b=>{if(J(b.target))return !1;const d=
    	l.$getSelection();if(!l.$isRangeSelection(d))return !1;b.preventDefault();return c.dispatchCommand(l.DELETE_CHARACTER_COMMAND,!1)},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ENTER_COMMAND,b=>{const d=l.$getSelection();if(!l.$isRangeSelection(d))return !1;if(null!==b){if((u||t)&&r)return !1;b.preventDefault();if(b.shiftKey)return c.dispatchCommand(l.INSERT_LINE_BREAK_COMMAND,!1)}return c.dispatchCommand(l.INSERT_PARAGRAPH_COMMAND,void 0)},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.KEY_ESCAPE_COMMAND,
    	()=>{const b=l.$getSelection();if(!l.$isRangeSelection(b))return !1;c.blur();return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.DROP_COMMAND,b=>{const [,d]=H(b);if(0<d.length){var e=m(b.clientX,b.clientY);if(null!==e){const {offset:n,node:v}=e;var f=l.$getNearestNodeFromDOMNode(v);if(null!==f){e=l.$createRangeSelection();if(l.$isTextNode(f))e.anchor.set(f.getKey(),n,"text"),e.focus.set(f.getKey(),n,"text");else {const h=f.getParentOrThrow().getKey();f=f.getIndexWithinParent()+1;e.anchor.set(h,
    	f,"element");e.focus.set(h,f,"element");}e=l.$normalizeSelection__EXPERIMENTAL(e);l.$setSelection(e);}c.dispatchCommand(w,d);}b.preventDefault();return !0}b=l.$getSelection();return l.$isRangeSelection(b)?!0:!1},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.DRAGSTART_COMMAND,b=>{[b]=H(b);const d=l.$getSelection();return b&&!l.$isRangeSelection(d)?!1:!0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.DRAGOVER_COMMAND,b=>{var [d]=H(b);const e=l.$getSelection();if(d&&!l.$isRangeSelection(e))return !1;d=
    	m(b.clientX,b.clientY);null!==d&&(d=l.$getNearestNodeFromDOMNode(d.node),l.$isDecoratorNode(d)&&b.preventDefault());return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.COPY_COMMAND,b=>{a.copyToClipboard__EXPERIMENTAL(c,b instanceof ClipboardEvent?b:null);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.CUT_COMMAND,b=>{G(b,c);return !0},l.COMMAND_PRIORITY_EDITOR),c.registerCommand(l.PASTE_COMMAND,b=>{const [,d,e]=H(b);if(0<d.length&&!e)return c.dispatchCommand(w,d),!0;const f=l.$getSelection();
    	return l.$isRangeSelection(f)||l.DEPRECATED_$isGridSelection(f)?(F(b,c),!0):!1},l.COMMAND_PRIORITY_EDITOR))};
    	return LexicalRichText_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalRichText = process.env.NODE_ENV === 'development' ? requireLexicalRichText_dev() : requireLexicalRichText_prod();
    var LexicalRichText_1 = LexicalRichText;

    /* src/core/plugins/RichTextPlugin.svelte generated by Svelte v3.55.1 */

    function instance$A($$self) {
    	const editor = getContext('editor');

    	// returns callback to unregister
    	onMount(() => LexicalRichText_1.registerRichText(editor));

    	return [];
    }

    class RichTextPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$A, null, safe_not_equal, {});
    	}
    }

    var LexicalHistory_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalHistory_dev;

    function requireLexicalHistory_dev () {
    	if (hasRequiredLexicalHistory_dev) return LexicalHistory_dev;
    	hasRequiredLexicalHistory_dev = 1;

    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/** @module @lexical/history */
    	const HISTORY_MERGE = 0;
    	const HISTORY_PUSH = 1;
    	const DISCARD_HISTORY_CANDIDATE = 2;
    	const OTHER = 0;
    	const COMPOSING_CHARACTER = 1;
    	const INSERT_CHARACTER_AFTER_SELECTION = 2;
    	const DELETE_CHARACTER_BEFORE_SELECTION = 3;
    	const DELETE_CHARACTER_AFTER_SELECTION = 4;

    	function getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {
    	  const nodeMap = editorState._nodeMap;
    	  const nodes = [];

    	  for (const dirtyLeafKey of dirtyLeaves) {
    	    const dirtyLeaf = nodeMap.get(dirtyLeafKey);

    	    if (dirtyLeaf !== undefined) {
    	      nodes.push(dirtyLeaf);
    	    }
    	  }

    	  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {
    	    if (!intentionallyMarkedAsDirty) {
    	      continue;
    	    }

    	    const dirtyElement = nodeMap.get(dirtyElementKey);

    	    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {
    	      nodes.push(dirtyElement);
    	    }
    	  }

    	  return nodes;
    	}

    	function getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {
    	  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {
    	    return OTHER;
    	  }

    	  const nextSelection = nextEditorState._selection;
    	  const prevSelection = prevEditorState._selection;

    	  if (isComposing) {
    	    return COMPOSING_CHARACTER;
    	  }

    	  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {
    	    return OTHER;
    	  }

    	  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);

    	  if (dirtyNodes.length === 0) {
    	    return OTHER;
    	  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),
    	  // or after existing node.


    	  if (dirtyNodes.length > 1) {
    	    const nextNodeMap = nextEditorState._nodeMap;
    	    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);
    	    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);

    	    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {
    	      return INSERT_CHARACTER_AFTER_SELECTION;
    	    }

    	    return OTHER;
    	  }

    	  const nextDirtyNode = dirtyNodes[0];

    	  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);

    	  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {
    	    return OTHER;
    	  }

    	  const prevText = prevDirtyNode.__text;
    	  const nextText = nextDirtyNode.__text;

    	  if (prevText === nextText) {
    	    return OTHER;
    	  }

    	  const nextAnchor = nextSelection.anchor;
    	  const prevAnchor = prevSelection.anchor;

    	  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {
    	    return OTHER;
    	  }

    	  const nextAnchorOffset = nextAnchor.offset;
    	  const prevAnchorOffset = prevAnchor.offset;
    	  const textDiff = nextText.length - prevText.length;

    	  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {
    	    return INSERT_CHARACTER_AFTER_SELECTION;
    	  }

    	  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {
    	    return DELETE_CHARACTER_BEFORE_SELECTION;
    	  }

    	  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {
    	    return DELETE_CHARACTER_AFTER_SELECTION;
    	  }

    	  return OTHER;
    	}

    	function isTextNodeUnchanged(key, prevEditorState, nextEditorState) {
    	  const prevNode = prevEditorState._nodeMap.get(key);

    	  const nextNode = nextEditorState._nodeMap.get(key);

    	  if (lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {
    	    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;
    	  }

    	  return false;
    	}

    	function createMergeActionGetter(editor, delay) {
    	  let prevChangeTime = Date.now();
    	  let prevChangeType = OTHER;
    	  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {
    	    const changeTime = Date.now(); // If applying changes from history stack there's no need
    	    // to run history logic again, as history entries already calculated

    	    if (tags.has('historic')) {
    	      prevChangeType = OTHER;
    	      prevChangeTime = changeTime;
    	      return DISCARD_HISTORY_CANDIDATE;
    	    }

    	    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());

    	    const mergeAction = (() => {
    	      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;
    	      const shouldPushHistory = tags.has('history-push');
    	      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');

    	      if (shouldMergeHistory) {
    	        return HISTORY_MERGE;
    	      }

    	      if (prevEditorState === null) {
    	        return HISTORY_PUSH;
    	      }

    	      const selection = nextEditorState._selection;
    	      const prevSelection = prevEditorState._selection;
    	      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;

    	      if (!hasDirtyNodes) {
    	        if (prevSelection === null && selection !== null) {
    	          return HISTORY_MERGE;
    	        }

    	        return DISCARD_HISTORY_CANDIDATE;
    	      }

    	      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {
    	        return HISTORY_MERGE;
    	      } // A single node might have been marked as dirty, but not have changed
    	      // due to some node transform reverting the change.


    	      if (dirtyLeaves.size === 1) {
    	        const dirtyLeafKey = Array.from(dirtyLeaves)[0];

    	        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {
    	          return HISTORY_MERGE;
    	        }
    	      }

    	      return HISTORY_PUSH;
    	    })();

    	    prevChangeTime = changeTime;
    	    prevChangeType = changeType;
    	    return mergeAction;
    	  };
    	}

    	function redo(editor, historyState) {
    	  const redoStack = historyState.redoStack;
    	  const undoStack = historyState.undoStack;

    	  if (redoStack.length !== 0) {
    	    const current = historyState.current;

    	    if (current !== null) {
    	      undoStack.push(current);
    	      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);
    	    }

    	    const historyStateEntry = redoStack.pop();

    	    if (redoStack.length === 0) {
    	      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);
    	    }

    	    historyState.current = historyStateEntry || null;

    	    if (historyStateEntry) {
    	      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
    	        tag: 'historic'
    	      });
    	    }
    	  }
    	}

    	function undo(editor, historyState) {
    	  const redoStack = historyState.redoStack;
    	  const undoStack = historyState.undoStack;
    	  const undoStackLength = undoStack.length;

    	  if (undoStackLength !== 0) {
    	    const current = historyState.current;
    	    const historyStateEntry = undoStack.pop();

    	    if (current !== null) {
    	      redoStack.push(current);
    	      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);
    	    }

    	    if (undoStack.length === 0) {
    	      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);
    	    }

    	    historyState.current = historyStateEntry || null;

    	    if (historyStateEntry) {
    	      historyStateEntry.editor.setEditorState(historyStateEntry.editorState.clone(historyStateEntry.undoSelection), {
    	        tag: 'historic'
    	      });
    	    }
    	  }
    	}

    	function clearHistory(historyState) {
    	  historyState.undoStack = [];
    	  historyState.redoStack = [];
    	  historyState.current = null;
    	}

    	function registerHistory(editor, historyState, delay) {
    	  const getMergeAction = createMergeActionGetter(editor, delay);

    	  const applyChange = ({
    	    editorState,
    	    prevEditorState,
    	    dirtyLeaves,
    	    dirtyElements,
    	    tags
    	  }) => {
    	    const current = historyState.current;
    	    const redoStack = historyState.redoStack;
    	    const undoStack = historyState.undoStack;
    	    const currentEditorState = current === null ? null : current.editorState;

    	    if (current !== null && editorState === currentEditorState) {
    	      return;
    	    }

    	    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);

    	    if (mergeAction === HISTORY_PUSH) {
    	      if (redoStack.length !== 0) {
    	        historyState.redoStack = [];
    	      }

    	      if (current !== null) {
    	        undoStack.push({ ...current,
    	          undoSelection: prevEditorState.read(lexical.$getSelection)
    	        });
    	        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);
    	      }
    	    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {
    	      return;
    	    } // Else we merge


    	    historyState.current = {
    	      editor,
    	      editorState
    	    };
    	  };

    	  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {
    	    undo(editor, historyState);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {
    	    redo(editor, historyState);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {
    	    clearHistory(historyState);
    	    return false;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {
    	    clearHistory(historyState);
    	    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);
    	    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);
    	    return true;
    	  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));
    	  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);
    	  return () => {
    	    unregisterCommandListener();
    	    unregisterUpdateListener();
    	  };
    	}
    	function createEmptyHistoryState() {
    	  return {
    	    current: null,
    	    redoStack: [],
    	    undoStack: []
    	  };
    	}

    	LexicalHistory_dev.createEmptyHistoryState = createEmptyHistoryState;
    	LexicalHistory_dev.registerHistory = registerHistory;
    	return LexicalHistory_dev;
    }

    var LexicalHistory_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalHistory_prod;

    function requireLexicalHistory_prod () {
    	if (hasRequiredLexicalHistory_prod) return LexicalHistory_prod;
    	hasRequiredLexicalHistory_prod = 1;
    var d=LexicalUtils_1,u=Lexical_1;
    	function v(b,a,m,k,p){if(null===b||0===m.size&&0===k.size&&!p)return 0;var f=a._selection,c=b._selection;if(p)return 1;if(!(u.$isRangeSelection(f)&&u.$isRangeSelection(c)&&c.isCollapsed()&&f.isCollapsed()))return 0;p=a._nodeMap;let e=[];for(let g of m)m=p.get(g),void 0!==m&&e.push(m);for(let [g,n]of k)n&&(k=p.get(g),void 0===k||u.$isRootNode(k)||e.push(k));if(0===e.length)return 0;if(1<e.length)return k=a._nodeMap,a=k.get(f.anchor.key),c=k.get(c.anchor.key),a&&c&&!b._nodeMap.has(a.__key)&&u.$isTextNode(a)&&
    	1===a.__text.length&&1===f.anchor.offset?2:0;a=e[0];b=b._nodeMap.get(a.__key);if(!u.$isTextNode(b)||!u.$isTextNode(a)||b.__mode!==a.__mode)return 0;b=b.__text;a=a.__text;if(b===a)return 0;f=f.anchor;c=c.anchor;if(f.key!==c.key||"text"!==f.type)return 0;f=f.offset;c=c.offset;b=a.length-b.length;return 1===b&&c===f-1?2:-1===b&&c===f+1?3:-1===b&&c===f?4:0}
    	function w(b,a){let m=Date.now(),k=0;return (p,f,c,e,g,n)=>{let r=Date.now();if(n.has("historic"))return k=0,m=r,2;let q=v(p,f,e,g,b.isComposing()),t=(()=>{var l=null===c||c.editor===b,h=n.has("history-push");if(!h&&l&&n.has("history-merge"))return 0;if(null===p)return 1;const x=f._selection,y=p._selection;return 0<e.size||0<g.size?!1===h&&0!==q&&q===k&&r<m+a&&l||1===e.size&&(h=Array.from(e)[0],l=p._nodeMap.get(h),h=f._nodeMap.get(h),l=u.$isTextNode(l)&&u.$isTextNode(h)?l.__type===h.__type&&l.__text===
    	h.__text&&l.__mode===h.__mode&&l.__detail===h.__detail&&l.__style===h.__style&&l.__format===h.__format&&l.__parent===h.__parent:!1,l)?0:1:null===y&&null!==x?0:2})();m=r;k=q;return t}}LexicalHistory_prod.createEmptyHistoryState=function(){return {current:null,redoStack:[],undoStack:[]}};
    	LexicalHistory_prod.registerHistory=function(b,a,m){let k=w(b,m);m=({editorState:c,prevEditorState:e,dirtyLeaves:g,dirtyElements:n,tags:r})=>{const q=a.current,t=a.redoStack,l=a.undoStack,h=null===q?null:q.editorState;if(null===q||c!==h){g=k(e,c,q,g,n,r);if(1===g)0!==t.length&&(a.redoStack=[]),null!==q&&(l.push({...q,undoSelection:e.read(u.$getSelection)}),b.dispatchCommand(u.CAN_UNDO_COMMAND,!0));else if(2===g)return;a.current={editor:b,editorState:c};}};let p=d.mergeRegister(b.registerCommand(u.UNDO_COMMAND,
    	()=>{let c=a.redoStack,e=a.undoStack;if(0!==e.length){let g=a.current,n=e.pop();null!==g&&(c.push(g),b.dispatchCommand(u.CAN_REDO_COMMAND,!0));0===e.length&&b.dispatchCommand(u.CAN_UNDO_COMMAND,!1);a.current=n||null;n&&n.editor.setEditorState(n.editorState.clone(n.undoSelection),{tag:"historic"});}return !0},u.COMMAND_PRIORITY_EDITOR),b.registerCommand(u.REDO_COMMAND,()=>{let c=a.redoStack;var e=a.undoStack;if(0!==c.length){let g=a.current;null!==g&&(e.push(g),b.dispatchCommand(u.CAN_UNDO_COMMAND,!0));
    	e=c.pop();0===c.length&&b.dispatchCommand(u.CAN_REDO_COMMAND,!1);a.current=e||null;e&&e.editor.setEditorState(e.editorState,{tag:"historic"});}return !0},u.COMMAND_PRIORITY_EDITOR),b.registerCommand(u.CLEAR_EDITOR_COMMAND,()=>{a.undoStack=[];a.redoStack=[];a.current=null;return !1},u.COMMAND_PRIORITY_EDITOR),b.registerCommand(u.CLEAR_HISTORY_COMMAND,()=>{a.undoStack=[];a.redoStack=[];a.current=null;b.dispatchCommand(u.CAN_REDO_COMMAND,!1);b.dispatchCommand(u.CAN_UNDO_COMMAND,!1);return !0},u.COMMAND_PRIORITY_EDITOR),
    	b.registerUpdateListener(m)),f=b.registerUpdateListener(m);return ()=>{p();f();}};
    	return LexicalHistory_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalHistory = process.env.NODE_ENV === 'development' ? requireLexicalHistory_dev() : requireLexicalHistory_prod();
    var LexicalHistory_1 = LexicalHistory;

    /* src/core/plugins/HistoryPlugin.svelte generated by Svelte v3.55.1 */

    function instance$z($$self, $$props, $$invalidate) {
    	const editor = getContext('editor');
    	let { externalHistoryState = LexicalHistory_1.createEmptyHistoryState() } = $$props;
    	let { delay = 1000 } = $$props;

    	// returns callback to unregister
    	onMount(() => LexicalHistory_1.registerHistory(editor, externalHistoryState, delay));

    	$$self.$$set = $$props => {
    		if ('externalHistoryState' in $$props) $$invalidate(0, externalHistoryState = $$props.externalHistoryState);
    		if ('delay' in $$props) $$invalidate(1, delay = $$props.delay);
    	};

    	return [externalHistoryState, delay];
    }

    class HistoryPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$z, null, safe_not_equal, { externalHistoryState: 0, delay: 1 });
    	}
    }

    /* src/core/plugins/ListPlugin.svelte generated by Svelte v3.55.1 */

    function instance$y($$self) {
    	const editor = getContext('editor');

    	onMount(() => {
    		// returns callback to unregister
    		return LexicalUtils_1.mergeRegister(
    			editor.registerCommand(
    				Lexical_1.INDENT_CONTENT_COMMAND,
    				() => {
    					LexicalList_1.indentList();
    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.OUTDENT_CONTENT_COMMAND,
    				() => {
    					LexicalList_1.outdentList();
    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				LexicalList_1.INSERT_ORDERED_LIST_COMMAND,
    				() => {
    					LexicalList_1.insertList(editor, 'number');
    					return true;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				LexicalList_1.INSERT_UNORDERED_LIST_COMMAND,
    				() => {
    					LexicalList_1.insertList(editor, 'bullet');
    					return true;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				LexicalList_1.REMOVE_LIST_COMMAND,
    				() => {
    					LexicalList_1.removeList(editor);
    					return true;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.INSERT_PARAGRAPH_COMMAND,
    				() => {
    					const hasHandledInsertParagraph = LexicalList_1.$handleListInsertParagraph();

    					if (hasHandledInsertParagraph) {
    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			)
    		);
    	});

    	return [];
    }

    class ListPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$y, null, safe_not_equal, {});
    	}
    }

    /* src/core/plugins/CheckListPlugin.svelte generated by Svelte v3.55.1 */

    function handleCheckItemEvent(event, callback) {
    	const target = event.target;

    	if (!(target instanceof HTMLElement)) {
    		return;
    	}

    	// Ignore clicks on LI that have nested lists
    	const firstChild = target.firstChild;

    	if (firstChild != null && firstChild instanceof HTMLElement && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {
    		return;
    	}

    	const parentNode = target.parentNode;

    	// @ts-ignore internal field
    	if (!parentNode || parentNode.__lexicalListType !== 'check') {
    		return;
    	}

    	const pageX = event.pageX;
    	const rect = target.getBoundingClientRect();

    	if (target.dir === 'rtl'
    	? pageX < rect.right && pageX > rect.right - 20
    	: pageX > rect.left && pageX < rect.left + 20) {
    		callback();
    	}
    }

    function handlePointerDown(event) {
    	handleCheckItemEvent(event, () => {
    		// Prevents caret moving when clicking on check mark
    		event.preventDefault();
    	});
    }

    function findEditor(target) {
    	let node = target;

    	while (node) {
    		// @ts-ignore internal field
    		if (node.__lexicalEditor) {
    			// @ts-ignore internal field
    			return node.__lexicalEditor;
    		}

    		node = node.parentNode;
    	}

    	return null;
    }

    function getActiveCheckListItem() {
    	const activeElement = document.activeElement;

    	return activeElement != null && activeElement.tagName === 'LI' && activeElement.parentNode != null && // @ts-ignore internal field
    	activeElement.parentNode.__lexicalListType === 'check'
    	? activeElement
    	: null;
    }

    function instance$x($$self) {
    	const editor = getContext('editor');

    	onMount(() => {
    		return LexicalUtils_1.mergeRegister(
    			editor.registerCommand(
    				LexicalList_1.INSERT_CHECK_LIST_COMMAND,
    				() => {
    					LexicalList_1.insertList(editor, 'check');
    					return true;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.KEY_ARROW_DOWN_COMMAND,
    				event => {
    					return handleArrownUpOrDown(event, editor, false);
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.KEY_ARROW_UP_COMMAND,
    				event => {
    					return handleArrownUpOrDown(event, editor, true);
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.KEY_ESCAPE_COMMAND,
    				event => {
    					const activeItem = getActiveCheckListItem();

    					if (activeItem != null) {
    						const rootElement = editor.getRootElement();

    						if (rootElement != null) {
    							rootElement.focus();
    						}

    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.KEY_SPACE_COMMAND,
    				event => {
    					const activeItem = getActiveCheckListItem();

    					if (activeItem != null && editor.isEditable()) {
    						editor.update(() => {
    							const listItemNode = Lexical_1.$getNearestNodeFromDOMNode(activeItem);

    							if (LexicalList_1.$isListItemNode(listItemNode)) {
    								event.preventDefault();
    								listItemNode.toggleChecked();
    							}
    						});

    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.KEY_ARROW_LEFT_COMMAND,
    				event => {
    					return editor.getEditorState().read(() => {
    						const selection = Lexical_1.$getSelection();

    						if (Lexical_1.$isRangeSelection(selection) && selection.isCollapsed()) {
    							const { anchor } = selection;
    							const isElement = anchor.type === 'element';

    							if (isElement || anchor.offset === 0) {
    								const anchorNode = anchor.getNode();
    								const elementNode = LexicalUtils_1.$findMatchingParent(anchorNode, node => Lexical_1.$isElementNode(node) && !node.isInline());

    								if (LexicalList_1.$isListItemNode(elementNode)) {
    									const parent = elementNode.getParent();

    									if (LexicalList_1.$isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
    										const domNode = editor.getElementByKey(elementNode.__key);

    										if (domNode != null && document.activeElement !== domNode) {
    											domNode.focus();
    											event.preventDefault();
    											return true;
    										}
    									}
    								}
    							}
    						}

    						return false;
    					});
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			listenPointerDown()
    		);
    	});

    	let listenersCount = 0;

    	function listenPointerDown() {
    		if (listenersCount++ === 0) {
    			document.addEventListener('click', handleClick);
    			document.addEventListener('pointerdown', handlePointerDown);
    		}

    		return () => {
    			if (--listenersCount === 0) {
    				document.removeEventListener('click', handleClick);
    				document.removeEventListener('pointerdown', handlePointerDown);
    			}
    		};
    	}

    	function handleClick(event) {
    		handleCheckItemEvent(event, () => {
    			const domNode = event.target;
    			const editor = findEditor(domNode);

    			if (editor != null && editor.isEditable()) {
    				editor.update(() => {
    					if (event.target) {
    						const node = Lexical_1.$getNearestNodeFromDOMNode(domNode);

    						if (LexicalList_1.$isListItemNode(node)) {
    							domNode.focus();
    							node.toggleChecked();
    						}
    					}
    				});
    			}
    		});
    	}

    	function findCheckListItemSibling(node, backward) {
    		let sibling = backward
    		? node.getPreviousSibling()
    		: node.getNextSibling();

    		let parent = node;

    		// Going up in a tree to get non-null sibling
    		while (sibling == null && LexicalList_1.$isListItemNode(parent)) {
    			// Get li -> parent ul/ol -> parent li
    			parent = parent.getParentOrThrow().getParent();

    			if (parent != null) {
    				sibling = backward
    				? parent.getPreviousSibling()
    				: parent.getNextSibling();
    			}
    		}

    		// Going down in a tree to get first non-nested list item
    		while (LexicalList_1.$isListItemNode(sibling)) {
    			const firstChild = backward
    			? sibling.getLastChild()
    			: sibling.getFirstChild();

    			if (!LexicalList_1.$isListNode(firstChild)) {
    				return sibling;
    			}

    			sibling = backward
    			? firstChild.getLastChild()
    			: firstChild.getFirstChild();
    		}

    		return null;
    	}

    	function handleArrownUpOrDown(event, editor, backward) {
    		const activeItem = getActiveCheckListItem();

    		if (activeItem != null) {
    			editor.update(() => {
    				const listItem = Lexical_1.$getNearestNodeFromDOMNode(activeItem);

    				if (!LexicalList_1.$isListItemNode(listItem)) {
    					return;
    				}

    				const nextListItem = findCheckListItemSibling(listItem, backward);

    				if (nextListItem != null) {
    					nextListItem.selectStart();
    					const dom = editor.getElementByKey(nextListItem.__key);

    					if (dom != null) {
    						event.preventDefault();

    						setTimeout(
    							() => {
    								dom.focus();
    							},
    							0
    						);
    					}
    				}
    			});
    		}

    		return false;
    	}

    	return [];
    }

    class CheckListPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$x, null, safe_not_equal, {});
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    /**
     * Ported from lexical/packages/lexical-react/src/useLexicalNodeSelection.ts
     */
    function isNodeSelected(editor, key) {
        return editor.getEditorState().read(() => {
            const node = Lexical_1.$getNodeByKey(key);
            if (node === null) {
                return false;
            }
            return node.isSelected();
        });
    }
    /**
     * Clear editor selection
     */
    function clearSelection(editor) {
        editor.update(() => {
            const selection = Lexical_1.$getSelection();
            if (Lexical_1.$isNodeSelection(selection)) {
                selection.clear();
            }
        });
    }
    /**
     * Stores `isSelected` state for a SvelteComponent node.
     * Rather than updating the component state directly, it updates the editor node selection and receives updates from the editor.
     */
    function createNodeSelectionStore(editor, nodeKey) {
        const { subscribe, set /*, update*/ } = writable(false);
        editor.registerUpdateListener(() => {
            set(isNodeSelected(editor, nodeKey));
        });
        return {
            subscribe,
            set: (selected) => {
                editor.update(() => {
                    let selection = Lexical_1.$getSelection();
                    if (!Lexical_1.$isNodeSelection(selection)) {
                        selection = Lexical_1.$createNodeSelection();
                        Lexical_1.$setSelection(selection);
                    }
                    if (selected) {
                        selection.add(nodeKey);
                    }
                    else {
                        selection.delete(nodeKey);
                    }
                });
            },
        };
    }

    /* src/core/plugins/HorizontalRuleComponent.svelte generated by Svelte v3.55.1 */

    function create_fragment$w(ctx) {
    	let hr;

    	return {
    		c() {
    			hr = element("hr");
    			toggle_class(hr, "selected", /*$isSelected*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, hr, anchor);
    			/*hr_binding*/ ctx[5](hr);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isSelected*/ 2) {
    				toggle_class(hr, "selected", /*$isSelected*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(hr);
    			/*hr_binding*/ ctx[5](null);
    		}
    	};
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $isSelected;
    	let { editor } = $$props;
    	let { nodeKey } = $$props;
    	let isSelected = createNodeSelectionStore(editor, nodeKey);
    	component_subscribe($$self, isSelected, value => $$invalidate(1, $isSelected = value));
    	let self;

    	function onDelete(event) {
    		if ($isSelected && Lexical_1.$isNodeSelection(Lexical_1.$getSelection())) {
    			event.preventDefault();
    			const node = Lexical_1.$getNodeByKey(nodeKey);

    			if ($isHorizontalRuleNode(node)) {
    				node.remove();
    			}

    			set_store_value(isSelected, $isSelected = false, $isSelected);
    		}

    		return false;
    	}

    	onMount(() => {
    		return LexicalUtils_1.mergeRegister(
    			editor.registerCommand(
    				Lexical_1.CLICK_COMMAND,
    				event => {
    					if (event.target === self) {
    						if (!event.shiftKey) {
    							clearSelection(editor);
    						}

    						set_store_value(isSelected, $isSelected = !$isSelected, $isSelected);
    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(Lexical_1.KEY_DELETE_COMMAND, onDelete, Lexical_1.COMMAND_PRIORITY_LOW),
    			editor.registerCommand(Lexical_1.KEY_BACKSPACE_COMMAND, onDelete, Lexical_1.COMMAND_PRIORITY_LOW)
    		);
    	});

    	function hr_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			self = $$value;
    			$$invalidate(0, self);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('editor' in $$props) $$invalidate(3, editor = $$props.editor);
    		if ('nodeKey' in $$props) $$invalidate(4, nodeKey = $$props.nodeKey);
    	};

    	return [self, $isSelected, isSelected, editor, nodeKey, hr_binding];
    }

    class HorizontalRuleComponent extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { editor: 3, nodeKey: 4 });
    	}
    }

    const { createCommand, DecoratorNode } = Lexical_1;
    const INSERT_HORIZONTAL_RULE_COMMAND = createCommand();
    class HorizontalRuleNode extends DecoratorNode {
        static getType() {
            return 'horizontalrule';
        }
        static clone(node) {
            return new HorizontalRuleNode(node.__key);
        }
        static importJSON() {
            return $createHorizontalRuleNode();
        }
        static importDOM() {
            return {
                hr: () => ({
                    conversion: convertHorizontalRuleElement,
                    priority: 0,
                }),
            };
        }
        exportJSON() {
            return {
                type: 'horizontalrule',
                version: 1,
            };
        }
        exportDOM() {
            return { element: document.createElement('hr') };
        }
        createDOM(editorConfig, editor) {
            const div = document.createElement('div');
            div.style.display = 'contents';
            new HorizontalRuleComponent({
                target: div,
                props: {
                    nodeKey: this.__key,
                    editor,
                },
            });
            return div;
        }
        getTextContent() {
            return '\n';
        }
        isInline() {
            return false;
        }
        updateDOM() {
            return false;
        }
        decorate() {
            return null;
        }
    }
    function convertHorizontalRuleElement() {
        return { node: $createHorizontalRuleNode() };
    }
    function $createHorizontalRuleNode() {
        return Lexical_1.$applyNodeReplacement(new HorizontalRuleNode());
    }
    function $isHorizontalRuleNode(node) {
        return node instanceof HorizontalRuleNode;
    }

    /* src/core/plugins/HorizontalRulePlugin.svelte generated by Svelte v3.55.1 */

    function instance$v($$self) {
    	const editor = getContext('editor');

    	onMount(() => {
    		editor.registerCommand(
    			INSERT_HORIZONTAL_RULE_COMMAND,
    			type => {
    				const selection = Lexical_1.$getSelection();

    				if (!Lexical_1.$isRangeSelection(selection)) {
    					return false;
    				}

    				const focusNode = selection.focus.getNode();

    				if (focusNode !== null) {
    					const horizontalRuleNode = $createHorizontalRuleNode();
    					selection.insertParagraph();
    					selection.focus.getNode().getTopLevelElementOrThrow().insertBefore(horizontalRuleNode);
    				}

    				return true;
    			},
    			Lexical_1.COMMAND_PRIORITY_EDITOR
    		);
    	});

    	return [];
    }

    class HorizontalRulePlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$v, null, safe_not_equal, {});
    	}
    }

    /* src/components/ImageResizer.svelte generated by Svelte v3.55.1 */

    function create_if_block$4(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.textContent = "Add Caption";
    			attr(button, "class", "image-caption-button");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			/*button_binding*/ ctx[12](button);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[13]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			/*button_binding*/ ctx[12](null);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function create_fragment$v(ctx) {
    	let div8;
    	let t0;
    	let div0;
    	let t1;
    	let div1;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let t4;
    	let div4;
    	let t5;
    	let div5;
    	let t6;
    	let div6;
    	let t7;
    	let div7;
    	let mounted;
    	let dispose;
    	let if_block = !/*showCaption*/ ctx[1] && /*captionsEnabled*/ ctx[3] && create_if_block$4(ctx);

    	return {
    		c() {
    			div8 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			div1 = element("div");
    			t2 = space();
    			div2 = element("div");
    			t3 = space();
    			div3 = element("div");
    			t4 = space();
    			div4 = element("div");
    			t5 = space();
    			div5 = element("div");
    			t6 = space();
    			div6 = element("div");
    			t7 = space();
    			div7 = element("div");
    			attr(div0, "class", "image-resizer image-resizer-n");
    			attr(div1, "class", "image-resizer image-resizer-ne");
    			attr(div2, "class", "image-resizer image-resizer-e");
    			attr(div3, "class", "image-resizer image-resizer-se");
    			attr(div4, "class", "image-resizer image-resizer-s");
    			attr(div5, "class", "image-resizer image-resizer-sw");
    			attr(div6, "class", "image-resizer image-resizer-w");
    			attr(div7, "class", "image-resizer image-resizer-nw");
    		},
    		m(target, anchor) {
    			insert(target, div8, anchor);
    			if (if_block) if_block.m(div8, null);
    			append(div8, t0);
    			append(div8, div0);
    			append(div8, t1);
    			append(div8, div1);
    			append(div8, t2);
    			append(div8, div2);
    			append(div8, t3);
    			append(div8, div3);
    			append(div8, t4);
    			append(div8, div4);
    			append(div8, t5);
    			append(div8, div5);
    			append(div8, t6);
    			append(div8, div6);
    			append(div8, t7);
    			append(div8, div7);
    			/*div8_binding*/ ctx[22](div8);

    			if (!mounted) {
    				dispose = [
    					listen(div0, "pointerdown", /*pointerdown_handler*/ ctx[14]),
    					listen(div1, "pointerdown", /*pointerdown_handler_1*/ ctx[15]),
    					listen(div2, "pointerdown", /*pointerdown_handler_2*/ ctx[16]),
    					listen(div3, "pointerdown", /*pointerdown_handler_3*/ ctx[17]),
    					listen(div4, "pointerdown", /*pointerdown_handler_4*/ ctx[18]),
    					listen(div5, "pointerdown", /*pointerdown_handler_5*/ ctx[19]),
    					listen(div6, "pointerdown", /*pointerdown_handler_6*/ ctx[20]),
    					listen(div7, "pointerdown", /*pointerdown_handler_7*/ ctx[21])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (!/*showCaption*/ ctx[1] && /*captionsEnabled*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(div8, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div8);
    			if (if_block) if_block.d();
    			/*div8_binding*/ ctx[22](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    const minWidth = 100;
    const minHeight = 100;

    function clamp(value, min, max) {
    	return Math.min(Math.max(value, min), max);
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { onResizeStart } = $$props;
    	let { onResizeEnd } = $$props;
    	let { buttonRef } = $$props;
    	let { imageRef } = $$props;
    	let { maxWidth } = $$props;
    	let { editor } = $$props;
    	let { showCaption } = $$props;
    	let { setShowCaption } = $$props;
    	let { captionsEnabled } = $$props;
    	let controlWrapperRef;

    	const Direction = {
    		east: 1 << 0,
    		north: 1 << 3,
    		south: 1 << 1,
    		west: 1 << 2
    	};

    	const userSelect = { priority: '', value: 'default' };

    	const positioningRef = {
    		currentHeight: 0,
    		currentWidth: 0,
    		direction: 0,
    		isResizing: false,
    		ratio: 0,
    		startHeight: 0,
    		startWidth: 0,
    		startX: 0,
    		startY: 0
    	};

    	const editorRootElement = editor.getRootElement();

    	// Find max width, accounting for editor padding.
    	const maxWidthContainer = maxWidth
    	? maxWidth
    	: editorRootElement !== null
    		? editorRootElement.getBoundingClientRect().width - 20
    		: 100;

    	const maxHeightContainer = editorRootElement !== null
    	? editorRootElement.getBoundingClientRect().height - 20
    	: 100;

    	const setStartCursor = direction => {
    		const ew = direction === Direction.east || direction === Direction.west;
    		const ns = direction === Direction.north || direction === Direction.south;
    		const nwse = direction & Direction.north && direction & Direction.west || direction & Direction.south && direction & Direction.east;
    		const cursorDir = ew ? 'ew' : ns ? 'ns' : nwse ? 'nwse' : 'nesw';

    		if (editorRootElement !== null) {
    			editorRootElement.style.setProperty('cursor', `${cursorDir}-resize`, 'important');
    		}

    		if (document.body !== null) {
    			document.body.style.setProperty('cursor', `${cursorDir}-resize`, 'important');
    			userSelect.value = document.body.style.getPropertyValue('-webkit-user-select');
    			userSelect.priority = document.body.style.getPropertyPriority('-webkit-user-select');
    			document.body.style.setProperty('-webkit-user-select', `none`, 'important');
    		}
    	};

    	const setEndCursor = () => {
    		if (editorRootElement !== null) {
    			editorRootElement.style.setProperty('cursor', 'default');
    		}

    		if (document.body !== null) {
    			document.body.style.setProperty('cursor', 'default');
    			document.body.style.setProperty('-webkit-user-select', userSelect.value, userSelect.priority);
    		}
    	};

    	const handlePointerDown = (event, direction) => {
    		if (!editor.isEditable()) {
    			return;
    		}

    		const image = imageRef;
    		const controlWrapper = controlWrapperRef;

    		if (image !== null && controlWrapper !== null) {
    			const { width, height } = image.getBoundingClientRect();
    			const positioning = positioningRef;
    			positioning.startWidth = width;
    			positioning.startHeight = height;
    			positioning.ratio = width / height;
    			positioning.currentWidth = width;
    			positioning.currentHeight = height;
    			positioning.startX = event.clientX;
    			positioning.startY = event.clientY;
    			positioning.isResizing = true;
    			positioning.direction = direction;
    			setStartCursor(direction);
    			onResizeStart();
    			controlWrapper.classList.add('image-control-wrapper--resizing');
    			image.style.height = `${height}px`;
    			image.style.width = `${width}px`;
    			document.addEventListener('pointermove', handlePointerMove);
    			document.addEventListener('pointerup', handlePointerUp);
    		}
    	};

    	const handlePointerMove = event => {
    		const image = imageRef;
    		const positioning = positioningRef;
    		const isHorizontal = positioning.direction & (Direction.east | Direction.west);
    		const isVertical = positioning.direction & (Direction.south | Direction.north);

    		if (image !== null && positioning.isResizing) {
    			// Corner cursor
    			if (isHorizontal && isVertical) {
    				let diff = Math.floor(positioning.startX - event.clientX);
    				diff = positioning.direction & Direction.east ? -diff : diff;
    				const width = clamp(positioning.startWidth + diff, minWidth, maxWidthContainer);
    				const height = width / positioning.ratio;
    				image.style.width = `${width}px`;
    				image.style.height = `${height}px`;
    				positioning.currentHeight = height;
    				positioning.currentWidth = width;
    			} else if (isVertical) {
    				let diff = Math.floor(positioning.startY - event.clientY);
    				diff = positioning.direction & Direction.south ? -diff : diff;
    				const height = clamp(positioning.startHeight + diff, minHeight, maxHeightContainer);
    				image.style.height = `${height}px`;
    				positioning.currentHeight = height;
    			} else {
    				let diff = Math.floor(positioning.startX - event.clientX);
    				diff = positioning.direction & Direction.east ? -diff : diff;
    				const width = clamp(positioning.startWidth + diff, minWidth, maxWidthContainer);
    				image.style.width = `${width}px`;
    				positioning.currentWidth = width;
    			}
    		}
    	};

    	const handlePointerUp = () => {
    		const image = imageRef;
    		const positioning = positioningRef;
    		const controlWrapper = controlWrapperRef;

    		if (image !== null && controlWrapper !== null && positioning.isResizing) {
    			const width = positioning.currentWidth;
    			const height = positioning.currentHeight;
    			positioning.startWidth = 0;
    			positioning.startHeight = 0;
    			positioning.ratio = 0;
    			positioning.startX = 0;
    			positioning.startY = 0;
    			positioning.currentWidth = 0;
    			positioning.currentHeight = 0;
    			positioning.isResizing = false;
    			controlWrapper.classList.remove('image-control-wrapper--resizing');
    			setEndCursor();
    			onResizeEnd(width, height);
    			document.removeEventListener('pointermove', handlePointerMove);
    			document.removeEventListener('pointerup', handlePointerUp);
    		}
    	};

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonRef = $$value;
    			$$invalidate(0, buttonRef);
    		});
    	}

    	const click_handler = () => {
    		setShowCaption(!showCaption);
    	};

    	const pointerdown_handler = event => {
    		handlePointerDown(event, Direction.north);
    	};

    	const pointerdown_handler_1 = event => {
    		handlePointerDown(event, Direction.north | Direction.east);
    	};

    	const pointerdown_handler_2 = event => {
    		handlePointerDown(event, Direction.east);
    	};

    	const pointerdown_handler_3 = event => {
    		handlePointerDown(event, Direction.south | Direction.east);
    	};

    	const pointerdown_handler_4 = event => {
    		handlePointerDown(event, Direction.south);
    	};

    	const pointerdown_handler_5 = event => {
    		handlePointerDown(event, Direction.south | Direction.west);
    	};

    	const pointerdown_handler_6 = event => {
    		handlePointerDown(event, Direction.west);
    	};

    	const pointerdown_handler_7 = event => {
    		handlePointerDown(event, Direction.north | Direction.west);
    	};

    	function div8_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			controlWrapperRef = $$value;
    			$$invalidate(4, controlWrapperRef);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('onResizeStart' in $$props) $$invalidate(7, onResizeStart = $$props.onResizeStart);
    		if ('onResizeEnd' in $$props) $$invalidate(8, onResizeEnd = $$props.onResizeEnd);
    		if ('buttonRef' in $$props) $$invalidate(0, buttonRef = $$props.buttonRef);
    		if ('imageRef' in $$props) $$invalidate(9, imageRef = $$props.imageRef);
    		if ('maxWidth' in $$props) $$invalidate(10, maxWidth = $$props.maxWidth);
    		if ('editor' in $$props) $$invalidate(11, editor = $$props.editor);
    		if ('showCaption' in $$props) $$invalidate(1, showCaption = $$props.showCaption);
    		if ('setShowCaption' in $$props) $$invalidate(2, setShowCaption = $$props.setShowCaption);
    		if ('captionsEnabled' in $$props) $$invalidate(3, captionsEnabled = $$props.captionsEnabled);
    	};

    	return [
    		buttonRef,
    		showCaption,
    		setShowCaption,
    		captionsEnabled,
    		controlWrapperRef,
    		Direction,
    		handlePointerDown,
    		onResizeStart,
    		onResizeEnd,
    		imageRef,
    		maxWidth,
    		editor,
    		button_binding,
    		click_handler,
    		pointerdown_handler,
    		pointerdown_handler_1,
    		pointerdown_handler_2,
    		pointerdown_handler_3,
    		pointerdown_handler_4,
    		pointerdown_handler_5,
    		pointerdown_handler_6,
    		pointerdown_handler_7,
    		div8_binding
    	];
    }

    class ImageResizer extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$u,
    			create_fragment$v,
    			safe_not_equal,
    			{
    				onResizeStart: 7,
    				onResizeEnd: 8,
    				buttonRef: 0,
    				imageRef: 9,
    				maxWidth: 10,
    				editor: 11,
    				showCaption: 1,
    				setShowCaption: 2,
    				captionsEnabled: 3
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    /* src/core/plugins/ImageComponent.svelte generated by Svelte v3.55.1 */

    function create_catch_block(ctx) {
    	return { c: noop, m: noop, p: noop, d: noop };
    }

    // (152:2) {:then _}
    function create_then_block(ctx) {
    	let img;
    	let img_src_value;

    	return {
    		c() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) attr(img, "src", img_src_value);
    			attr(img, "alt", /*altText*/ ctx[1]);
    			set_style(img, "height", /*height*/ ctx[3] + "px");
    			set_style(img, "width", /*width*/ ctx[2] + "px");
    			set_style(img, "max-width", /*maxWidth*/ ctx[4] + "px");
    			attr(img, "draggable", "false");
    			toggle_class(img, "focused", /*isFocused*/ ctx[11]);
    			toggle_class(img, "draggable", /*isFocused*/ ctx[11] && Lexical_1.$isNodeSelection(/*selection*/ ctx[9]));
    		},
    		m(target, anchor) {
    			insert(target, img, anchor);
    			/*img_binding*/ ctx[23](img);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*src*/ 1 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) {
    				attr(img, "src", img_src_value);
    			}

    			if (dirty & /*altText*/ 2) {
    				attr(img, "alt", /*altText*/ ctx[1]);
    			}

    			if (dirty & /*height*/ 8) {
    				set_style(img, "height", /*height*/ ctx[3] + "px");
    			}

    			if (dirty & /*width*/ 4) {
    				set_style(img, "width", /*width*/ ctx[2] + "px");
    			}

    			if (dirty & /*maxWidth*/ 16) {
    				set_style(img, "max-width", /*maxWidth*/ ctx[4] + "px");
    			}

    			if (dirty & /*isFocused*/ 2048) {
    				toggle_class(img, "focused", /*isFocused*/ ctx[11]);
    			}

    			if (dirty & /*isFocused, isNodeSelection, selection*/ 2560) {
    				toggle_class(img, "draggable", /*isFocused*/ ctx[11] && Lexical_1.$isNodeSelection(/*selection*/ ctx[9]));
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(img);
    			/*img_binding*/ ctx[23](null);
    		}
    	};
    }

    // (150:18)      <p>...loading image</p>   {:then _}
    function create_pending_block(ctx) {
    	let p;

    	return {
    		c() {
    			p = element("p");
    			p.textContent = "...loading image";
    		},
    		m(target, anchor) {
    			insert(target, p, anchor);
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(p);
    		}
    	};
    }

    // (163:0) {#if resizable && isNodeSelection(selection) && isFocused}
    function create_if_block$3(ctx) {
    	let imageresizer;
    	let current;

    	imageresizer = new ImageResizer({
    			props: {
    				showCaption: /*showCaption*/ ctx[6],
    				setShowCaption: /*setShowCaption*/ ctx[16],
    				editor: /*editor*/ ctx[8],
    				buttonRef: /*buttonRef*/ ctx[13],
    				imageRef: /*imageRef*/ ctx[10],
    				maxWidth: /*maxWidth*/ ctx[4],
    				onResizeStart: /*onResizeStart*/ ctx[18],
    				onResizeEnd: /*onResizeEnd*/ ctx[17],
    				captionsEnabled: /*captionsEnabled*/ ctx[7]
    			}
    		});

    	return {
    		c() {
    			create_component(imageresizer.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(imageresizer, target, anchor);
    			current = true;
    		},
    		p(ctx, dirty) {
    			const imageresizer_changes = {};
    			if (dirty & /*showCaption*/ 64) imageresizer_changes.showCaption = /*showCaption*/ ctx[6];
    			if (dirty & /*editor*/ 256) imageresizer_changes.editor = /*editor*/ ctx[8];
    			if (dirty & /*imageRef*/ 1024) imageresizer_changes.imageRef = /*imageRef*/ ctx[10];
    			if (dirty & /*maxWidth*/ 16) imageresizer_changes.maxWidth = /*maxWidth*/ ctx[4];
    			if (dirty & /*captionsEnabled*/ 128) imageresizer_changes.captionsEnabled = /*captionsEnabled*/ ctx[7];
    			imageresizer.$set(imageresizer_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(imageresizer.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(imageresizer.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(imageresizer, detaching);
    		}
    	};
    }

    function create_fragment$u(ctx) {
    	let div;
    	let t;
    	let show_if = /*resizable*/ ctx[5] && Lexical_1.$isNodeSelection(/*selection*/ ctx[9]) && /*isFocused*/ ctx[11];
    	let if_block_anchor;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 28
    	};

    	handle_promise(/*promise*/ ctx[15], info);
    	let if_block = show_if && create_if_block$3(ctx);

    	return {
    		c() {
    			div = element("div");
    			info.block.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(div, "draggable", /*draggable*/ ctx[12]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			info.block.m(div, info.anchor = null);
    			info.mount = () => div;
    			info.anchor = null;
    			insert(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			update_await_block_branch(info, ctx, dirty);

    			if (!current || dirty & /*draggable*/ 4096) {
    				attr(div, "draggable", /*draggable*/ ctx[12]);
    			}

    			if (dirty & /*resizable, selection, isFocused*/ 2592) show_if = /*resizable*/ ctx[5] && Lexical_1.$isNodeSelection(/*selection*/ ctx[9]) && /*isFocused*/ ctx[11];

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*resizable, selection, isFocused*/ 2592) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			info.block.d();
    			info.token = null;
    			info = null;
    			if (detaching) detach(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    		}
    	};
    }
    const imageCache = new Set();

    function instance$t($$self, $$props, $$invalidate) {
    	let draggable;
    	let isFocused;
    	let $isSelected;
    	let { src } = $$props;
    	let { altText } = $$props;
    	let { nodeKey } = $$props;
    	let { width } = $$props;
    	let { height } = $$props;
    	let { maxWidth } = $$props;
    	let { resizable } = $$props;
    	let { showCaption } = $$props;
    	let { caption } = $$props;
    	let { captionsEnabled } = $$props;
    	let { editor } = $$props;
    	let selection = null;
    	let imageRef;
    	let buttonRef;
    	let isSelected = createNodeSelectionStore(editor, nodeKey);
    	component_subscribe($$self, isSelected, value => $$invalidate(22, $isSelected = value));
    	let isResizing = false;

    	//const isCollabActive = false; //TODO: const {isCollabActive} = useCollaborationContext();
    	let activeEditorRef;

    	let promise = new Promise(resolve => {
    			if (imageCache.has(src)) {
    				resolve(null);
    			} else {
    				const img = new Image();
    				img.src = src;

    				img.onload = () => {
    					imageCache.add(src);
    					resolve(null);
    				};
    			}
    		});

    	const onDelete = payload => {
    		if ($isSelected && Lexical_1.$isNodeSelection(Lexical_1.$getSelection())) {
    			const event = payload;
    			event.preventDefault();
    			const node = Lexical_1.$getNodeByKey(nodeKey);

    			if ($isImageNode(node)) {
    				node.remove();
    			}

    			set_store_value(isSelected, $isSelected = false, $isSelected);
    		}

    		return false;
    	};

    	const onEnter = event => {
    		const latestSelection = Lexical_1.$getSelection();
    		const buttonElem = buttonRef;

    		if ($isSelected && Lexical_1.$isNodeSelection(latestSelection) && latestSelection.getNodes().length === 1) {
    			if (showCaption) {
    				// Move focus into nested editor
    				$$invalidate(9, selection = null);

    				event.preventDefault();
    				caption.focus();
    				return true;
    			} else if (buttonElem !== document.activeElement) {
    				event.preventDefault();
    				buttonElem.focus();
    				return true;
    			}
    		}

    		return false;
    	};

    	const onEscape = event => {
    		if (activeEditorRef === caption || buttonRef === event.target) {
    			$$invalidate(9, selection = null);

    			editor.update(() => {
    				set_store_value(isSelected, $isSelected = true, $isSelected);
    				const parentRootElement = editor.getRootElement();

    				if (parentRootElement !== null) {
    					parentRootElement.focus();
    				}
    			});

    			return true;
    		}

    		return false;
    	};

    	onMount(() => {
    		return LexicalUtils_1.mergeRegister(
    			editor.registerUpdateListener(({ editorState }) => {
    				$$invalidate(9, selection = editorState.read(() => Lexical_1.$getSelection()));
    			}),
    			editor.registerCommand(
    				Lexical_1.SELECTION_CHANGE_COMMAND,
    				(_, activeEditor) => {
    					activeEditorRef = activeEditor;
    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.CLICK_COMMAND,
    				payload => {
    					const event = payload;

    					if (isResizing) {
    						return true;
    					}

    					if (event.target === imageRef) {
    						if (event.shiftKey) {
    							set_store_value(isSelected, $isSelected = !$isSelected, $isSelected);
    						} else {
    							clearSelection(editor);
    							set_store_value(isSelected, $isSelected = true, $isSelected);
    						}

    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.DRAGSTART_COMMAND,
    				event => {
    					if (event.target === imageRef) {
    						// TODO This is just a temporary workaround for FF to behave like other browsers.
    						// Ideally, this handles drag & drop too (and all browsers).
    						event.preventDefault();

    						return true;
    					}

    					return false;
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(Lexical_1.KEY_DELETE_COMMAND, onDelete, Lexical_1.COMMAND_PRIORITY_LOW),
    			editor.registerCommand(Lexical_1.KEY_BACKSPACE_COMMAND, onDelete, Lexical_1.COMMAND_PRIORITY_LOW),
    			editor.registerCommand(Lexical_1.KEY_ENTER_COMMAND, onEnter, Lexical_1.COMMAND_PRIORITY_LOW),
    			editor.registerCommand(Lexical_1.KEY_ESCAPE_COMMAND, onEscape, Lexical_1.COMMAND_PRIORITY_LOW)
    		);
    	});

    	const setShowCaption = () => {
    		editor.update(() => {
    			const node = Lexical_1.$getNodeByKey(nodeKey);

    			if ($isImageNode(node)) {
    				node.setShowCaption(true);
    			}
    		});
    	};

    	const onResizeEnd = (nextWidth, nextHeight) => {
    		// Delay hiding the resize bars for click case
    		setTimeout(
    			() => {
    				$$invalidate(21, isResizing = false);
    			},
    			200
    		);

    		editor.update(() => {
    			const node = Lexical_1.$getNodeByKey(nodeKey);

    			if ($isImageNode(node)) {
    				node.setWidthAndHeight(nextWidth, nextHeight);
    			}
    		});
    	};

    	const onResizeStart = () => {
    		$$invalidate(21, isResizing = true);
    	};

    	function img_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			imageRef = $$value;
    			$$invalidate(10, imageRef);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('src' in $$props) $$invalidate(0, src = $$props.src);
    		if ('altText' in $$props) $$invalidate(1, altText = $$props.altText);
    		if ('nodeKey' in $$props) $$invalidate(19, nodeKey = $$props.nodeKey);
    		if ('width' in $$props) $$invalidate(2, width = $$props.width);
    		if ('height' in $$props) $$invalidate(3, height = $$props.height);
    		if ('maxWidth' in $$props) $$invalidate(4, maxWidth = $$props.maxWidth);
    		if ('resizable' in $$props) $$invalidate(5, resizable = $$props.resizable);
    		if ('showCaption' in $$props) $$invalidate(6, showCaption = $$props.showCaption);
    		if ('caption' in $$props) $$invalidate(20, caption = $$props.caption);
    		if ('captionsEnabled' in $$props) $$invalidate(7, captionsEnabled = $$props.captionsEnabled);
    		if ('editor' in $$props) $$invalidate(8, editor = $$props.editor);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$isSelected, selection, isResizing*/ 6291968) {
    			$$invalidate(12, draggable = $isSelected && Lexical_1.$isNodeSelection(selection) && !isResizing);
    		}

    		if ($$self.$$.dirty & /*$isSelected, isResizing*/ 6291456) {
    			$$invalidate(11, isFocused = $isSelected || isResizing);
    		}
    	};

    	return [
    		src,
    		altText,
    		width,
    		height,
    		maxWidth,
    		resizable,
    		showCaption,
    		captionsEnabled,
    		editor,
    		selection,
    		imageRef,
    		isFocused,
    		draggable,
    		buttonRef,
    		isSelected,
    		promise,
    		setShowCaption,
    		onResizeEnd,
    		onResizeStart,
    		nodeKey,
    		caption,
    		isResizing,
    		$isSelected,
    		img_binding
    	];
    }

    class ImageComponent extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$t, create_fragment$u, safe_not_equal, {
    			src: 0,
    			altText: 1,
    			nodeKey: 19,
    			width: 2,
    			height: 3,
    			maxWidth: 4,
    			resizable: 5,
    			showCaption: 6,
    			caption: 20,
    			captionsEnabled: 7,
    			editor: 8
    		});
    	}
    }

    function convertImageElement(domNode) {
        if (domNode instanceof HTMLImageElement) {
            const { alt: altText, src } = domNode;
            const node = $createImageNode({ altText, src });
            return { node };
        }
        return null;
    }
    class ImageNode extends Lexical_1.DecoratorNode {
        static getType() {
            return 'image';
        }
        static clone(node) {
            return new ImageNode(node.__src, node.__altText, node.__maxWidth, node.__width, node.__height, node.__showCaption, node.__caption, node.__captionsEnabled, node.__key);
        }
        static importJSON(serializedNode) {
            const { altText, height, width, maxWidth, caption, src, showCaption } = serializedNode;
            const node = $createImageNode({
                altText,
                height,
                maxWidth,
                showCaption,
                src,
                width,
            });
            const nestedEditor = node.__caption;
            const editorState = nestedEditor.parseEditorState(caption.editorState);
            if (!editorState.isEmpty()) {
                nestedEditor.setEditorState(editorState);
            }
            return node;
        }
        exportDOM() {
            const element = document.createElement('img');
            element.setAttribute('src', this.__src);
            element.setAttribute('alt', this.__altText);
            return { element };
        }
        static importDOM() {
            return {
                img: (node) => ({
                    conversion: convertImageElement,
                    priority: 0,
                }),
            };
        }
        constructor(src, altText, maxWidth, width, height, showCaption, caption, captionsEnabled, key) {
            super(key);
            this.__src = src;
            this.__altText = altText;
            this.__maxWidth = maxWidth;
            this.__width = width || 'inherit';
            this.__height = height || 'inherit';
            this.__showCaption = showCaption || false;
            this.__caption = caption || Lexical_1.createEditor();
            this.__captionsEnabled = captionsEnabled || captionsEnabled === undefined;
        }
        exportJSON() {
            return {
                altText: this.getAltText(),
                caption: this.__caption.toJSON(),
                height: this.__height === 'inherit' ? 0 : this.__height,
                maxWidth: this.__maxWidth,
                showCaption: this.__showCaption,
                src: this.getSrc(),
                type: 'image',
                version: 1,
                width: this.__width === 'inherit' ? 0 : this.__width,
            };
        }
        setWidthAndHeight(width, height) {
            const writable = this.getWritable();
            writable.__width = width;
            writable.__height = height;
        }
        setShowCaption(showCaption) {
            const writable = this.getWritable();
            writable.__showCaption = showCaption;
        }
        // View
        createDOM(config, editor) {
            const span = document.createElement('span');
            const theme = config.theme;
            const className = theme.image;
            if (className !== undefined) {
                span.className = className;
            }
            new ImageComponent({
                target: span,
                props: {
                    src: this.__src,
                    altText: this.__altText,
                    width: this.__width,
                    height: this.__height,
                    maxWidth: this.__maxWidth,
                    nodeKey: this.__key,
                    showCaption: this.__showCaption,
                    caption: this.__caption,
                    captionsEnabled: this.__captionsEnabled,
                    resizable: true,
                    editor: editor,
                },
            });
            return span;
        }
        updateDOM() {
            return false;
        }
        getSrc() {
            return this.__src;
        }
        getAltText() {
            return this.__altText;
        }
        decorate() {
            /*return (
              <Suspense fallback={null}>
              <ImageComponent
                src={this.__src}
            altText={this.__altText}
            width={this.__width}
            height={this.__height}
            maxWidth={this.__maxWidth}
            nodeKey={this.getKey()}
            showCaption={this.__showCaption}
            caption={this.__caption}
            captionsEnabled={this.__captionsEnabled}
            resizable={true}
            />
            </Suspense>
          );*/
            return null;
        }
    }
    function $createImageNode({ altText, height, maxWidth = 500, captionsEnabled, src, width, showCaption, caption, key, }) {
        return Lexical_1.$applyNodeReplacement(new ImageNode(src, altText, maxWidth, width, height, showCaption, caption, captionsEnabled, key));
    }
    function $isImageNode(node) {
        return node instanceof ImageNode;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     *
     */
    const CAN_USE_DOM = typeof window !== 'undefined' &&
        typeof window.document !== 'undefined' &&
        typeof window.document.createElement !== 'undefined';

    /* src/core/plugins/ImagePlugin.svelte generated by Svelte v3.55.1 */
    const INSERT_IMAGE_COMMAND = Lexical_1.createCommand();

    const getDOMSelection = targetWindow => CAN_USE_DOM
    ? (targetWindow || window).getSelection()
    : null;

    const TRANSPARENT_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

    function getDragImageData(event) {
    	var _a;

    	const dragData = (_a = event.dataTransfer) === null || _a === void 0
    	? void 0
    	: _a.getData('application/x-lexical-drag');

    	if (!dragData) {
    		return null;
    	}

    	const { type, data } = JSON.parse(dragData);

    	if (type !== 'image') {
    		return null;
    	}

    	return data;
    }

    function canDropImage(event) {
    	const target = event.target;
    	return !!(target && target instanceof HTMLElement && !target.closest('code, span.editor-image') && target.parentElement && target.parentElement.closest('div.ContentEditable__root'));
    }

    function getDragSelection(event) {
    	let range;
    	const target = event.target;

    	const targetWindow = target == null
    	? null
    	: target.nodeType === 9
    		? target.defaultView
    		: target.ownerDocument.defaultView;

    	const domSelection = getDOMSelection(targetWindow);

    	if (document.caretRangeFromPoint) {
    		range = document.caretRangeFromPoint(event.clientX, event.clientY);
    	} else if (event.rangeParent && domSelection !== null) {
    		domSelection.collapse(event.rangeParent, event.rangeOffset || 0);
    		range = domSelection.getRangeAt(0);
    	} else {
    		throw Error(`Cannot get the selection when dragging`);
    	}

    	return range;
    }

    function instance$s($$self) {
    	const editor = getContext('editor');

    	onMount(() => {
    		if (!editor.hasNodes([ImageNode])) {
    			throw new Error('ImagesPlugin: ImageNode not registered on editor');
    		}

    		return LexicalUtils_1.mergeRegister(
    			editor.registerCommand(
    				INSERT_IMAGE_COMMAND,
    				payload => {
    					const imageNode = $createImageNode(payload);
    					Lexical_1.$insertNodes([imageNode]);

    					if (Lexical_1.$isRootOrShadowRoot(imageNode.getParentOrThrow())) {
    						LexicalUtils_1.$wrapNodeInElement(imageNode, Lexical_1.$createParagraphNode).selectEnd();
    					}

    					return true;
    				},
    				Lexical_1.COMMAND_PRIORITY_EDITOR
    			),
    			editor.registerCommand(
    				Lexical_1.DRAGSTART_COMMAND,
    				event => {
    					return onDragStart(event);
    				},
    				Lexical_1.COMMAND_PRIORITY_HIGH
    			),
    			editor.registerCommand(
    				Lexical_1.DRAGOVER_COMMAND,
    				event => {
    					return onDragover(event);
    				},
    				Lexical_1.COMMAND_PRIORITY_LOW
    			),
    			editor.registerCommand(
    				Lexical_1.DROP_COMMAND,
    				event => {
    					return onDrop(event, editor);
    				},
    				Lexical_1.COMMAND_PRIORITY_HIGH
    			)
    		);
    	});

    	const img = document.createElement('img');
    	img.src = TRANSPARENT_IMAGE;

    	function onDragStart(event) {
    		const node = getImageNodeInSelection();

    		if (!node) {
    			return false;
    		}

    		const dataTransfer = event.dataTransfer;

    		if (!dataTransfer) {
    			return false;
    		}

    		dataTransfer.setData('text/plain', '_');
    		dataTransfer.setDragImage(img, 0, 0);

    		dataTransfer.setData('application/x-lexical-drag', JSON.stringify({
    			data: {
    				altText: node.__altText,
    				caption: node.__caption,
    				height: node.__height,
    				key: node.getKey(),
    				maxWidth: node.__maxWidth,
    				showCaption: node.__showCaption,
    				src: node.__src,
    				width: node.__width
    			},
    			type: 'image'
    		}));

    		return true;
    	}

    	function onDragover(event) {
    		const node = getImageNodeInSelection();

    		if (!node) {
    			return false;
    		}

    		if (!canDropImage(event)) {
    			event.preventDefault();
    		}

    		return true;
    	}

    	function onDrop(event, editor) {
    		const node = getImageNodeInSelection();

    		if (!node) {
    			return false;
    		}

    		const data = getDragImageData(event);

    		if (!data) {
    			return false;
    		}

    		event.preventDefault();

    		if (canDropImage(event)) {
    			const range = getDragSelection(event);
    			node.remove();
    			const rangeSelection = Lexical_1.$createRangeSelection();

    			if (range !== null && range !== undefined) {
    				rangeSelection.applyDOMRange(range);
    			}

    			Lexical_1.$setSelection(rangeSelection);
    			editor.dispatchCommand(INSERT_IMAGE_COMMAND, data);
    		}

    		return true;
    	}

    	function getImageNodeInSelection() {
    		const selection = Lexical_1.$getSelection();

    		if (!Lexical_1.$isNodeSelection(selection)) {
    			return null;
    		}

    		const nodes = selection.getNodes();
    		const node = nodes[0];
    		return $isImageNode(node) ? node : null;
    	}

    	return [];
    }

    class ImagePlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$s, null, safe_not_equal, {});
    	}
    }

    var LexicalSelectionExports = requireLexicalSelection();

    var LexicalCode_dev = {};

    var prismExports = {};
    var prism = {
      get exports(){ return prismExports; },
      set exports(v){ prismExports = v; },
    };

    var hasRequiredPrism;

    function requirePrism () {
    	if (hasRequiredPrism) return prismExports;
    	hasRequiredPrism = 1;
    	(function (module) {
    		/* **********************************************
    		     Begin prism-core.js
    		********************************************** */

    		/// <reference lib="WebWorker"/>

    		var _self = (typeof window !== 'undefined')
    			? window   // if in browser
    			: (
    				(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
    					? self // if in worker
    					: {}   // if in node js
    			);

    		/**
    		 * Prism: Lightweight, robust, elegant syntax highlighting
    		 *
    		 * @license MIT <https://opensource.org/licenses/MIT>
    		 * @author Lea Verou <https://lea.verou.me>
    		 * @namespace
    		 * @public
    		 */
    		var Prism = (function (_self) {

    			// Private helper vars
    			var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    			var uniqueId = 0;

    			// The grammar object for plaintext
    			var plainTextGrammar = {};


    			var _ = {
    				/**
    				 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
    				 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
    				 * additional languages or plugins yourself.
    				 *
    				 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
    				 *
    				 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
    				 * empty Prism object into the global scope before loading the Prism script like this:
    				 *
    				 * ```js
    				 * window.Prism = window.Prism || {};
    				 * Prism.manual = true;
    				 * // add a new <script> to load Prism's script
    				 * ```
    				 *
    				 * @default false
    				 * @type {boolean}
    				 * @memberof Prism
    				 * @public
    				 */
    				manual: _self.Prism && _self.Prism.manual,
    				/**
    				 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
    				 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
    				 * own worker, you don't want it to do this.
    				 *
    				 * By setting this value to `true`, Prism will not add its own listeners to the worker.
    				 *
    				 * You obviously have to change this value before Prism executes. To do this, you can add an
    				 * empty Prism object into the global scope before loading the Prism script like this:
    				 *
    				 * ```js
    				 * window.Prism = window.Prism || {};
    				 * Prism.disableWorkerMessageHandler = true;
    				 * // Load Prism's script
    				 * ```
    				 *
    				 * @default false
    				 * @type {boolean}
    				 * @memberof Prism
    				 * @public
    				 */
    				disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

    				/**
    				 * A namespace for utility methods.
    				 *
    				 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
    				 * change or disappear at any time.
    				 *
    				 * @namespace
    				 * @memberof Prism
    				 */
    				util: {
    					encode: function encode(tokens) {
    						if (tokens instanceof Token) {
    							return new Token(tokens.type, encode(tokens.content), tokens.alias);
    						} else if (Array.isArray(tokens)) {
    							return tokens.map(encode);
    						} else {
    							return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
    						}
    					},

    					/**
    					 * Returns the name of the type of the given value.
    					 *
    					 * @param {any} o
    					 * @returns {string}
    					 * @example
    					 * type(null)      === 'Null'
    					 * type(undefined) === 'Undefined'
    					 * type(123)       === 'Number'
    					 * type('foo')     === 'String'
    					 * type(true)      === 'Boolean'
    					 * type([1, 2])    === 'Array'
    					 * type({})        === 'Object'
    					 * type(String)    === 'Function'
    					 * type(/abc+/)    === 'RegExp'
    					 */
    					type: function (o) {
    						return Object.prototype.toString.call(o).slice(8, -1);
    					},

    					/**
    					 * Returns a unique number for the given object. Later calls will still return the same number.
    					 *
    					 * @param {Object} obj
    					 * @returns {number}
    					 */
    					objId: function (obj) {
    						if (!obj['__id']) {
    							Object.defineProperty(obj, '__id', { value: ++uniqueId });
    						}
    						return obj['__id'];
    					},

    					/**
    					 * Creates a deep clone of the given object.
    					 *
    					 * The main intended use of this function is to clone language definitions.
    					 *
    					 * @param {T} o
    					 * @param {Record<number, any>} [visited]
    					 * @returns {T}
    					 * @template T
    					 */
    					clone: function deepClone(o, visited) {
    						visited = visited || {};

    						var clone; var id;
    						switch (_.util.type(o)) {
    							case 'Object':
    								id = _.util.objId(o);
    								if (visited[id]) {
    									return visited[id];
    								}
    								clone = /** @type {Record<string, any>} */ ({});
    								visited[id] = clone;

    								for (var key in o) {
    									if (o.hasOwnProperty(key)) {
    										clone[key] = deepClone(o[key], visited);
    									}
    								}

    								return /** @type {any} */ (clone);

    							case 'Array':
    								id = _.util.objId(o);
    								if (visited[id]) {
    									return visited[id];
    								}
    								clone = [];
    								visited[id] = clone;

    								(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
    									clone[i] = deepClone(v, visited);
    								});

    								return /** @type {any} */ (clone);

    							default:
    								return o;
    						}
    					},

    					/**
    					 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
    					 *
    					 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
    					 *
    					 * @param {Element} element
    					 * @returns {string}
    					 */
    					getLanguage: function (element) {
    						while (element) {
    							var m = lang.exec(element.className);
    							if (m) {
    								return m[1].toLowerCase();
    							}
    							element = element.parentElement;
    						}
    						return 'none';
    					},

    					/**
    					 * Sets the Prism `language-xxxx` class of the given element.
    					 *
    					 * @param {Element} element
    					 * @param {string} language
    					 * @returns {void}
    					 */
    					setLanguage: function (element, language) {
    						// remove all `language-xxxx` classes
    						// (this might leave behind a leading space)
    						element.className = element.className.replace(RegExp(lang, 'gi'), '');

    						// add the new `language-xxxx` class
    						// (using `classList` will automatically clean up spaces for us)
    						element.classList.add('language-' + language);
    					},

    					/**
    					 * Returns the script element that is currently executing.
    					 *
    					 * This does __not__ work for line script element.
    					 *
    					 * @returns {HTMLScriptElement | null}
    					 */
    					currentScript: function () {
    						if (typeof document === 'undefined') {
    							return null;
    						}
    						if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
    							return /** @type {any} */ (document.currentScript);
    						}

    						// IE11 workaround
    						// we'll get the src of the current script by parsing IE11's error stack trace
    						// this will not work for inline scripts

    						try {
    							throw new Error();
    						} catch (err) {
    							// Get file src url from stack. Specifically works with the format of stack traces in IE.
    							// A stack will look like this:
    							//
    							// Error
    							//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
    							//    at Global code (http://localhost/components/prism-core.js:606:1)

    							var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
    							if (src) {
    								var scripts = document.getElementsByTagName('script');
    								for (var i in scripts) {
    									if (scripts[i].src == src) {
    										return scripts[i];
    									}
    								}
    							}
    							return null;
    						}
    					},

    					/**
    					 * Returns whether a given class is active for `element`.
    					 *
    					 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
    					 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
    					 * given class is just the given class with a `no-` prefix.
    					 *
    					 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
    					 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
    					 * ancestors have the given class or the negated version of it, then the default activation will be returned.
    					 *
    					 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
    					 * version of it, the class is considered active.
    					 *
    					 * @param {Element} element
    					 * @param {string} className
    					 * @param {boolean} [defaultActivation=false]
    					 * @returns {boolean}
    					 */
    					isActive: function (element, className, defaultActivation) {
    						var no = 'no-' + className;

    						while (element) {
    							var classList = element.classList;
    							if (classList.contains(className)) {
    								return true;
    							}
    							if (classList.contains(no)) {
    								return false;
    							}
    							element = element.parentElement;
    						}
    						return !!defaultActivation;
    					}
    				},

    				/**
    				 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
    				 *
    				 * @namespace
    				 * @memberof Prism
    				 * @public
    				 */
    				languages: {
    					/**
    					 * The grammar for plain, unformatted text.
    					 */
    					plain: plainTextGrammar,
    					plaintext: plainTextGrammar,
    					text: plainTextGrammar,
    					txt: plainTextGrammar,

    					/**
    					 * Creates a deep copy of the language with the given id and appends the given tokens.
    					 *
    					 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
    					 * will be overwritten at its original position.
    					 *
    					 * ## Best practices
    					 *
    					 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
    					 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
    					 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
    					 *
    					 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
    					 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
    					 *
    					 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
    					 * @param {Grammar} redef The new tokens to append.
    					 * @returns {Grammar} The new language created.
    					 * @public
    					 * @example
    					 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
    					 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
    					 *     // at its original position
    					 *     'comment': { ... },
    					 *     // CSS doesn't have a 'color' token, so this token will be appended
    					 *     'color': /\b(?:red|green|blue)\b/
    					 * });
    					 */
    					extend: function (id, redef) {
    						var lang = _.util.clone(_.languages[id]);

    						for (var key in redef) {
    							lang[key] = redef[key];
    						}

    						return lang;
    					},

    					/**
    					 * Inserts tokens _before_ another token in a language definition or any other grammar.
    					 *
    					 * ## Usage
    					 *
    					 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
    					 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
    					 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
    					 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
    					 * this:
    					 *
    					 * ```js
    					 * Prism.languages.markup.style = {
    					 *     // token
    					 * };
    					 * ```
    					 *
    					 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
    					 * before existing tokens. For the CSS example above, you would use it like this:
    					 *
    					 * ```js
    					 * Prism.languages.insertBefore('markup', 'cdata', {
    					 *     'style': {
    					 *         // token
    					 *     }
    					 * });
    					 * ```
    					 *
    					 * ## Special cases
    					 *
    					 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
    					 * will be ignored.
    					 *
    					 * This behavior can be used to insert tokens after `before`:
    					 *
    					 * ```js
    					 * Prism.languages.insertBefore('markup', 'comment', {
    					 *     'comment': Prism.languages.markup.comment,
    					 *     // tokens after 'comment'
    					 * });
    					 * ```
    					 *
    					 * ## Limitations
    					 *
    					 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
    					 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
    					 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
    					 * deleting properties which is necessary to insert at arbitrary positions.
    					 *
    					 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
    					 * Instead, it will create a new object and replace all references to the target object with the new one. This
    					 * can be done without temporarily deleting properties, so the iteration order is well-defined.
    					 *
    					 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
    					 * you hold the target object in a variable, then the value of the variable will not change.
    					 *
    					 * ```js
    					 * var oldMarkup = Prism.languages.markup;
    					 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
    					 *
    					 * assert(oldMarkup !== Prism.languages.markup);
    					 * assert(newMarkup === Prism.languages.markup);
    					 * ```
    					 *
    					 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
    					 * object to be modified.
    					 * @param {string} before The key to insert before.
    					 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
    					 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
    					 * object to be modified.
    					 *
    					 * Defaults to `Prism.languages`.
    					 * @returns {Grammar} The new grammar object.
    					 * @public
    					 */
    					insertBefore: function (inside, before, insert, root) {
    						root = root || /** @type {any} */ (_.languages);
    						var grammar = root[inside];
    						/** @type {Grammar} */
    						var ret = {};

    						for (var token in grammar) {
    							if (grammar.hasOwnProperty(token)) {

    								if (token == before) {
    									for (var newToken in insert) {
    										if (insert.hasOwnProperty(newToken)) {
    											ret[newToken] = insert[newToken];
    										}
    									}
    								}

    								// Do not insert token which also occur in insert. See #1525
    								if (!insert.hasOwnProperty(token)) {
    									ret[token] = grammar[token];
    								}
    							}
    						}

    						var old = root[inside];
    						root[inside] = ret;

    						// Update references in other language definitions
    						_.languages.DFS(_.languages, function (key, value) {
    							if (value === old && key != inside) {
    								this[key] = ret;
    							}
    						});

    						return ret;
    					},

    					// Traverse a language definition with Depth First Search
    					DFS: function DFS(o, callback, type, visited) {
    						visited = visited || {};

    						var objId = _.util.objId;

    						for (var i in o) {
    							if (o.hasOwnProperty(i)) {
    								callback.call(o, i, o[i], type || i);

    								var property = o[i];
    								var propertyType = _.util.type(property);

    								if (propertyType === 'Object' && !visited[objId(property)]) {
    									visited[objId(property)] = true;
    									DFS(property, callback, null, visited);
    								} else if (propertyType === 'Array' && !visited[objId(property)]) {
    									visited[objId(property)] = true;
    									DFS(property, callback, i, visited);
    								}
    							}
    						}
    					}
    				},

    				plugins: {},

    				/**
    				 * This is the most high-level function in Prism’s API.
    				 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
    				 * each one of them.
    				 *
    				 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
    				 *
    				 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
    				 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
    				 * @memberof Prism
    				 * @public
    				 */
    				highlightAll: function (async, callback) {
    					_.highlightAllUnder(document, async, callback);
    				},

    				/**
    				 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
    				 * {@link Prism.highlightElement} on each one of them.
    				 *
    				 * The following hooks will be run:
    				 * 1. `before-highlightall`
    				 * 2. `before-all-elements-highlight`
    				 * 3. All hooks of {@link Prism.highlightElement} for each element.
    				 *
    				 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
    				 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
    				 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
    				 * @memberof Prism
    				 * @public
    				 */
    				highlightAllUnder: function (container, async, callback) {
    					var env = {
    						callback: callback,
    						container: container,
    						selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    					};

    					_.hooks.run('before-highlightall', env);

    					env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

    					_.hooks.run('before-all-elements-highlight', env);

    					for (var i = 0, element; (element = env.elements[i++]);) {
    						_.highlightElement(element, async === true, env.callback);
    					}
    				},

    				/**
    				 * Highlights the code inside a single element.
    				 *
    				 * The following hooks will be run:
    				 * 1. `before-sanity-check`
    				 * 2. `before-highlight`
    				 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
    				 * 4. `before-insert`
    				 * 5. `after-highlight`
    				 * 6. `complete`
    				 *
    				 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
    				 * the element's language.
    				 *
    				 * @param {Element} element The element containing the code.
    				 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
    				 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
    				 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
    				 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
    				 *
    				 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
    				 * asynchronous highlighting to work. You can build your own bundle on the
    				 * [Download page](https://prismjs.com/download.html).
    				 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
    				 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
    				 * @memberof Prism
    				 * @public
    				 */
    				highlightElement: function (element, async, callback) {
    					// Find language
    					var language = _.util.getLanguage(element);
    					var grammar = _.languages[language];

    					// Set language on the element, if not present
    					_.util.setLanguage(element, language);

    					// Set language on the parent, for styling
    					var parent = element.parentElement;
    					if (parent && parent.nodeName.toLowerCase() === 'pre') {
    						_.util.setLanguage(parent, language);
    					}

    					var code = element.textContent;

    					var env = {
    						element: element,
    						language: language,
    						grammar: grammar,
    						code: code
    					};

    					function insertHighlightedCode(highlightedCode) {
    						env.highlightedCode = highlightedCode;

    						_.hooks.run('before-insert', env);

    						env.element.innerHTML = env.highlightedCode;

    						_.hooks.run('after-highlight', env);
    						_.hooks.run('complete', env);
    						callback && callback.call(env.element);
    					}

    					_.hooks.run('before-sanity-check', env);

    					// plugins may change/add the parent/element
    					parent = env.element.parentElement;
    					if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
    						parent.setAttribute('tabindex', '0');
    					}

    					if (!env.code) {
    						_.hooks.run('complete', env);
    						callback && callback.call(env.element);
    						return;
    					}

    					_.hooks.run('before-highlight', env);

    					if (!env.grammar) {
    						insertHighlightedCode(_.util.encode(env.code));
    						return;
    					}

    					if (async && _self.Worker) {
    						var worker = new Worker(_.filename);

    						worker.onmessage = function (evt) {
    							insertHighlightedCode(evt.data);
    						};

    						worker.postMessage(JSON.stringify({
    							language: env.language,
    							code: env.code,
    							immediateClose: true
    						}));
    					} else {
    						insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
    					}
    				},

    				/**
    				 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
    				 * and the language definitions to use, and returns a string with the HTML produced.
    				 *
    				 * The following hooks will be run:
    				 * 1. `before-tokenize`
    				 * 2. `after-tokenize`
    				 * 3. `wrap`: On each {@link Token}.
    				 *
    				 * @param {string} text A string with the code to be highlighted.
    				 * @param {Grammar} grammar An object containing the tokens to use.
    				 *
    				 * Usually a language definition like `Prism.languages.markup`.
    				 * @param {string} language The name of the language definition passed to `grammar`.
    				 * @returns {string} The highlighted HTML.
    				 * @memberof Prism
    				 * @public
    				 * @example
    				 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
    				 */
    				highlight: function (text, grammar, language) {
    					var env = {
    						code: text,
    						grammar: grammar,
    						language: language
    					};
    					_.hooks.run('before-tokenize', env);
    					if (!env.grammar) {
    						throw new Error('The language "' + env.language + '" has no grammar.');
    					}
    					env.tokens = _.tokenize(env.code, env.grammar);
    					_.hooks.run('after-tokenize', env);
    					return Token.stringify(_.util.encode(env.tokens), env.language);
    				},

    				/**
    				 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
    				 * and the language definitions to use, and returns an array with the tokenized code.
    				 *
    				 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
    				 *
    				 * This method could be useful in other contexts as well, as a very crude parser.
    				 *
    				 * @param {string} text A string with the code to be highlighted.
    				 * @param {Grammar} grammar An object containing the tokens to use.
    				 *
    				 * Usually a language definition like `Prism.languages.markup`.
    				 * @returns {TokenStream} An array of strings and tokens, a token stream.
    				 * @memberof Prism
    				 * @public
    				 * @example
    				 * let code = `var foo = 0;`;
    				 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
    				 * tokens.forEach(token => {
    				 *     if (token instanceof Prism.Token && token.type === 'number') {
    				 *         console.log(`Found numeric literal: ${token.content}`);
    				 *     }
    				 * });
    				 */
    				tokenize: function (text, grammar) {
    					var rest = grammar.rest;
    					if (rest) {
    						for (var token in rest) {
    							grammar[token] = rest[token];
    						}

    						delete grammar.rest;
    					}

    					var tokenList = new LinkedList();
    					addAfter(tokenList, tokenList.head, text);

    					matchGrammar(text, tokenList, grammar, tokenList.head, 0);

    					return toArray(tokenList);
    				},

    				/**
    				 * @namespace
    				 * @memberof Prism
    				 * @public
    				 */
    				hooks: {
    					all: {},

    					/**
    					 * Adds the given callback to the list of callbacks for the given hook.
    					 *
    					 * The callback will be invoked when the hook it is registered for is run.
    					 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
    					 *
    					 * One callback function can be registered to multiple hooks and the same hook multiple times.
    					 *
    					 * @param {string} name The name of the hook.
    					 * @param {HookCallback} callback The callback function which is given environment variables.
    					 * @public
    					 */
    					add: function (name, callback) {
    						var hooks = _.hooks.all;

    						hooks[name] = hooks[name] || [];

    						hooks[name].push(callback);
    					},

    					/**
    					 * Runs a hook invoking all registered callbacks with the given environment variables.
    					 *
    					 * Callbacks will be invoked synchronously and in the order in which they were registered.
    					 *
    					 * @param {string} name The name of the hook.
    					 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
    					 * @public
    					 */
    					run: function (name, env) {
    						var callbacks = _.hooks.all[name];

    						if (!callbacks || !callbacks.length) {
    							return;
    						}

    						for (var i = 0, callback; (callback = callbacks[i++]);) {
    							callback(env);
    						}
    					}
    				},

    				Token: Token
    			};
    			_self.Prism = _;


    			// Typescript note:
    			// The following can be used to import the Token type in JSDoc:
    			//
    			//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

    			/**
    			 * Creates a new token.
    			 *
    			 * @param {string} type See {@link Token#type type}
    			 * @param {string | TokenStream} content See {@link Token#content content}
    			 * @param {string|string[]} [alias] The alias(es) of the token.
    			 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
    			 * @class
    			 * @global
    			 * @public
    			 */
    			function Token(type, content, alias, matchedStr) {
    				/**
    				 * The type of the token.
    				 *
    				 * This is usually the key of a pattern in a {@link Grammar}.
    				 *
    				 * @type {string}
    				 * @see GrammarToken
    				 * @public
    				 */
    				this.type = type;
    				/**
    				 * The strings or tokens contained by this token.
    				 *
    				 * This will be a token stream if the pattern matched also defined an `inside` grammar.
    				 *
    				 * @type {string | TokenStream}
    				 * @public
    				 */
    				this.content = content;
    				/**
    				 * The alias(es) of the token.
    				 *
    				 * @type {string|string[]}
    				 * @see GrammarToken
    				 * @public
    				 */
    				this.alias = alias;
    				// Copy of the full string this token was created from
    				this.length = (matchedStr || '').length | 0;
    			}

    			/**
    			 * A token stream is an array of strings and {@link Token Token} objects.
    			 *
    			 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
    			 * them.
    			 *
    			 * 1. No adjacent strings.
    			 * 2. No empty strings.
    			 *
    			 *    The only exception here is the token stream that only contains the empty string and nothing else.
    			 *
    			 * @typedef {Array<string | Token>} TokenStream
    			 * @global
    			 * @public
    			 */

    			/**
    			 * Converts the given token or token stream to an HTML representation.
    			 *
    			 * The following hooks will be run:
    			 * 1. `wrap`: On each {@link Token}.
    			 *
    			 * @param {string | Token | TokenStream} o The token or token stream to be converted.
    			 * @param {string} language The name of current language.
    			 * @returns {string} The HTML representation of the token or token stream.
    			 * @memberof Token
    			 * @static
    			 */
    			Token.stringify = function stringify(o, language) {
    				if (typeof o == 'string') {
    					return o;
    				}
    				if (Array.isArray(o)) {
    					var s = '';
    					o.forEach(function (e) {
    						s += stringify(e, language);
    					});
    					return s;
    				}

    				var env = {
    					type: o.type,
    					content: stringify(o.content, language),
    					tag: 'span',
    					classes: ['token', o.type],
    					attributes: {},
    					language: language
    				};

    				var aliases = o.alias;
    				if (aliases) {
    					if (Array.isArray(aliases)) {
    						Array.prototype.push.apply(env.classes, aliases);
    					} else {
    						env.classes.push(aliases);
    					}
    				}

    				_.hooks.run('wrap', env);

    				var attributes = '';
    				for (var name in env.attributes) {
    					attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    				}

    				return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
    			};

    			/**
    			 * @param {RegExp} pattern
    			 * @param {number} pos
    			 * @param {string} text
    			 * @param {boolean} lookbehind
    			 * @returns {RegExpExecArray | null}
    			 */
    			function matchPattern(pattern, pos, text, lookbehind) {
    				pattern.lastIndex = pos;
    				var match = pattern.exec(text);
    				if (match && lookbehind && match[1]) {
    					// change the match to remove the text matched by the Prism lookbehind group
    					var lookbehindLength = match[1].length;
    					match.index += lookbehindLength;
    					match[0] = match[0].slice(lookbehindLength);
    				}
    				return match;
    			}

    			/**
    			 * @param {string} text
    			 * @param {LinkedList<string | Token>} tokenList
    			 * @param {any} grammar
    			 * @param {LinkedListNode<string | Token>} startNode
    			 * @param {number} startPos
    			 * @param {RematchOptions} [rematch]
    			 * @returns {void}
    			 * @private
    			 *
    			 * @typedef RematchOptions
    			 * @property {string} cause
    			 * @property {number} reach
    			 */
    			function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    				for (var token in grammar) {
    					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
    						continue;
    					}

    					var patterns = grammar[token];
    					patterns = Array.isArray(patterns) ? patterns : [patterns];

    					for (var j = 0; j < patterns.length; ++j) {
    						if (rematch && rematch.cause == token + ',' + j) {
    							return;
    						}

    						var patternObj = patterns[j];
    						var inside = patternObj.inside;
    						var lookbehind = !!patternObj.lookbehind;
    						var greedy = !!patternObj.greedy;
    						var alias = patternObj.alias;

    						if (greedy && !patternObj.pattern.global) {
    							// Without the global flag, lastIndex won't work
    							var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
    							patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
    						}

    						/** @type {RegExp} */
    						var pattern = patternObj.pattern || patternObj;

    						for ( // iterate the token list and keep track of the current token/string position
    							var currentNode = startNode.next, pos = startPos;
    							currentNode !== tokenList.tail;
    							pos += currentNode.value.length, currentNode = currentNode.next
    						) {

    							if (rematch && pos >= rematch.reach) {
    								break;
    							}

    							var str = currentNode.value;

    							if (tokenList.length > text.length) {
    								// Something went terribly wrong, ABORT, ABORT!
    								return;
    							}

    							if (str instanceof Token) {
    								continue;
    							}

    							var removeCount = 1; // this is the to parameter of removeBetween
    							var match;

    							if (greedy) {
    								match = matchPattern(pattern, pos, text, lookbehind);
    								if (!match || match.index >= text.length) {
    									break;
    								}

    								var from = match.index;
    								var to = match.index + match[0].length;
    								var p = pos;

    								// find the node that contains the match
    								p += currentNode.value.length;
    								while (from >= p) {
    									currentNode = currentNode.next;
    									p += currentNode.value.length;
    								}
    								// adjust pos (and p)
    								p -= currentNode.value.length;
    								pos = p;

    								// the current node is a Token, then the match starts inside another Token, which is invalid
    								if (currentNode.value instanceof Token) {
    									continue;
    								}

    								// find the last node which is affected by this match
    								for (
    									var k = currentNode;
    									k !== tokenList.tail && (p < to || typeof k.value === 'string');
    									k = k.next
    								) {
    									removeCount++;
    									p += k.value.length;
    								}
    								removeCount--;

    								// replace with the new match
    								str = text.slice(pos, p);
    								match.index -= pos;
    							} else {
    								match = matchPattern(pattern, 0, str, lookbehind);
    								if (!match) {
    									continue;
    								}
    							}

    							// eslint-disable-next-line no-redeclare
    							var from = match.index;
    							var matchStr = match[0];
    							var before = str.slice(0, from);
    							var after = str.slice(from + matchStr.length);

    							var reach = pos + str.length;
    							if (rematch && reach > rematch.reach) {
    								rematch.reach = reach;
    							}

    							var removeFrom = currentNode.prev;

    							if (before) {
    								removeFrom = addAfter(tokenList, removeFrom, before);
    								pos += before.length;
    							}

    							removeRange(tokenList, removeFrom, removeCount);

    							var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
    							currentNode = addAfter(tokenList, removeFrom, wrapped);

    							if (after) {
    								addAfter(tokenList, currentNode, after);
    							}

    							if (removeCount > 1) {
    								// at least one Token object was removed, so we have to do some rematching
    								// this can only happen if the current pattern is greedy

    								/** @type {RematchOptions} */
    								var nestedRematch = {
    									cause: token + ',' + j,
    									reach: reach
    								};
    								matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

    								// the reach might have been extended because of the rematching
    								if (rematch && nestedRematch.reach > rematch.reach) {
    									rematch.reach = nestedRematch.reach;
    								}
    							}
    						}
    					}
    				}
    			}

    			/**
    			 * @typedef LinkedListNode
    			 * @property {T} value
    			 * @property {LinkedListNode<T> | null} prev The previous node.
    			 * @property {LinkedListNode<T> | null} next The next node.
    			 * @template T
    			 * @private
    			 */

    			/**
    			 * @template T
    			 * @private
    			 */
    			function LinkedList() {
    				/** @type {LinkedListNode<T>} */
    				var head = { value: null, prev: null, next: null };
    				/** @type {LinkedListNode<T>} */
    				var tail = { value: null, prev: head, next: null };
    				head.next = tail;

    				/** @type {LinkedListNode<T>} */
    				this.head = head;
    				/** @type {LinkedListNode<T>} */
    				this.tail = tail;
    				this.length = 0;
    			}

    			/**
    			 * Adds a new node with the given value to the list.
    			 *
    			 * @param {LinkedList<T>} list
    			 * @param {LinkedListNode<T>} node
    			 * @param {T} value
    			 * @returns {LinkedListNode<T>} The added node.
    			 * @template T
    			 */
    			function addAfter(list, node, value) {
    				// assumes that node != list.tail && values.length >= 0
    				var next = node.next;

    				var newNode = { value: value, prev: node, next: next };
    				node.next = newNode;
    				next.prev = newNode;
    				list.length++;

    				return newNode;
    			}
    			/**
    			 * Removes `count` nodes after the given node. The given node will not be removed.
    			 *
    			 * @param {LinkedList<T>} list
    			 * @param {LinkedListNode<T>} node
    			 * @param {number} count
    			 * @template T
    			 */
    			function removeRange(list, node, count) {
    				var next = node.next;
    				for (var i = 0; i < count && next !== list.tail; i++) {
    					next = next.next;
    				}
    				node.next = next;
    				next.prev = node;
    				list.length -= i;
    			}
    			/**
    			 * @param {LinkedList<T>} list
    			 * @returns {T[]}
    			 * @template T
    			 */
    			function toArray(list) {
    				var array = [];
    				var node = list.head.next;
    				while (node !== list.tail) {
    					array.push(node.value);
    					node = node.next;
    				}
    				return array;
    			}


    			if (!_self.document) {
    				if (!_self.addEventListener) {
    					// in Node.js
    					return _;
    				}

    				if (!_.disableWorkerMessageHandler) {
    					// In worker
    					_self.addEventListener('message', function (evt) {
    						var message = JSON.parse(evt.data);
    						var lang = message.language;
    						var code = message.code;
    						var immediateClose = message.immediateClose;

    						_self.postMessage(_.highlight(code, _.languages[lang], lang));
    						if (immediateClose) {
    							_self.close();
    						}
    					}, false);
    				}

    				return _;
    			}

    			// Get current script and highlight
    			var script = _.util.currentScript();

    			if (script) {
    				_.filename = script.src;

    				if (script.hasAttribute('data-manual')) {
    					_.manual = true;
    				}
    			}

    			function highlightAutomaticallyCallback() {
    				if (!_.manual) {
    					_.highlightAll();
    				}
    			}

    			if (!_.manual) {
    				// If the document state is "loading", then we'll use DOMContentLoaded.
    				// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
    				// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
    				// might take longer one animation frame to execute which can create a race condition where only some plugins have
    				// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
    				// See https://github.com/PrismJS/prism/issues/2102
    				var readyState = document.readyState;
    				if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
    					document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
    				} else {
    					if (window.requestAnimationFrame) {
    						window.requestAnimationFrame(highlightAutomaticallyCallback);
    					} else {
    						window.setTimeout(highlightAutomaticallyCallback, 16);
    					}
    				}
    			}

    			return _;

    		}(_self));

    		if (module.exports) {
    			module.exports = Prism;
    		}

    		// hack for components to work correctly in node.js
    		if (typeof commonjsGlobal !== 'undefined') {
    			commonjsGlobal.Prism = Prism;
    		}

    		// some additional documentation/types

    		/**
    		 * The expansion of a simple `RegExp` literal to support additional properties.
    		 *
    		 * @typedef GrammarToken
    		 * @property {RegExp} pattern The regular expression of the token.
    		 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
    		 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
    		 * @property {boolean} [greedy=false] Whether the token is greedy.
    		 * @property {string|string[]} [alias] An optional alias or list of aliases.
    		 * @property {Grammar} [inside] The nested grammar of this token.
    		 *
    		 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
    		 *
    		 * This can be used to make nested and even recursive language definitions.
    		 *
    		 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
    		 * each another.
    		 * @global
    		 * @public
    		 */

    		/**
    		 * @typedef Grammar
    		 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
    		 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
    		 * @global
    		 * @public
    		 */

    		/**
    		 * A function which will invoked after an element was successfully highlighted.
    		 *
    		 * @callback HighlightCallback
    		 * @param {Element} element The element successfully highlighted.
    		 * @returns {void}
    		 * @global
    		 * @public
    		 */

    		/**
    		 * @callback HookCallback
    		 * @param {Object<string, any>} env The environment variables of the hook.
    		 * @returns {void}
    		 * @global
    		 * @public
    		 */


    		/* **********************************************
    		     Begin prism-markup.js
    		********************************************** */

    		Prism.languages.markup = {
    			'comment': {
    				pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    				greedy: true
    			},
    			'prolog': {
    				pattern: /<\?[\s\S]+?\?>/,
    				greedy: true
    			},
    			'doctype': {
    				// https://www.w3.org/TR/xml/#NT-doctypedecl
    				pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    				greedy: true,
    				inside: {
    					'internal-subset': {
    						pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
    						lookbehind: true,
    						greedy: true,
    						inside: null // see below
    					},
    					'string': {
    						pattern: /"[^"]*"|'[^']*'/,
    						greedy: true
    					},
    					'punctuation': /^<!|>$|[[\]]/,
    					'doctype-tag': /^DOCTYPE/i,
    					'name': /[^\s<>'"]+/
    				}
    			},
    			'cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				greedy: true
    			},
    			'tag': {
    				pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    				greedy: true,
    				inside: {
    					'tag': {
    						pattern: /^<\/?[^\s>\/]+/,
    						inside: {
    							'punctuation': /^<\/?/,
    							'namespace': /^[^\s>\/:]+:/
    						}
    					},
    					'special-attr': [],
    					'attr-value': {
    						pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
    						inside: {
    							'punctuation': [
    								{
    									pattern: /^=/,
    									alias: 'attr-equals'
    								},
    								{
    									pattern: /^(\s*)["']|["']$/,
    									lookbehind: true
    								}
    							]
    						}
    					},
    					'punctuation': /\/?>/,
    					'attr-name': {
    						pattern: /[^\s>\/]+/,
    						inside: {
    							'namespace': /^[^\s>\/:]+:/
    						}
    					}

    				}
    			},
    			'entity': [
    				{
    					pattern: /&[\da-z]{1,8};/i,
    					alias: 'named-entity'
    				},
    				/&#x?[\da-f]{1,8};/i
    			]
    		};

    		Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    			Prism.languages.markup['entity'];
    		Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    		// Plugin to make entity title show the real entity, idea by Roman Komarov
    		Prism.hooks.add('wrap', function (env) {

    			if (env.type === 'entity') {
    				env.attributes['title'] = env.content.replace(/&amp;/, '&');
    			}
    		});

    		Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    			/**
    			 * Adds an inlined language to markup.
    			 *
    			 * An example of an inlined language is CSS with `<style>` tags.
    			 *
    			 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    			 * case insensitive.
    			 * @param {string} lang The language key.
    			 * @example
    			 * addInlined('style', 'css');
    			 */
    			value: function addInlined(tagName, lang) {
    				var includedCdataInside = {};
    				includedCdataInside['language-' + lang] = {
    					pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    					lookbehind: true,
    					inside: Prism.languages[lang]
    				};
    				includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    				var inside = {
    					'included-cdata': {
    						pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    						inside: includedCdataInside
    					}
    				};
    				inside['language-' + lang] = {
    					pattern: /[\s\S]+/,
    					inside: Prism.languages[lang]
    				};

    				var def = {};
    				def[tagName] = {
    					pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
    					lookbehind: true,
    					greedy: true,
    					inside: inside
    				};

    				Prism.languages.insertBefore('markup', 'cdata', def);
    			}
    		});
    		Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    			/**
    			 * Adds an pattern to highlight languages embedded in HTML attributes.
    			 *
    			 * An example of an inlined language is CSS with `style` attributes.
    			 *
    			 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    			 * case insensitive.
    			 * @param {string} lang The language key.
    			 * @example
    			 * addAttribute('style', 'css');
    			 */
    			value: function (attrName, lang) {
    				Prism.languages.markup.tag.inside['special-attr'].push({
    					pattern: RegExp(
    						/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
    						'i'
    					),
    					lookbehind: true,
    					inside: {
    						'attr-name': /^[^\s=]+/,
    						'attr-value': {
    							pattern: /=[\s\S]+/,
    							inside: {
    								'value': {
    									pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
    									lookbehind: true,
    									alias: [lang, 'language-' + lang],
    									inside: Prism.languages[lang]
    								},
    								'punctuation': [
    									{
    										pattern: /^=/,
    										alias: 'attr-equals'
    									},
    									/"|'/
    								]
    							}
    						}
    					}
    				});
    			}
    		});

    		Prism.languages.html = Prism.languages.markup;
    		Prism.languages.mathml = Prism.languages.markup;
    		Prism.languages.svg = Prism.languages.markup;

    		Prism.languages.xml = Prism.languages.extend('markup', {});
    		Prism.languages.ssml = Prism.languages.xml;
    		Prism.languages.atom = Prism.languages.xml;
    		Prism.languages.rss = Prism.languages.xml;


    		/* **********************************************
    		     Begin prism-css.js
    		********************************************** */

    		(function (Prism) {

    			var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

    			Prism.languages.css = {
    				'comment': /\/\*[\s\S]*?\*\//,
    				'atrule': {
    					pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
    					inside: {
    						'rule': /^@[\w-]+/,
    						'selector-function-argument': {
    							pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
    							lookbehind: true,
    							alias: 'selector'
    						},
    						'keyword': {
    							pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    							lookbehind: true
    						}
    						// See rest below
    					}
    				},
    				'url': {
    					// https://drafts.csswg.org/css-values-3/#urls
    					pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
    					greedy: true,
    					inside: {
    						'function': /^url/i,
    						'punctuation': /^\(|\)$/,
    						'string': {
    							pattern: RegExp('^' + string.source + '$'),
    							alias: 'url'
    						}
    					}
    				},
    				'selector': {
    					pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
    					lookbehind: true
    				},
    				'string': {
    					pattern: string,
    					greedy: true
    				},
    				'property': {
    					pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
    					lookbehind: true
    				},
    				'important': /!important\b/i,
    				'function': {
    					pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
    					lookbehind: true
    				},
    				'punctuation': /[(){};:,]/
    			};

    			Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    			var markup = Prism.languages.markup;
    			if (markup) {
    				markup.tag.addInlined('style', 'css');
    				markup.tag.addAttribute('style', 'css');
    			}

    		}(Prism));


    		/* **********************************************
    		     Begin prism-clike.js
    		********************************************** */

    		Prism.languages.clike = {
    			'comment': [
    				{
    					pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    					lookbehind: true,
    					greedy: true
    				},
    				{
    					pattern: /(^|[^\\:])\/\/.*/,
    					lookbehind: true,
    					greedy: true
    				}
    			],
    			'string': {
    				pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    				greedy: true
    			},
    			'class-name': {
    				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    				lookbehind: true,
    				inside: {
    					'punctuation': /[.\\]/
    				}
    			},
    			'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    			'boolean': /\b(?:false|true)\b/,
    			'function': /\b\w+(?=\()/,
    			'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    			'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    			'punctuation': /[{}[\];(),.:]/
    		};


    		/* **********************************************
    		     Begin prism-javascript.js
    		********************************************** */

    		Prism.languages.javascript = Prism.languages.extend('clike', {
    			'class-name': [
    				Prism.languages.clike['class-name'],
    				{
    					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    					lookbehind: true
    				}
    			],
    			'keyword': [
    				{
    					pattern: /((?:^|\})\s*)catch\b/,
    					lookbehind: true
    				},
    				{
    					pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    					lookbehind: true
    				},
    			],
    			// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    			'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    			'number': {
    				pattern: RegExp(
    					/(^|[^\w$])/.source +
    					'(?:' +
    					(
    						// constant
    						/NaN|Infinity/.source +
    						'|' +
    						// binary integer
    						/0[bB][01]+(?:_[01]+)*n?/.source +
    						'|' +
    						// octal integer
    						/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
    						'|' +
    						// hexadecimal integer
    						/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
    						'|' +
    						// decimal bigint
    						/\d+(?:_\d+)*n/.source +
    						'|' +
    						// decimal number (integer or float) but no bigint
    						/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
    					) +
    					')' +
    					/(?![\w$])/.source
    				),
    				lookbehind: true
    			},
    			'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    		});

    		Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

    		Prism.languages.insertBefore('javascript', 'keyword', {
    			'regex': {
    				pattern: RegExp(
    					// lookbehind
    					// eslint-disable-next-line regexp/no-dupe-characters-character-class
    					/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
    					// Regex pattern:
    					// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
    					// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
    					// with the only syntax, so we have to define 2 different regex patterns.
    					/\//.source +
    					'(?:' +
    					/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
    					'|' +
    					// `v` flag syntax. This supports 3 levels of nested character classes.
    					/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
    					')' +
    					// lookahead
    					/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    				),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'regex-source': {
    						pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
    						lookbehind: true,
    						alias: 'language-regex',
    						inside: Prism.languages.regex
    					},
    					'regex-delimiter': /^\/|\/$/,
    					'regex-flags': /^[a-z]+$/,
    				}
    			},
    			// This must be declared before keyword because we use "function" inside the look-forward
    			'function-variable': {
    				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    				alias: 'function'
    			},
    			'parameter': [
    				{
    					pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    					lookbehind: true,
    					inside: Prism.languages.javascript
    				},
    				{
    					pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    					lookbehind: true,
    					inside: Prism.languages.javascript
    				},
    				{
    					pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    					lookbehind: true,
    					inside: Prism.languages.javascript
    				},
    				{
    					pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    					lookbehind: true,
    					inside: Prism.languages.javascript
    				}
    			],
    			'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    		});

    		Prism.languages.insertBefore('javascript', 'string', {
    			'hashbang': {
    				pattern: /^#!.*/,
    				greedy: true,
    				alias: 'comment'
    			},
    			'template-string': {
    				pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    				greedy: true,
    				inside: {
    					'template-punctuation': {
    						pattern: /^`|`$/,
    						alias: 'string'
    					},
    					'interpolation': {
    						pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
    						lookbehind: true,
    						inside: {
    							'interpolation-punctuation': {
    								pattern: /^\$\{|\}$/,
    								alias: 'punctuation'
    							},
    							rest: Prism.languages.javascript
    						}
    					},
    					'string': /[\s\S]+/
    				}
    			},
    			'string-property': {
    				pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    				lookbehind: true,
    				greedy: true,
    				alias: 'property'
    			}
    		});

    		Prism.languages.insertBefore('javascript', 'operator', {
    			'literal-property': {
    				pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    				lookbehind: true,
    				alias: 'property'
    			},
    		});

    		if (Prism.languages.markup) {
    			Prism.languages.markup.tag.addInlined('script', 'javascript');

    			// add attribute support for all DOM events.
    			// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    			Prism.languages.markup.tag.addAttribute(
    				/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    				'javascript'
    			);
    		}

    		Prism.languages.js = Prism.languages.javascript;


    		/* **********************************************
    		     Begin prism-file-highlight.js
    		********************************************** */

    		(function () {

    			if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    				return;
    			}

    			// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    			if (!Element.prototype.matches) {
    				Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    			}

    			var LOADING_MESSAGE = 'Loading…';
    			var FAILURE_MESSAGE = function (status, message) {
    				return '✖ Error ' + status + ' while fetching file: ' + message;
    			};
    			var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

    			var EXTENSIONS = {
    				'js': 'javascript',
    				'py': 'python',
    				'rb': 'ruby',
    				'ps1': 'powershell',
    				'psm1': 'powershell',
    				'sh': 'bash',
    				'bat': 'batch',
    				'h': 'c',
    				'tex': 'latex'
    			};

    			var STATUS_ATTR = 'data-src-status';
    			var STATUS_LOADING = 'loading';
    			var STATUS_LOADED = 'loaded';
    			var STATUS_FAILED = 'failed';

    			var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
    				+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

    			/**
    			 * Loads the given file.
    			 *
    			 * @param {string} src The URL or path of the source file to load.
    			 * @param {(result: string) => void} success
    			 * @param {(reason: string) => void} error
    			 */
    			function loadFile(src, success, error) {
    				var xhr = new XMLHttpRequest();
    				xhr.open('GET', src, true);
    				xhr.onreadystatechange = function () {
    					if (xhr.readyState == 4) {
    						if (xhr.status < 400 && xhr.responseText) {
    							success(xhr.responseText);
    						} else {
    							if (xhr.status >= 400) {
    								error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
    							} else {
    								error(FAILURE_EMPTY_MESSAGE);
    							}
    						}
    					}
    				};
    				xhr.send(null);
    			}

    			/**
    			 * Parses the given range.
    			 *
    			 * This returns a range with inclusive ends.
    			 *
    			 * @param {string | null | undefined} range
    			 * @returns {[number, number | undefined] | undefined}
    			 */
    			function parseRange(range) {
    				var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
    				if (m) {
    					var start = Number(m[1]);
    					var comma = m[2];
    					var end = m[3];

    					if (!comma) {
    						return [start, start];
    					}
    					if (!end) {
    						return [start, undefined];
    					}
    					return [start, Number(end)];
    				}
    				return undefined;
    			}

    			Prism.hooks.add('before-highlightall', function (env) {
    				env.selector += ', ' + SELECTOR;
    			});

    			Prism.hooks.add('before-sanity-check', function (env) {
    				var pre = /** @type {HTMLPreElement} */ (env.element);
    				if (pre.matches(SELECTOR)) {
    					env.code = ''; // fast-path the whole thing and go to complete

    					pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

    					// add code element with loading message
    					var code = pre.appendChild(document.createElement('CODE'));
    					code.textContent = LOADING_MESSAGE;

    					var src = pre.getAttribute('data-src');

    					var language = env.language;
    					if (language === 'none') {
    						// the language might be 'none' because there is no language set;
    						// in this case, we want to use the extension as the language
    						var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
    						language = EXTENSIONS[extension] || extension;
    					}

    					// set language classes
    					Prism.util.setLanguage(code, language);
    					Prism.util.setLanguage(pre, language);

    					// preload the language
    					var autoloader = Prism.plugins.autoloader;
    					if (autoloader) {
    						autoloader.loadLanguages(language);
    					}

    					// load file
    					loadFile(
    						src,
    						function (text) {
    							// mark as loaded
    							pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

    							// handle data-range
    							var range = parseRange(pre.getAttribute('data-range'));
    							if (range) {
    								var lines = text.split(/\r\n?|\n/g);

    								// the range is one-based and inclusive on both ends
    								var start = range[0];
    								var end = range[1] == null ? lines.length : range[1];

    								if (start < 0) { start += lines.length; }
    								start = Math.max(0, Math.min(start - 1, lines.length));
    								if (end < 0) { end += lines.length; }
    								end = Math.max(0, Math.min(end, lines.length));

    								text = lines.slice(start, end).join('\n');

    								// add data-start for line numbers
    								if (!pre.hasAttribute('data-start')) {
    									pre.setAttribute('data-start', String(start + 1));
    								}
    							}

    							// highlight code
    							code.textContent = text;
    							Prism.highlightElement(code);
    						},
    						function (error) {
    							// mark as failed
    							pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

    							code.textContent = error;
    						}
    					);
    				}
    			});

    			Prism.plugins.fileHighlight = {
    				/**
    				 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
    				 *
    				 * Note: Elements which are already loaded or currently loading will not be touched by this method.
    				 *
    				 * @param {ParentNode} [container=document]
    				 */
    				highlight: function highlight(container) {
    					var elements = (container || document).querySelectorAll(SELECTOR);

    					for (var i = 0, element; (element = elements[i++]);) {
    						Prism.highlightElement(element);
    					}
    				}
    			};

    			var logged = false;
    			/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
    			Prism.fileHighlight = function () {
    				if (!logged) {
    					console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
    					logged = true;
    				}
    				Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    			};

    		}());
    } (prism));
    	return prismExports;
    }

    var prismClike = {};

    var hasRequiredPrismClike;

    function requirePrismClike () {
    	if (hasRequiredPrismClike) return prismClike;
    	hasRequiredPrismClike = 1;
    	Prism.languages.clike = {
    		'comment': [
    			{
    				pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    				lookbehind: true,
    				greedy: true
    			},
    			{
    				pattern: /(^|[^\\:])\/\/.*/,
    				lookbehind: true,
    				greedy: true
    			}
    		],
    		'string': {
    			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    			greedy: true
    		},
    		'class-name': {
    			pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    			lookbehind: true,
    			inside: {
    				'punctuation': /[.\\]/
    			}
    		},
    		'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    		'boolean': /\b(?:false|true)\b/,
    		'function': /\b\w+(?=\()/,
    		'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    		'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    		'punctuation': /[{}[\];(),.:]/
    	};
    	return prismClike;
    }

    var prismJavascript = {};

    var hasRequiredPrismJavascript;

    function requirePrismJavascript () {
    	if (hasRequiredPrismJavascript) return prismJavascript;
    	hasRequiredPrismJavascript = 1;
    	Prism.languages.javascript = Prism.languages.extend('clike', {
    		'class-name': [
    			Prism.languages.clike['class-name'],
    			{
    				pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    				lookbehind: true
    			}
    		],
    		'keyword': [
    			{
    				pattern: /((?:^|\})\s*)catch\b/,
    				lookbehind: true
    			},
    			{
    				pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    				lookbehind: true
    			},
    		],
    		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    		'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    		'number': {
    			pattern: RegExp(
    				/(^|[^\w$])/.source +
    				'(?:' +
    				(
    					// constant
    					/NaN|Infinity/.source +
    					'|' +
    					// binary integer
    					/0[bB][01]+(?:_[01]+)*n?/.source +
    					'|' +
    					// octal integer
    					/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
    					'|' +
    					// hexadecimal integer
    					/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
    					'|' +
    					// decimal bigint
    					/\d+(?:_\d+)*n/.source +
    					'|' +
    					// decimal number (integer or float) but no bigint
    					/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
    				) +
    				')' +
    				/(?![\w$])/.source
    			),
    			lookbehind: true
    		},
    		'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    	});

    	Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

    	Prism.languages.insertBefore('javascript', 'keyword', {
    		'regex': {
    			pattern: RegExp(
    				// lookbehind
    				// eslint-disable-next-line regexp/no-dupe-characters-character-class
    				/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
    				// Regex pattern:
    				// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
    				// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
    				// with the only syntax, so we have to define 2 different regex patterns.
    				/\//.source +
    				'(?:' +
    				/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
    				'|' +
    				// `v` flag syntax. This supports 3 levels of nested character classes.
    				/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
    				')' +
    				// lookahead
    				/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    			),
    			lookbehind: true,
    			greedy: true,
    			inside: {
    				'regex-source': {
    					pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
    					lookbehind: true,
    					alias: 'language-regex',
    					inside: Prism.languages.regex
    				},
    				'regex-delimiter': /^\/|\/$/,
    				'regex-flags': /^[a-z]+$/,
    			}
    		},
    		// This must be declared before keyword because we use "function" inside the look-forward
    		'function-variable': {
    			pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    			alias: 'function'
    		},
    		'parameter': [
    			{
    				pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			}
    		],
    		'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    	});

    	Prism.languages.insertBefore('javascript', 'string', {
    		'hashbang': {
    			pattern: /^#!.*/,
    			greedy: true,
    			alias: 'comment'
    		},
    		'template-string': {
    			pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    			greedy: true,
    			inside: {
    				'template-punctuation': {
    					pattern: /^`|`$/,
    					alias: 'string'
    				},
    				'interpolation': {
    					pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
    					lookbehind: true,
    					inside: {
    						'interpolation-punctuation': {
    							pattern: /^\$\{|\}$/,
    							alias: 'punctuation'
    						},
    						rest: Prism.languages.javascript
    					}
    				},
    				'string': /[\s\S]+/
    			}
    		},
    		'string-property': {
    			pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    			lookbehind: true,
    			greedy: true,
    			alias: 'property'
    		}
    	});

    	Prism.languages.insertBefore('javascript', 'operator', {
    		'literal-property': {
    			pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    			lookbehind: true,
    			alias: 'property'
    		},
    	});

    	if (Prism.languages.markup) {
    		Prism.languages.markup.tag.addInlined('script', 'javascript');

    		// add attribute support for all DOM events.
    		// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    		Prism.languages.markup.tag.addAttribute(
    			/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    			'javascript'
    		);
    	}

    	Prism.languages.js = Prism.languages.javascript;
    	return prismJavascript;
    }

    var prismMarkup = {};

    var hasRequiredPrismMarkup;

    function requirePrismMarkup () {
    	if (hasRequiredPrismMarkup) return prismMarkup;
    	hasRequiredPrismMarkup = 1;
    	Prism.languages.markup = {
    		'comment': {
    			pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    			greedy: true
    		},
    		'prolog': {
    			pattern: /<\?[\s\S]+?\?>/,
    			greedy: true
    		},
    		'doctype': {
    			// https://www.w3.org/TR/xml/#NT-doctypedecl
    			pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    			greedy: true,
    			inside: {
    				'internal-subset': {
    					pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
    					lookbehind: true,
    					greedy: true,
    					inside: null // see below
    				},
    				'string': {
    					pattern: /"[^"]*"|'[^']*'/,
    					greedy: true
    				},
    				'punctuation': /^<!|>$|[[\]]/,
    				'doctype-tag': /^DOCTYPE/i,
    				'name': /[^\s<>'"]+/
    			}
    		},
    		'cdata': {
    			pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    			greedy: true
    		},
    		'tag': {
    			pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    			greedy: true,
    			inside: {
    				'tag': {
    					pattern: /^<\/?[^\s>\/]+/,
    					inside: {
    						'punctuation': /^<\/?/,
    						'namespace': /^[^\s>\/:]+:/
    					}
    				},
    				'special-attr': [],
    				'attr-value': {
    					pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
    					inside: {
    						'punctuation': [
    							{
    								pattern: /^=/,
    								alias: 'attr-equals'
    							},
    							{
    								pattern: /^(\s*)["']|["']$/,
    								lookbehind: true
    							}
    						]
    					}
    				},
    				'punctuation': /\/?>/,
    				'attr-name': {
    					pattern: /[^\s>\/]+/,
    					inside: {
    						'namespace': /^[^\s>\/:]+:/
    					}
    				}

    			}
    		},
    		'entity': [
    			{
    				pattern: /&[\da-z]{1,8};/i,
    				alias: 'named-entity'
    			},
    			/&#x?[\da-f]{1,8};/i
    		]
    	};

    	Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    		Prism.languages.markup['entity'];
    	Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    	// Plugin to make entity title show the real entity, idea by Roman Komarov
    	Prism.hooks.add('wrap', function (env) {

    		if (env.type === 'entity') {
    			env.attributes['title'] = env.content.replace(/&amp;/, '&');
    		}
    	});

    	Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    		/**
    		 * Adds an inlined language to markup.
    		 *
    		 * An example of an inlined language is CSS with `<style>` tags.
    		 *
    		 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    		 * case insensitive.
    		 * @param {string} lang The language key.
    		 * @example
    		 * addInlined('style', 'css');
    		 */
    		value: function addInlined(tagName, lang) {
    			var includedCdataInside = {};
    			includedCdataInside['language-' + lang] = {
    				pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    				lookbehind: true,
    				inside: Prism.languages[lang]
    			};
    			includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    			var inside = {
    				'included-cdata': {
    					pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    					inside: includedCdataInside
    				}
    			};
    			inside['language-' + lang] = {
    				pattern: /[\s\S]+/,
    				inside: Prism.languages[lang]
    			};

    			var def = {};
    			def[tagName] = {
    				pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
    				lookbehind: true,
    				greedy: true,
    				inside: inside
    			};

    			Prism.languages.insertBefore('markup', 'cdata', def);
    		}
    	});
    	Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    		/**
    		 * Adds an pattern to highlight languages embedded in HTML attributes.
    		 *
    		 * An example of an inlined language is CSS with `style` attributes.
    		 *
    		 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    		 * case insensitive.
    		 * @param {string} lang The language key.
    		 * @example
    		 * addAttribute('style', 'css');
    		 */
    		value: function (attrName, lang) {
    			Prism.languages.markup.tag.inside['special-attr'].push({
    				pattern: RegExp(
    					/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
    					'i'
    				),
    				lookbehind: true,
    				inside: {
    					'attr-name': /^[^\s=]+/,
    					'attr-value': {
    						pattern: /=[\s\S]+/,
    						inside: {
    							'value': {
    								pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
    								lookbehind: true,
    								alias: [lang, 'language-' + lang],
    								inside: Prism.languages[lang]
    							},
    							'punctuation': [
    								{
    									pattern: /^=/,
    									alias: 'attr-equals'
    								},
    								/"|'/
    							]
    						}
    					}
    				}
    			});
    		}
    	});

    	Prism.languages.html = Prism.languages.markup;
    	Prism.languages.mathml = Prism.languages.markup;
    	Prism.languages.svg = Prism.languages.markup;

    	Prism.languages.xml = Prism.languages.extend('markup', {});
    	Prism.languages.ssml = Prism.languages.xml;
    	Prism.languages.atom = Prism.languages.xml;
    	Prism.languages.rss = Prism.languages.xml;
    	return prismMarkup;
    }

    var prismMarkdown = {};

    var hasRequiredPrismMarkdown;

    function requirePrismMarkdown () {
    	if (hasRequiredPrismMarkdown) return prismMarkdown;
    	hasRequiredPrismMarkdown = 1;
    	(function (Prism) {

    		// Allow only one line break
    		var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;

    		/**
    		 * This function is intended for the creation of the bold or italic pattern.
    		 *
    		 * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
    		 *
    		 * _Note:_ Keep in mind that this adds a capturing group.
    		 *
    		 * @param {string} pattern
    		 * @returns {RegExp}
    		 */
    		function createInline(pattern) {
    			pattern = pattern.replace(/<inner>/g, function () { return inner; });
    			return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
    		}


    		var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
    		var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function () { return tableCell; });
    		var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;


    		Prism.languages.markdown = Prism.languages.extend('markup', {});
    		Prism.languages.insertBefore('markdown', 'prolog', {
    			'front-matter-block': {
    				pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'punctuation': /^---|---$/,
    					'front-matter': {
    						pattern: /\S+(?:\s+\S+)*/,
    						alias: ['yaml', 'language-yaml'],
    						inside: Prism.languages.yaml
    					}
    				}
    			},
    			'blockquote': {
    				// > ...
    				pattern: /^>(?:[\t ]*>)*/m,
    				alias: 'punctuation'
    			},
    			'table': {
    				pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
    				inside: {
    					'table-data-rows': {
    						pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
    						lookbehind: true,
    						inside: {
    							'table-data': {
    								pattern: RegExp(tableCell),
    								inside: Prism.languages.markdown
    							},
    							'punctuation': /\|/
    						}
    					},
    					'table-line': {
    						pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
    						lookbehind: true,
    						inside: {
    							'punctuation': /\||:?-{3,}:?/
    						}
    					},
    					'table-header-row': {
    						pattern: RegExp('^' + tableRow + '$'),
    						inside: {
    							'table-header': {
    								pattern: RegExp(tableCell),
    								alias: 'important',
    								inside: Prism.languages.markdown
    							},
    							'punctuation': /\|/
    						}
    					}
    				}
    			},
    			'code': [
    				{
    					// Prefixed by 4 spaces or 1 tab and preceded by an empty line
    					pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
    					lookbehind: true,
    					alias: 'keyword'
    				},
    				{
    					// ```optional language
    					// code block
    					// ```
    					pattern: /^```[\s\S]*?^```$/m,
    					greedy: true,
    					inside: {
    						'code-block': {
    							pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
    							lookbehind: true
    						},
    						'code-language': {
    							pattern: /^(```).+/,
    							lookbehind: true
    						},
    						'punctuation': /```/
    					}
    				}
    			],
    			'title': [
    				{
    					// title 1
    					// =======

    					// title 2
    					// -------
    					pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
    					alias: 'important',
    					inside: {
    						punctuation: /==+$|--+$/
    					}
    				},
    				{
    					// # title 1
    					// ###### title 6
    					pattern: /(^\s*)#.+/m,
    					lookbehind: true,
    					alias: 'important',
    					inside: {
    						punctuation: /^#+|#+$/
    					}
    				}
    			],
    			'hr': {
    				// ***
    				// ---
    				// * * *
    				// -----------
    				pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
    				lookbehind: true,
    				alias: 'punctuation'
    			},
    			'list': {
    				// * item
    				// + item
    				// - item
    				// 1. item
    				pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
    				lookbehind: true,
    				alias: 'punctuation'
    			},
    			'url-reference': {
    				// [id]: http://example.com "Optional title"
    				// [id]: http://example.com 'Optional title'
    				// [id]: http://example.com (Optional title)
    				// [id]: <http://example.com> "Optional title"
    				pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
    				inside: {
    					'variable': {
    						pattern: /^(!?\[)[^\]]+/,
    						lookbehind: true
    					},
    					'string': /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
    					'punctuation': /^[\[\]!:]|[<>]/
    				},
    				alias: 'url'
    			},
    			'bold': {
    				// **strong**
    				// __strong__

    				// allow one nested instance of italic text using the same delimiter
    				pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'content': {
    						pattern: /(^..)[\s\S]+(?=..$)/,
    						lookbehind: true,
    						inside: {} // see below
    					},
    					'punctuation': /\*\*|__/
    				}
    			},
    			'italic': {
    				// *em*
    				// _em_

    				// allow one nested instance of bold text using the same delimiter
    				pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'content': {
    						pattern: /(^.)[\s\S]+(?=.$)/,
    						lookbehind: true,
    						inside: {} // see below
    					},
    					'punctuation': /[*_]/
    				}
    			},
    			'strike': {
    				// ~~strike through~~
    				// ~strike~
    				// eslint-disable-next-line regexp/strict
    				pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'content': {
    						pattern: /(^~~?)[\s\S]+(?=\1$)/,
    						lookbehind: true,
    						inside: {} // see below
    					},
    					'punctuation': /~~?/
    				}
    			},
    			'code-snippet': {
    				// `code`
    				// ``code``
    				pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
    				lookbehind: true,
    				greedy: true,
    				alias: ['code', 'keyword']
    			},
    			'url': {
    				// [example](http://example.com "Optional title")
    				// [example][id]
    				// [example] [id]
    				pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'operator': /^!/,
    					'content': {
    						pattern: /(^\[)[^\]]+(?=\])/,
    						lookbehind: true,
    						inside: {} // see below
    					},
    					'variable': {
    						pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
    						lookbehind: true
    					},
    					'url': {
    						pattern: /(^\]\()[^\s)]+/,
    						lookbehind: true
    					},
    					'string': {
    						pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
    						lookbehind: true
    					}
    				}
    			}
    		});

    		['url', 'bold', 'italic', 'strike'].forEach(function (token) {
    			['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
    				if (token !== inside) {
    					Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
    				}
    			});
    		});

    		Prism.hooks.add('after-tokenize', function (env) {
    			if (env.language !== 'markdown' && env.language !== 'md') {
    				return;
    			}

    			function walkTokens(tokens) {
    				if (!tokens || typeof tokens === 'string') {
    					return;
    				}

    				for (var i = 0, l = tokens.length; i < l; i++) {
    					var token = tokens[i];

    					if (token.type !== 'code') {
    						walkTokens(token.content);
    						continue;
    					}

    					/*
    					 * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
    					 * is optional. But the grammar is defined so that there is only one case we have to handle:
    					 *
    					 * token.content = [
    					 *     <span class="punctuation">```</span>,
    					 *     <span class="code-language">xxxx</span>,
    					 *     '\n', // exactly one new lines (\r or \n or \r\n)
    					 *     <span class="code-block">...</span>,
    					 *     '\n', // exactly one new lines again
    					 *     <span class="punctuation">```</span>
    					 * ];
    					 */

    					var codeLang = token.content[1];
    					var codeBlock = token.content[3];

    					if (codeLang && codeBlock &&
    						codeLang.type === 'code-language' && codeBlock.type === 'code-block' &&
    						typeof codeLang.content === 'string') {

    						// this might be a language that Prism does not support

    						// do some replacements to support C++, C#, and F#
    						var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
    						// only use the first word
    						lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
    						var alias = 'language-' + lang;

    						// add alias
    						if (!codeBlock.alias) {
    							codeBlock.alias = [alias];
    						} else if (typeof codeBlock.alias === 'string') {
    							codeBlock.alias = [codeBlock.alias, alias];
    						} else {
    							codeBlock.alias.push(alias);
    						}
    					}
    				}
    			}

    			walkTokens(env.tokens);
    		});

    		Prism.hooks.add('wrap', function (env) {
    			if (env.type !== 'code-block') {
    				return;
    			}

    			var codeLang = '';
    			for (var i = 0, l = env.classes.length; i < l; i++) {
    				var cls = env.classes[i];
    				var match = /language-(.+)/.exec(cls);
    				if (match) {
    					codeLang = match[1];
    					break;
    				}
    			}

    			var grammar = Prism.languages[codeLang];

    			if (!grammar) {
    				if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {
    					var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
    					env.attributes['id'] = id;

    					Prism.plugins.autoloader.loadLanguages(codeLang, function () {
    						var ele = document.getElementById(id);
    						if (ele) {
    							ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
    						}
    					});
    				}
    			} else {
    				env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
    			}
    		});

    		var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');

    		/**
    		 * A list of known entity names.
    		 *
    		 * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
    		 *
    		 * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
    		 */
    		var KNOWN_ENTITY_NAMES = {
    			'amp': '&',
    			'lt': '<',
    			'gt': '>',
    			'quot': '"',
    		};

    		// IE 11 doesn't support `String.fromCodePoint`
    		var fromCodePoint = String.fromCodePoint || String.fromCharCode;

    		/**
    		 * Returns the text content of a given HTML source code string.
    		 *
    		 * @param {string} html
    		 * @returns {string}
    		 */
    		function textContent(html) {
    			// remove all tags
    			var text = html.replace(tagPattern, '');

    			// decode known entities
    			text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m, code) {
    				code = code.toLowerCase();

    				if (code[0] === '#') {
    					var value;
    					if (code[1] === 'x') {
    						value = parseInt(code.slice(2), 16);
    					} else {
    						value = Number(code.slice(1));
    					}

    					return fromCodePoint(value);
    				} else {
    					var known = KNOWN_ENTITY_NAMES[code];
    					if (known) {
    						return known;
    					}

    					// unable to decode
    					return m;
    				}
    			});

    			return text;
    		}

    		Prism.languages.md = Prism.languages.markdown;

    	}(Prism));
    	return prismMarkdown;
    }

    var prismC = {};

    var hasRequiredPrismC;

    function requirePrismC () {
    	if (hasRequiredPrismC) return prismC;
    	hasRequiredPrismC = 1;
    	Prism.languages.c = Prism.languages.extend('clike', {
    		'comment': {
    			pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    			greedy: true
    		},
    		'string': {
    			// https://en.cppreference.com/w/c/language/string_literal
    			pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    			greedy: true
    		},
    		'class-name': {
    			pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    			lookbehind: true
    		},
    		'keyword': /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    		'function': /\b[a-z_]\w*(?=\s*\()/i,
    		'number': /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    		'operator': />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    	});

    	Prism.languages.insertBefore('c', 'string', {
    		'char': {
    			// https://en.cppreference.com/w/c/language/character_constant
    			pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    			greedy: true
    		}
    	});

    	Prism.languages.insertBefore('c', 'string', {
    		'macro': {
    			// allow for multiline macro definitions
    			// spaces after the # character compile fine with gcc
    			pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    			lookbehind: true,
    			greedy: true,
    			alias: 'property',
    			inside: {
    				'string': [
    					{
    						// highlight the path of the include statement as a string
    						pattern: /^(#\s*include\s*)<[^>]+>/,
    						lookbehind: true
    					},
    					Prism.languages.c['string']
    				],
    				'char': Prism.languages.c['char'],
    				'comment': Prism.languages.c['comment'],
    				'macro-name': [
    					{
    						pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
    						lookbehind: true
    					},
    					{
    						pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
    						lookbehind: true,
    						alias: 'function'
    					}
    				],
    				// highlight macro directives as keywords
    				'directive': {
    					pattern: /^(#\s*)[a-z]+/,
    					lookbehind: true,
    					alias: 'keyword'
    				},
    				'directive-hash': /^#/,
    				'punctuation': /##|\\(?=[\r\n])/,
    				'expression': {
    					pattern: /\S[\s\S]*/,
    					inside: Prism.languages.c
    				}
    			}
    		}
    	});

    	Prism.languages.insertBefore('c', 'function', {
    		// highlight predefined macros as constants
    		'constant': /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    	});

    	delete Prism.languages.c['boolean'];
    	return prismC;
    }

    var prismCss = {};

    var hasRequiredPrismCss;

    function requirePrismCss () {
    	if (hasRequiredPrismCss) return prismCss;
    	hasRequiredPrismCss = 1;
    	(function (Prism) {

    		var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

    		Prism.languages.css = {
    			'comment': /\/\*[\s\S]*?\*\//,
    			'atrule': {
    				pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
    				inside: {
    					'rule': /^@[\w-]+/,
    					'selector-function-argument': {
    						pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
    						lookbehind: true,
    						alias: 'selector'
    					},
    					'keyword': {
    						pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    						lookbehind: true
    					}
    					// See rest below
    				}
    			},
    			'url': {
    				// https://drafts.csswg.org/css-values-3/#urls
    				pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
    				greedy: true,
    				inside: {
    					'function': /^url/i,
    					'punctuation': /^\(|\)$/,
    					'string': {
    						pattern: RegExp('^' + string.source + '$'),
    						alias: 'url'
    					}
    				}
    			},
    			'selector': {
    				pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
    				lookbehind: true
    			},
    			'string': {
    				pattern: string,
    				greedy: true
    			},
    			'property': {
    				pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
    				lookbehind: true
    			},
    			'important': /!important\b/i,
    			'function': {
    				pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
    				lookbehind: true
    			},
    			'punctuation': /[(){};:,]/
    		};

    		Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    		var markup = Prism.languages.markup;
    		if (markup) {
    			markup.tag.addInlined('style', 'css');
    			markup.tag.addAttribute('style', 'css');
    		}

    	}(Prism));
    	return prismCss;
    }

    var prismObjectivec = {};

    var hasRequiredPrismObjectivec;

    function requirePrismObjectivec () {
    	if (hasRequiredPrismObjectivec) return prismObjectivec;
    	hasRequiredPrismObjectivec = 1;
    	Prism.languages.objectivec = Prism.languages.extend('c', {
    		'string': {
    			pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    			greedy: true
    		},
    		'keyword': /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    		'operator': /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    	});

    	delete Prism.languages.objectivec['class-name'];

    	Prism.languages.objc = Prism.languages.objectivec;
    	return prismObjectivec;
    }

    var prismSql = {};

    var hasRequiredPrismSql;

    function requirePrismSql () {
    	if (hasRequiredPrismSql) return prismSql;
    	hasRequiredPrismSql = 1;
    	Prism.languages.sql = {
    		'comment': {
    			pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    			lookbehind: true
    		},
    		'variable': [
    			{
    				pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
    				greedy: true
    			},
    			/@[\w.$]+/
    		],
    		'string': {
    			pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    			greedy: true,
    			lookbehind: true
    		},
    		'identifier': {
    			pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    			greedy: true,
    			lookbehind: true,
    			inside: {
    				'punctuation': /^`|`$/
    			}
    		},
    		'function': /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, // Should we highlight user defined functions too?
    		'keyword': /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    		'boolean': /\b(?:FALSE|NULL|TRUE)\b/i,
    		'number': /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    		'operator': /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    		'punctuation': /[;[\]()`,.]/
    	};
    	return prismSql;
    }

    var prismPython = {};

    var hasRequiredPrismPython;

    function requirePrismPython () {
    	if (hasRequiredPrismPython) return prismPython;
    	hasRequiredPrismPython = 1;
    	Prism.languages.python = {
    		'comment': {
    			pattern: /(^|[^\\])#.*/,
    			lookbehind: true,
    			greedy: true
    		},
    		'string-interpolation': {
    			pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    			greedy: true,
    			inside: {
    				'interpolation': {
    					// "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
    					pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
    					lookbehind: true,
    					inside: {
    						'format-spec': {
    							pattern: /(:)[^:(){}]+(?=\}$)/,
    							lookbehind: true
    						},
    						'conversion-option': {
    							pattern: /![sra](?=[:}]$)/,
    							alias: 'punctuation'
    						},
    						rest: null
    					}
    				},
    				'string': /[\s\S]+/
    			}
    		},
    		'triple-quoted-string': {
    			pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    			greedy: true,
    			alias: 'string'
    		},
    		'string': {
    			pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    			greedy: true
    		},
    		'function': {
    			pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    			lookbehind: true
    		},
    		'class-name': {
    			pattern: /(\bclass\s+)\w+/i,
    			lookbehind: true
    		},
    		'decorator': {
    			pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    			lookbehind: true,
    			alias: ['annotation', 'punctuation'],
    			inside: {
    				'punctuation': /\./
    			}
    		},
    		'keyword': /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    		'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    		'boolean': /\b(?:False|None|True)\b/,
    		'number': /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    		'operator': /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    		'punctuation': /[{}[\];(),.:]/
    	};

    	Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;

    	Prism.languages.py = Prism.languages.python;
    	return prismPython;
    }

    var prismRust = {};

    var hasRequiredPrismRust;

    function requirePrismRust () {
    	if (hasRequiredPrismRust) return prismRust;
    	hasRequiredPrismRust = 1;
    	(function (Prism) {

    		var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
    		for (var i = 0; i < 2; i++) {
    			// support 4 levels of nested comments
    			multilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });
    		}
    		multilineComment = multilineComment.replace(/<self>/g, function () { return /[^\s\S]/.source; });


    		Prism.languages.rust = {
    			'comment': [
    				{
    					pattern: RegExp(/(^|[^\\])/.source + multilineComment),
    					lookbehind: true,
    					greedy: true
    				},
    				{
    					pattern: /(^|[^\\:])\/\/.*/,
    					lookbehind: true,
    					greedy: true
    				}
    			],
    			'string': {
    				pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
    				greedy: true
    			},
    			'char': {
    				pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
    				greedy: true
    			},
    			'attribute': {
    				pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
    				greedy: true,
    				alias: 'attr-name',
    				inside: {
    					'string': null // see below
    				}
    			},

    			// Closure params should not be confused with bitwise OR |
    			'closure-params': {
    				pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'closure-punctuation': {
    						pattern: /^\||\|$/,
    						alias: 'punctuation'
    					},
    					rest: null // see below
    				}
    			},

    			'lifetime-annotation': {
    				pattern: /'\w+/,
    				alias: 'symbol'
    			},

    			'fragment-specifier': {
    				pattern: /(\$\w+:)[a-z]+/,
    				lookbehind: true,
    				alias: 'punctuation'
    			},
    			'variable': /\$\w+/,

    			'function-definition': {
    				pattern: /(\bfn\s+)\w+/,
    				lookbehind: true,
    				alias: 'function'
    			},
    			'type-definition': {
    				pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
    				lookbehind: true,
    				alias: 'class-name'
    			},
    			'module-declaration': [
    				{
    					pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
    					lookbehind: true,
    					alias: 'namespace'
    				},
    				{
    					pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
    					lookbehind: true,
    					alias: 'namespace',
    					inside: {
    						'punctuation': /::/
    					}
    				}
    			],
    			'keyword': [
    				// https://github.com/rust-lang/reference/blob/master/src/keywords.md
    				/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
    				// primitives and str
    				// https://doc.rust-lang.org/stable/rust-by-example/primitives.html
    				/\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
    			],

    			// functions can technically start with an upper-case letter, but this will introduce a lot of false positives
    			// and Rust's naming conventions recommend snake_case anyway.
    			// https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
    			'function': /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
    			'macro': {
    				pattern: /\b\w+!/,
    				alias: 'property'
    			},
    			'constant': /\b[A-Z_][A-Z_\d]+\b/,
    			'class-name': /\b[A-Z]\w*\b/,

    			'namespace': {
    				pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
    				inside: {
    					'punctuation': /::/
    				}
    			},

    			// Hex, oct, bin, dec numbers with visual separators and type suffix
    			'number': /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
    			'boolean': /\b(?:false|true)\b/,
    			'punctuation': /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
    			'operator': /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    		};

    		Prism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;
    		Prism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];

    	}(Prism));
    	return prismRust;
    }

    var prismSwift = {};

    var hasRequiredPrismSwift;

    function requirePrismSwift () {
    	if (hasRequiredPrismSwift) return prismSwift;
    	hasRequiredPrismSwift = 1;
    	Prism.languages.swift = {
    		'comment': {
    			// Nested comments are supported up to 2 levels
    			pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    			lookbehind: true,
    			greedy: true
    		},
    		'string-literal': [
    			// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    			{
    				pattern: RegExp(
    					/(^|[^"#])/.source
    					+ '(?:'
    					// single-line string
    					+ /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source
    					+ '|'
    					// multi-line string
    					+ /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source
    					+ ')'
    					+ /(?!["#])/.source
    				),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'interpolation': {
    						pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
    						lookbehind: true,
    						inside: null // see below
    					},
    					'interpolation-punctuation': {
    						pattern: /^\)|\\\($/,
    						alias: 'punctuation'
    					},
    					'punctuation': /\\(?=[\r\n])/,
    					'string': /[\s\S]+/
    				}
    			},
    			{
    				pattern: RegExp(
    					/(^|[^"#])(#+)/.source
    					+ '(?:'
    					// single-line string
    					+ /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source
    					+ '|'
    					// multi-line string
    					+ /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source
    					+ ')'
    					+ '\\2'
    				),
    				lookbehind: true,
    				greedy: true,
    				inside: {
    					'interpolation': {
    						pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
    						lookbehind: true,
    						inside: null // see below
    					},
    					'interpolation-punctuation': {
    						pattern: /^\)|\\#+\($/,
    						alias: 'punctuation'
    					},
    					'string': /[\s\S]+/
    				}
    			},
    		],

    		'directive': {
    			// directives with conditions
    			pattern: RegExp(
    				/#/.source
    				+ '(?:'
    				+ (
    					/(?:elseif|if)\b/.source
    					+ '(?:[ \t]*'
    					// This regex is a little complex. It's equivalent to this:
    					//   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
    					// where <round> is a general parentheses expression.
    					+ /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source
    					+ ')+'
    				)
    				+ '|'
    				+ /(?:else|endif)\b/.source
    				+ ')'
    			),
    			alias: 'property',
    			inside: {
    				'directive-name': /^#\w+/,
    				'boolean': /\b(?:false|true)\b/,
    				'number': /\b\d+(?:\.\d+)*\b/,
    				'operator': /!|&&|\|\||[<>]=?/,
    				'punctuation': /[(),]/
    			}
    		},
    		'literal': {
    			pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    			alias: 'constant'
    		},
    		'other-directive': {
    			pattern: /#\w+\b/,
    			alias: 'property'
    		},

    		'attribute': {
    			pattern: /@\w+/,
    			alias: 'atrule'
    		},

    		'function-definition': {
    			pattern: /(\bfunc\s+)\w+/,
    			lookbehind: true,
    			alias: 'function'
    		},
    		'label': {
    			// https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    			pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    			lookbehind: true,
    			alias: 'important'
    		},

    		'keyword': /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    		'boolean': /\b(?:false|true)\b/,
    		'nil': {
    			pattern: /\bnil\b/,
    			alias: 'constant'
    		},

    		'short-argument': /\$\d+\b/,
    		'omit': {
    			pattern: /\b_\b/,
    			alias: 'keyword'
    		},
    		'number': /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,

    		// A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    		'class-name': /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    		'function': /\b[a-z_]\w*(?=\s*\()/i,
    		'constant': /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,

    		// Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    		// https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    		// This regex only supports ASCII operators.
    		'operator': /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    		'punctuation': /[{}[\]();,.:\\]/
    	};

    	Prism.languages.swift['string-literal'].forEach(function (rule) {
    		rule.inside['interpolation'].inside = Prism.languages.swift;
    	});
    	return prismSwift;
    }

    var prismTypescript = {};

    var hasRequiredPrismTypescript;

    function requirePrismTypescript () {
    	if (hasRequiredPrismTypescript) return prismTypescript;
    	hasRequiredPrismTypescript = 1;
    	(function (Prism) {

    		Prism.languages.typescript = Prism.languages.extend('javascript', {
    			'class-name': {
    				pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
    				lookbehind: true,
    				greedy: true,
    				inside: null // see below
    			},
    			'builtin': /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
    		});

    		// The keywords TypeScript adds to JavaScript
    		Prism.languages.typescript.keyword.push(
    			/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    			// keywords that have to be followed by an identifier
    			/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    			// This is for `import type *, {}`
    			/\btype\b(?=\s*(?:[\{*]|$))/
    		);

    		// doesn't work with TS because TS is too complex
    		delete Prism.languages.typescript['parameter'];
    		delete Prism.languages.typescript['literal-property'];

    		// a version of typescript specifically for highlighting types
    		var typeInside = Prism.languages.extend('typescript', {});
    		delete typeInside['class-name'];

    		Prism.languages.typescript['class-name'].inside = typeInside;

    		Prism.languages.insertBefore('typescript', 'function', {
    			'decorator': {
    				pattern: /@[$\w\xA0-\uFFFF]+/,
    				inside: {
    					'at': {
    						pattern: /^@/,
    						alias: 'operator'
    					},
    					'function': /^[\s\S]+/
    				}
    			},
    			'generic-function': {
    				// e.g. foo<T extends "bar" | "baz">( ...
    				pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
    				greedy: true,
    				inside: {
    					'function': /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
    					'generic': {
    						pattern: /<[\s\S]+/, // everything after the first <
    						alias: 'class-name',
    						inside: typeInside
    					}
    				}
    			}
    		});

    		Prism.languages.ts = Prism.languages.typescript;

    	}(Prism));
    	return prismTypescript;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalCode_dev;

    function requireLexicalCode_dev () {
    	if (hasRequiredLexicalCode_dev) return LexicalCode_dev;
    	hasRequiredLexicalCode_dev = 1;

    	var Prism = requirePrism();
    	requirePrismClike();
    	requirePrismJavascript();
    	requirePrismMarkup();
    	requirePrismMarkdown();
    	requirePrismC();
    	requirePrismCss();
    	requirePrismObjectivec();
    	requirePrismSql();
    	requirePrismPython();
    	requirePrismRust();
    	requirePrismSwift();
    	requirePrismTypescript();
    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const DEFAULT_CODE_LANGUAGE = 'javascript';
    	const CODE_LANGUAGE_FRIENDLY_NAME_MAP = {
    	  c: 'C',
    	  clike: 'C-like',
    	  css: 'CSS',
    	  html: 'HTML',
    	  js: 'JavaScript',
    	  markdown: 'Markdown',
    	  objc: 'Objective-C',
    	  plain: 'Plain Text',
    	  py: 'Python',
    	  rust: 'Rust',
    	  sql: 'SQL',
    	  swift: 'Swift',
    	  typescript: 'TypeScript',
    	  xml: 'XML'
    	};
    	const CODE_LANGUAGE_MAP = {
    	  javascript: 'js',
    	  md: 'markdown',
    	  plaintext: 'plain',
    	  python: 'py',
    	  text: 'plain',
    	  ts: 'typescript'
    	};
    	function normalizeCodeLang(lang) {
    	  return CODE_LANGUAGE_MAP[lang] || lang;
    	}
    	function getLanguageFriendlyName(lang) {
    	  const _lang = normalizeCodeLang(lang);

    	  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;
    	}
    	const getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;
    	const getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object
    	// so filtering them out here to get langs list
    	language => typeof Prism.languages[language] !== 'function').sort();
    	/** @noInheritDoc */

    	class CodeHighlightNode extends lexical.TextNode {
    	  /** @internal */
    	  constructor(text, highlightType, key) {
    	    super(text, key);
    	    this.__highlightType = highlightType;
    	  }

    	  static getType() {
    	    return 'code-highlight';
    	  }

    	  static clone(node) {
    	    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);
    	  }

    	  getHighlightType() {
    	    const self = this.getLatest();
    	    return self.__highlightType;
    	  }

    	  createDOM(config) {
    	    const element = super.createDOM(config);
    	    const className = getHighlightThemeClass(config.theme, this.__highlightType);
    	    utils.addClassNamesToElement(element, className);
    	    return element;
    	  }

    	  updateDOM(prevNode, dom, config) {
    	    const update = super.updateDOM(prevNode, dom, config);
    	    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);
    	    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);

    	    if (prevClassName !== nextClassName) {
    	      if (prevClassName) {
    	        utils.removeClassNamesFromElement(dom, prevClassName);
    	      }

    	      if (nextClassName) {
    	        utils.addClassNamesToElement(dom, nextClassName);
    	      }
    	    }

    	    return update;
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);
    	    node.setFormat(serializedNode.format);
    	    node.setDetail(serializedNode.detail);
    	    node.setMode(serializedNode.mode);
    	    node.setStyle(serializedNode.style);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      highlightType: this.getHighlightType(),
    	      type: 'code-highlight',
    	      version: 1
    	    };
    	  } // Prevent formatting (bold, underline, etc)


    	  setFormat(format) {
    	    return this;
    	  }

    	}

    	function getHighlightThemeClass(theme, highlightType) {
    	  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];
    	}

    	function $createCodeHighlightNode(text, highlightType) {
    	  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));
    	}
    	function $isCodeHighlightNode(node) {
    	  return node instanceof CodeHighlightNode;
    	}
    	function getFirstCodeHighlightNodeOfLine(anchor) {
    	  let currentNode = null;
    	  const previousSiblings = anchor.getPreviousSiblings();
    	  previousSiblings.push(anchor);

    	  while (previousSiblings.length > 0) {
    	    const node = previousSiblings.pop();

    	    if ($isCodeHighlightNode(node)) {
    	      currentNode = node;
    	    }

    	    if (lexical.$isLineBreakNode(node)) {
    	      break;
    	    }
    	  }

    	  return currentNode;
    	}
    	function getLastCodeHighlightNodeOfLine(anchor) {
    	  let currentNode = null;
    	  const nextSiblings = anchor.getNextSiblings();
    	  nextSiblings.unshift(anchor);

    	  while (nextSiblings.length > 0) {
    	    const node = nextSiblings.shift();

    	    if ($isCodeHighlightNode(node)) {
    	      currentNode = node;
    	    }

    	    if (lexical.$isLineBreakNode(node)) {
    	      break;
    	    }
    	  }

    	  return currentNode;
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	const mapToPrismLanguage = language => {
    	  // eslint-disable-next-line no-prototype-builtins
    	  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;
    	};

    	function hasChildDOMNodeTag(node, tagName) {
    	  for (const child of node.childNodes) {
    	    if (child instanceof HTMLElement && child.tagName === tagName) {
    	      return true;
    	    }

    	    hasChildDOMNodeTag(child, tagName);
    	  }

    	  return false;
    	}

    	const LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';
    	/** @noInheritDoc */

    	class CodeNode extends lexical.ElementNode {
    	  /** @internal */
    	  static getType() {
    	    return 'code';
    	  }

    	  static clone(node) {
    	    return new CodeNode(node.__language, node.__key);
    	  }

    	  constructor(language, key) {
    	    super(key);
    	    this.__language = mapToPrismLanguage(language);
    	  } // View


    	  createDOM(config) {
    	    const element = document.createElement('code');
    	    utils.addClassNamesToElement(element, config.theme.code);
    	    element.setAttribute('spellcheck', 'false');
    	    const language = this.getLanguage();

    	    if (language) {
    	      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
    	    }

    	    return element;
    	  }

    	  updateDOM(prevNode, dom) {
    	    const language = this.__language;
    	    const prevLanguage = prevNode.__language;

    	    if (language) {
    	      if (language !== prevLanguage) {
    	        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);
    	      }
    	    } else if (prevLanguage) {
    	      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);
    	    }

    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      // Typically <pre> is used for code blocks, and <code> for inline code styles
    	      // but if it's a multi line <code> we'll create a block. Pass through to
    	      // inline format handled by TextNode otherwise
    	      code: node => {
    	        const isMultiLine = node.textContent != null && (/\r?\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));
    	        return isMultiLine ? {
    	          conversion: convertPreElement,
    	          priority: 1
    	        } : null;
    	      },
    	      div: node => ({
    	        conversion: convertDivElement,
    	        priority: 1
    	      }),
    	      pre: node => ({
    	        conversion: convertPreElement,
    	        priority: 0
    	      }),
    	      table: node => {
    	        const table = node; // domNode is a <table> since we matched it by nodeName

    	        if (isGitHubCodeTable(table)) {
    	          return {
    	            conversion: convertTableElement,
    	            priority: 4
    	          };
    	        }

    	        return null;
    	      },
    	      td: node => {
    	        // element is a <td> since we matched it by nodeName
    	        const td = node;
    	        const table = td.closest('table');

    	        if (isGitHubCodeCell(td)) {
    	          return {
    	            conversion: convertTableCellElement,
    	            priority: 4
    	          };
    	        }

    	        if (table && isGitHubCodeTable(table)) {
    	          // Return a no-op if it's a table cell in a code table, but not a code line.
    	          // Otherwise it'll fall back to the T
    	          return {
    	            conversion: convertCodeNoop,
    	            priority: 4
    	          };
    	        }

    	        return null;
    	      },
    	      tr: node => {
    	        // element is a <tr> since we matched it by nodeName
    	        const tr = node;
    	        const table = tr.closest('table');

    	        if (table && isGitHubCodeTable(table)) {
    	          return {
    	            conversion: convertCodeNoop,
    	            priority: 4
    	          };
    	        }

    	        return null;
    	      }
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createCodeNode(serializedNode.language);
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      language: this.getLanguage(),
    	      type: 'code',
    	      version: 1
    	    };
    	  } // Mutation


    	  insertNewAfter(selection, restoreSelection = true) {
    	    const children = this.getChildren();
    	    const childrenLength = children.length;

    	    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\n' && children[childrenLength - 2].getTextContent() === '\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {
    	      children[childrenLength - 1].remove();
    	      children[childrenLength - 2].remove();
    	      const newElement = lexical.$createParagraphNode();
    	      this.insertAfter(newElement, restoreSelection);
    	      return newElement;
    	    } // If the selection is within the codeblock, find all leading tabs and
    	    // spaces of the current line. Create a new line that has all those
    	    // tabs and spaces, such that leading indentation is preserved.


    	    const anchor = selection.anchor.getNode();
    	    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);

    	    if (firstNode != null) {
    	      let leadingWhitespace = 0;
    	      const firstNodeText = firstNode.getTextContent();

    	      while (leadingWhitespace < firstNodeText.length && /[\t ]/.test(firstNodeText[leadingWhitespace])) {
    	        leadingWhitespace += 1;
    	      }

    	      if (leadingWhitespace > 0) {
    	        const whitespace = firstNodeText.substring(0, leadingWhitespace);
    	        const indentedChild = $createCodeHighlightNode(whitespace);
    	        anchor.insertAfter(indentedChild);
    	        selection.insertNodes([lexical.$createLineBreakNode()]);
    	        indentedChild.select();
    	        return indentedChild;
    	      }
    	    }

    	    return null;
    	  }

    	  canInsertTab() {
    	    const selection = lexical.$getSelection();

    	    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
    	      return false;
    	    }

    	    return true;
    	  }

    	  canIndent() {
    	    return false;
    	  }

    	  collapseAtStart() {
    	    const paragraph = lexical.$createParagraphNode();
    	    const children = this.getChildren();
    	    children.forEach(child => paragraph.append(child));
    	    this.replace(paragraph);
    	    return true;
    	  }

    	  setLanguage(language) {
    	    const writable = this.getWritable();
    	    writable.__language = mapToPrismLanguage(language);
    	  }

    	  getLanguage() {
    	    return this.getLatest().__language;
    	  }

    	}
    	function $createCodeNode(language) {
    	  return lexical.$applyNodeReplacement(new CodeNode(language));
    	}
    	function $isCodeNode(node) {
    	  return node instanceof CodeNode;
    	}

    	function convertPreElement(domNode) {
    	  return {
    	    node: $createCodeNode(),
    	    preformatted: true
    	  };
    	}

    	function convertDivElement(domNode) {
    	  // domNode is a <div> since we matched it by nodeName
    	  const div = domNode;
    	  const isCode = isCodeElement(div);

    	  if (!isCode && !isCodeChildElement(div)) {
    	    return {
    	      node: null
    	    };
    	  }

    	  return {
    	    after: childLexicalNodes => {
    	      const domParent = domNode.parentNode;

    	      if (domParent != null && domNode !== domParent.lastChild) {
    	        childLexicalNodes.push(lexical.$createLineBreakNode());
    	      }

    	      return childLexicalNodes;
    	    },
    	    node: isCode ? $createCodeNode() : null,
    	    preformatted: isCode
    	  };
    	}

    	function convertTableElement() {
    	  return {
    	    node: $createCodeNode(),
    	    preformatted: true
    	  };
    	}

    	function convertCodeNoop() {
    	  return {
    	    node: null
    	  };
    	}

    	function convertTableCellElement(domNode) {
    	  // domNode is a <td> since we matched it by nodeName
    	  const cell = domNode;
    	  return {
    	    after: childLexicalNodes => {
    	      if (cell.parentNode && cell.parentNode.nextSibling) {
    	        // Append newline between code lines
    	        childLexicalNodes.push(lexical.$createLineBreakNode());
    	      }

    	      return childLexicalNodes;
    	    },
    	    node: null
    	  };
    	}

    	function isCodeElement(div) {
    	  return div.style.fontFamily.match('monospace') !== null;
    	}

    	function isCodeChildElement(node) {
    	  let parent = node.parentElement;

    	  while (parent !== null) {
    	    if (isCodeElement(parent)) {
    	      return true;
    	    }

    	    parent = parent.parentElement;
    	  }

    	  return false;
    	}

    	function isGitHubCodeCell(cell) {
    	  return cell.classList.contains('js-file-line');
    	}

    	function isGitHubCodeTable(table) {
    	  return table.classList.contains('js-file-line-container');
    	}

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	const PrismTokenizer = {
    	  defaultLanguage: DEFAULT_CODE_LANGUAGE,

    	  tokenize(code, language) {
    	    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);
    	  }

    	};

    	function isSpaceOrTabChar(char) {
    	  return char === ' ' || char === '\t';
    	}

    	function findFirstNotSpaceOrTabCharAtText(text, isForward) {
    	  const length = text.length;
    	  let offset = -1;

    	  if (isForward) {
    	    for (let i = 0; i < length; i++) {
    	      const char = text[i];

    	      if (!isSpaceOrTabChar(char)) {
    	        offset = i;
    	        break;
    	      }
    	    }
    	  } else {
    	    for (let i = length - 1; i > -1; i--) {
    	      const char = text[i];

    	      if (!isSpaceOrTabChar(char)) {
    	        offset = i;
    	        break;
    	      }
    	    }
    	  }

    	  return offset;
    	}

    	function getStartOfCodeInLine(anchor) {
    	  let currentNode = null;
    	  let currentNodeOffset = -1;
    	  const previousSiblings = anchor.getPreviousSiblings();
    	  previousSiblings.push(anchor);

    	  while (previousSiblings.length > 0) {
    	    const node = previousSiblings.pop();

    	    if ($isCodeHighlightNode(node)) {
    	      const text = node.getTextContent();
    	      const offset = findFirstNotSpaceOrTabCharAtText(text, true);

    	      if (offset !== -1) {
    	        currentNode = node;
    	        currentNodeOffset = offset;
    	      }
    	    }

    	    if (lexical.$isLineBreakNode(node)) {
    	      break;
    	    }
    	  }

    	  if (currentNode === null) {
    	    const nextSiblings = anchor.getNextSiblings();

    	    while (nextSiblings.length > 0) {
    	      const node = nextSiblings.shift();

    	      if ($isCodeHighlightNode(node)) {
    	        const text = node.getTextContent();
    	        const offset = findFirstNotSpaceOrTabCharAtText(text, true);

    	        if (offset !== -1) {
    	          currentNode = node;
    	          currentNodeOffset = offset;
    	          break;
    	        }
    	      }

    	      if (lexical.$isLineBreakNode(node)) {
    	        break;
    	      }
    	    }
    	  }

    	  return {
    	    node: currentNode,
    	    offset: currentNodeOffset
    	  };
    	}
    	function getEndOfCodeInLine(anchor) {
    	  let currentNode = null;
    	  let currentNodeOffset = -1;
    	  const nextSiblings = anchor.getNextSiblings();
    	  nextSiblings.unshift(anchor);

    	  while (nextSiblings.length > 0) {
    	    const node = nextSiblings.shift();

    	    if ($isCodeHighlightNode(node)) {
    	      const text = node.getTextContent();
    	      const offset = findFirstNotSpaceOrTabCharAtText(text, false);

    	      if (offset !== -1) {
    	        currentNode = node;
    	        currentNodeOffset = offset + 1;
    	      }
    	    }

    	    if (lexical.$isLineBreakNode(node)) {
    	      break;
    	    }
    	  }

    	  if (currentNode === null) {
    	    const previousSiblings = anchor.getPreviousSiblings();

    	    while (previousSiblings.length > 0) {
    	      const node = previousSiblings.pop();

    	      if ($isCodeHighlightNode(node)) {
    	        const text = node.getTextContent();
    	        const offset = findFirstNotSpaceOrTabCharAtText(text, false);

    	        if (offset !== -1) {
    	          currentNode = node;
    	          currentNodeOffset = offset + 1;
    	          break;
    	        }
    	      }

    	      if (lexical.$isLineBreakNode(node)) {
    	        break;
    	      }
    	    }
    	  }

    	  return {
    	    node: currentNode,
    	    offset: currentNodeOffset
    	  };
    	}

    	function textNodeTransform(node, editor, tokenizer) {
    	  // Since CodeNode has flat children structure we only need to check
    	  // if node's parent is a code node and run highlighting if so
    	  const parentNode = node.getParent();

    	  if ($isCodeNode(parentNode)) {
    	    codeNodeTransform(parentNode, editor, tokenizer);
    	  } else if ($isCodeHighlightNode(node)) {
    	    // When code block converted into paragraph or other element
    	    // code highlight nodes converted back to normal text
    	    node.replace(lexical.$createTextNode(node.__text));
    	  }
    	}

    	function updateCodeGutter(node, editor) {
    	  const codeElement = editor.getElementByKey(node.getKey());

    	  if (codeElement === null) {
    	    return;
    	  }

    	  const children = node.getChildren();
    	  const childrenLength = children.length; // @ts-ignore: internal field

    	  if (childrenLength === codeElement.__cachedChildrenLength) {
    	    // Avoid updating the attribute if the children length hasn't changed.
    	    return;
    	  } // @ts-ignore:: internal field


    	  codeElement.__cachedChildrenLength = childrenLength;
    	  let gutter = '1';
    	  let count = 1;

    	  for (let i = 0; i < childrenLength; i++) {
    	    if (lexical.$isLineBreakNode(children[i])) {
    	      gutter += '\n' + ++count;
    	    }
    	  }

    	  codeElement.setAttribute('data-gutter', gutter);
    	} // Using `skipTransforms` to prevent extra transforms since reformatting the code
    	// will not affect code block content itself.
    	//
    	// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode
    	// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and
    	// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.
    	// Especially when pasting code into CodeBlock.


    	const nodesCurrentlyHighlighting = new Set();

    	function codeNodeTransform(node, editor, tokenizer) {
    	  const nodeKey = node.getKey();

    	  if (nodesCurrentlyHighlighting.has(nodeKey)) {
    	    return;
    	  }

    	  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected

    	  if (node.getLanguage() === undefined) {
    	    node.setLanguage(tokenizer.defaultLanguage);
    	  } // Using nested update call to pass `skipTransforms` since we don't want
    	  // each individual codehighlight node to be transformed again as it's already
    	  // in its final state


    	  editor.update(() => {
    	    updateAndRetainSelection(nodeKey, () => {
    	      const currentNode = lexical.$getNodeByKey(nodeKey);

    	      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {
    	        return false;
    	      }

    	      const code = currentNode.getTextContent();
    	      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);
    	      const highlightNodes = getHighlightNodes(tokens);
    	      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);
    	      const {
    	        from,
    	        to,
    	        nodesForReplacement
    	      } = diffRange;

    	      if (from !== to || nodesForReplacement.length) {
    	        node.splice(from, to - from, nodesForReplacement);
    	        return true;
    	      }

    	      return false;
    	    });
    	  }, {
    	    onUpdate: () => {
    	      nodesCurrentlyHighlighting.delete(nodeKey);
    	    },
    	    skipTransforms: true
    	  });
    	}

    	function getHighlightNodes(tokens) {
    	  const nodes = [];
    	  tokens.forEach(token => {
    	    if (typeof token === 'string') {
    	      const partials = token.split('\n');

    	      for (let i = 0; i < partials.length; i++) {
    	        const text = partials[i];

    	        if (text.length) {
    	          nodes.push($createCodeHighlightNode(text));
    	        }

    	        if (i < partials.length - 1) {
    	          nodes.push(lexical.$createLineBreakNode());
    	        }
    	      }
    	    } else {
    	      const {
    	        content
    	      } = token;

    	      if (typeof content === 'string') {
    	        nodes.push($createCodeHighlightNode(content, token.type));
    	      } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === 'string') {
    	        nodes.push($createCodeHighlightNode(content[0], token.type));
    	      } else if (Array.isArray(content)) {
    	        nodes.push(...getHighlightNodes(content));
    	      }
    	    }
    	  });
    	  return nodes;
    	} // Wrapping update function into selection retainer, that tries to keep cursor at the same
    	// position as before.


    	function updateAndRetainSelection(nodeKey, updateFn) {
    	  const node = lexical.$getNodeByKey(nodeKey);

    	  if (!$isCodeNode(node) || !node.isAttached()) {
    	    return;
    	  }

    	  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,
    	  // but we can still run highlighting logic

    	  if (!lexical.$isRangeSelection(selection)) {
    	    updateFn();
    	    return;
    	  }

    	  const anchor = selection.anchor;
    	  const anchorOffset = anchor.offset;
    	  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));
    	  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)

    	  if (!isNewLineAnchor) {
    	    const anchorNode = anchor.getNode();
    	    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {
    	      return offset + _node.getTextContentSize();
    	    }, 0);
    	  }

    	  const hasChanges = updateFn();

    	  if (!hasChanges) {
    	    return;
    	  } // Non-text anchors only happen for line breaks, otherwise
    	  // selection will be within text node (code highlight node)


    	  if (isNewLineAnchor) {
    	    anchor.getNode().select(anchorOffset, anchorOffset);
    	    return;
    	  } // If it was non-element anchor then we walk through child nodes
    	  // and looking for a position of original text offset


    	  node.getChildren().some(_node => {
    	    const isText = lexical.$isTextNode(_node);

    	    if (isText || lexical.$isLineBreakNode(_node)) {
    	      const textContentSize = _node.getTextContentSize();

    	      if (isText && textContentSize >= textOffset) {
    	        _node.select(textOffset, textOffset);

    	        return true;
    	      }

    	      textOffset -= textContentSize;
    	    }

    	    return false;
    	  });
    	} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes
    	// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.


    	function getDiffRange(prevNodes, nextNodes) {
    	  let leadingMatch = 0;

    	  while (leadingMatch < prevNodes.length) {
    	    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {
    	      break;
    	    }

    	    leadingMatch++;
    	  }

    	  const prevNodesLength = prevNodes.length;
    	  const nextNodesLength = nextNodes.length;
    	  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;
    	  let trailingMatch = 0;

    	  while (trailingMatch < maxTrailingMatch) {
    	    trailingMatch++;

    	    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {
    	      trailingMatch--;
    	      break;
    	    }
    	  }

    	  const from = leadingMatch;
    	  const to = prevNodesLength - trailingMatch;
    	  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);
    	  return {
    	    from,
    	    nodesForReplacement,
    	    to
    	  };
    	}

    	function isEqual(nodeA, nodeB) {
    	  // Only checking for code higlight nodes and linebreaks. If it's regular text node
    	  // returning false so that it's transformed into code highlight node
    	  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {
    	    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;
    	  }

    	  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {
    	    return true;
    	  }

    	  return false;
    	}

    	function handleMultilineIndent(type) {
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {
    	    return false;
    	  } // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks


    	  const nodes = selection.getNodes();

    	  for (let i = 0; i < nodes.length; i++) {
    	    const node = nodes[i];

    	    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
    	      return false;
    	    }
    	  }

    	  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);

    	  if (startOfLine != null) {
    	    doIndent(startOfLine, type);
    	  }

    	  for (let i = 1; i < nodes.length; i++) {
    	    const node = nodes[i];

    	    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {
    	      doIndent(node, type);
    	    }
    	  }

    	  return true;
    	}

    	function doIndent(node, type) {
    	  const text = node.getTextContent();

    	  if (type === lexical.INDENT_CONTENT_COMMAND) {
    	    // If the codeblock node doesn't start with whitespace, we don't want to
    	    // naively prepend a '\t'; Prism will then mangle all of our nodes when
    	    // it separates the whitespace from the first non-whitespace node. This
    	    // will lead to selection bugs when indenting lines that previously
    	    // didn't start with a whitespace character
    	    if (text.length > 0 && /\s/.test(text[0])) {
    	      node.setTextContent('\t' + text);
    	    } else {
    	      const indentNode = $createCodeHighlightNode('\t');
    	      node.insertBefore(indentNode);
    	    }
    	  } else {
    	    if (text.indexOf('\t') === 0) {
    	      // Same as above - if we leave empty text nodes lying around, the resulting
    	      // selection will be mangled
    	      if (text.length === 1) {
    	        node.remove();
    	      } else {
    	        node.setTextContent(text.substring(1));
    	      }
    	    }
    	  }
    	}

    	function handleShiftLines(type, event) {
    	  // We only care about the alt+arrow keys
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection)) {
    	    return false;
    	  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here
    	  // So first, get the anchor and the focus, then get their nodes


    	  const {
    	    anchor,
    	    focus
    	  } = selection;
    	  const anchorOffset = anchor.offset;
    	  const focusOffset = focus.offset;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();
    	  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock

    	  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
    	    return false;
    	  }

    	  if (!event.altKey) {
    	    // Handle moving selection out of the code block, given there are no
    	    // sibling thats can natively take the selection.
    	    if (selection.isCollapsed()) {
    	      const codeNode = anchorNode.getParentOrThrow();

    	      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {
    	        const codeNodeSibling = codeNode.getPreviousSibling();

    	        if (codeNodeSibling === null) {
    	          codeNode.selectPrevious();
    	          event.preventDefault();
    	          return true;
    	        }
    	      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {
    	        const codeNodeSibling = codeNode.getNextSibling();

    	        if (codeNodeSibling === null) {
    	          codeNode.selectNext();
    	          event.preventDefault();
    	          return true;
    	        }
    	      }
    	    }

    	    return false;
    	  }

    	  const start = getFirstCodeHighlightNodeOfLine(anchorNode);
    	  const end = getLastCodeHighlightNodeOfLine(focusNode);

    	  if (start == null || end == null) {
    	    return false;
    	  }

    	  const range = start.getNodesBetween(end);

    	  for (let i = 0; i < range.length; i++) {
    	    const node = range[i];

    	    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {
    	      return false;
    	    }
    	  } // After this point, we know the selection is within the codeblock. We may not be able to
    	  // actually move the lines around, but we want to return true either way to prevent
    	  // the event's default behavior


    	  event.preventDefault();
    	  event.stopPropagation(); // required to stop cursor movement under Firefox

    	  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();

    	  if (!lexical.$isLineBreakNode(linebreak)) {
    	    return true;
    	  }

    	  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();

    	  if (sibling == null) {
    	    return true;
    	  }

    	  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);
    	  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;
    	  linebreak.remove();
    	  range.forEach(node => node.remove());

    	  if (type === lexical.KEY_ARROW_UP_COMMAND) {
    	    range.forEach(node => insertionPoint.insertBefore(node));
    	    insertionPoint.insertBefore(linebreak);
    	  } else {
    	    insertionPoint.insertAfter(linebreak);
    	    insertionPoint = linebreak;
    	    range.forEach(node => {
    	      insertionPoint.insertAfter(node);
    	      insertionPoint = node;
    	    });
    	  }

    	  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);
    	  return true;
    	}

    	function handleMoveTo(type, event) {
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection)) {
    	    return false;
    	  }

    	  const {
    	    anchor,
    	    focus
    	  } = selection;
    	  const anchorNode = anchor.getNode();
    	  const focusNode = focus.getNode();
    	  const isMoveToStart = type === lexical.MOVE_TO_START;

    	  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {
    	    return false;
    	  }

    	  let node;
    	  let offset;

    	  if (isMoveToStart) {
    	    ({
    	      node,
    	      offset
    	    } = getStartOfCodeInLine(focusNode));
    	  } else {
    	    ({
    	      node,
    	      offset
    	    } = getEndOfCodeInLine(focusNode));
    	  }

    	  if (node !== null && offset !== -1) {
    	    selection.setTextNodeRange(node, offset, node, offset);
    	  }

    	  event.preventDefault();
    	  event.stopPropagation();
    	  return true;
    	}

    	function registerCodeHighlighting(editor, tokenizer) {
    	  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {
    	    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');
    	  }

    	  if (tokenizer == null) {
    	    tokenizer = PrismTokenizer;
    	  }

    	  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {
    	    editor.update(() => {
    	      for (const [key, type] of mutations) {
    	        if (type !== 'destroyed') {
    	          const node = lexical.$getNodeByKey(key);

    	          if (node !== null) {
    	            updateCodeGutter(node, editor);
    	          }
    	        }
    	      }
    	    });
    	  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));
    	}

    	LexicalCode_dev.$createCodeHighlightNode = $createCodeHighlightNode;
    	LexicalCode_dev.$createCodeNode = $createCodeNode;
    	LexicalCode_dev.$isCodeHighlightNode = $isCodeHighlightNode;
    	LexicalCode_dev.$isCodeNode = $isCodeNode;
    	LexicalCode_dev.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;
    	LexicalCode_dev.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;
    	LexicalCode_dev.CodeHighlightNode = CodeHighlightNode;
    	LexicalCode_dev.CodeNode = CodeNode;
    	LexicalCode_dev.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;
    	LexicalCode_dev.PrismTokenizer = PrismTokenizer;
    	LexicalCode_dev.getCodeLanguages = getCodeLanguages;
    	LexicalCode_dev.getDefaultCodeLanguage = getDefaultCodeLanguage;
    	LexicalCode_dev.getEndOfCodeInLine = getEndOfCodeInLine;
    	LexicalCode_dev.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;
    	LexicalCode_dev.getLanguageFriendlyName = getLanguageFriendlyName;
    	LexicalCode_dev.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;
    	LexicalCode_dev.getStartOfCodeInLine = getStartOfCodeInLine;
    	LexicalCode_dev.normalizeCodeLang = normalizeCodeLang;
    	LexicalCode_dev.registerCodeHighlighting = registerCodeHighlighting;
    	return LexicalCode_dev;
    }

    var LexicalCode_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalCode_prod;

    function requireLexicalCode_prod () {
    	if (hasRequiredLexicalCode_prod) return LexicalCode_prod;
    	hasRequiredLexicalCode_prod = 1;
    var e=requirePrism();requirePrismClike();requirePrismJavascript();requirePrismMarkup();requirePrismMarkdown();requirePrismC();requirePrismCss();requirePrismObjectivec();requirePrismSql();requirePrismPython();requirePrismRust();requirePrismSwift();
    	requirePrismTypescript();var n=LexicalUtils_1,u=Lexical_1;let v={c:"C",clike:"C-like",css:"CSS",html:"HTML",js:"JavaScript",markdown:"Markdown",objc:"Objective-C",plain:"Plain Text",py:"Python",rust:"Rust",sql:"SQL",swift:"Swift",typescript:"TypeScript",xml:"XML"},x={javascript:"js",md:"markdown",plaintext:"plain",python:"py",text:"plain",ts:"typescript"};function y(a){return x[a]||a}
    	class z extends u.TextNode{constructor(a,b,c){super(a,c);this.__highlightType=b;}static getType(){return "code-highlight"}static clone(a){return new z(a.__text,a.__highlightType||void 0,a.__key)}getHighlightType(){return this.getLatest().__highlightType}createDOM(a){let b=super.createDOM(a);a=A(a.theme,this.__highlightType);n.addClassNamesToElement(b,a);return b}updateDOM(a,b,c){let d=super.updateDOM(a,b,c);a=A(c.theme,a.__highlightType);c=A(c.theme,this.__highlightType);a!==c&&(a&&n.removeClassNamesFromElement(b,
    	a),c&&n.addClassNamesToElement(b,c));return d}static importJSON(a){let b=B(a.text,a.highlightType);b.setFormat(a.format);b.setDetail(a.detail);b.setMode(a.mode);b.setStyle(a.style);return b}exportJSON(){return {...super.exportJSON(),highlightType:this.getHighlightType(),type:"code-highlight",version:1}}setFormat(){return this}}function A(a,b){return b&&a&&a.codeHighlight&&a.codeHighlight[b]}function B(a,b){return u.$applyNodeReplacement(new z(a,b))}function C(a){return a instanceof z}
    	function D(a){let b=null,c=a.getPreviousSiblings();for(c.push(a);0<c.length&&(a=c.pop(),C(a)&&(b=a),!u.$isLineBreakNode(a)););return b}function E(a){let b=null,c=a.getNextSiblings();for(c.unshift(a);0<c.length&&(a=c.shift(),C(a)&&(b=a),!u.$isLineBreakNode(a)););return b}let F=a=>null!=a&&e.languages.hasOwnProperty(a)?a:void 0;function G(a,b){for(let c of a.childNodes){if(c instanceof HTMLElement&&c.tagName===b)return !0;G(c,b);}return !1}
    	class H extends u.ElementNode{static getType(){return "code"}static clone(a){return new H(a.__language,a.__key)}constructor(a,b){super(b);this.__language=F(a);}createDOM(a){let b=document.createElement("code");n.addClassNamesToElement(b,a.theme.code);b.setAttribute("spellcheck","false");(a=this.getLanguage())&&b.setAttribute("data-highlight-language",a);return b}updateDOM(a,b){let c=this.__language;a=a.__language;c?c!==a&&b.setAttribute("data-highlight-language",c):a&&b.removeAttribute("data-highlight-language");
    	return !1}static importDOM(){return {code:a=>null!=a.textContent&&(/\r?\n/.test(a.textContent)||G(a,"BR"))?{conversion:I,priority:1}:null,div:()=>({conversion:aa,priority:1}),pre:()=>({conversion:I,priority:0}),table:a=>J(a)?{conversion:ba,priority:4}:null,td:a=>{let b=a.closest("table");return a.classList.contains("js-file-line")?{conversion:ca,priority:4}:b&&J(b)?{conversion:K,priority:4}:null},tr:a=>(a=a.closest("table"))&&J(a)?{conversion:K,priority:4}:null}}static importJSON(a){let b=L(a.language);
    	b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {...super.exportJSON(),language:this.getLanguage(),type:"code",version:1}}insertNewAfter(a,b=!0){var c=this.getChildren(),d=c.length;if(2<=d&&"\n"===c[d-1].getTextContent()&&"\n"===c[d-2].getTextContent()&&a.isCollapsed()&&a.anchor.key===this.__key&&a.anchor.offset===d)return c[d-1].remove(),c[d-2].remove(),a=u.$createParagraphNode(),this.insertAfter(a,b),a;b=a.anchor.getNode();d=D(b);if(null!=d){c=
    	0;for(d=d.getTextContent();c<d.length&&/[\t ]/.test(d[c]);)c+=1;if(0<c)return c=d.substring(0,c),c=B(c),b.insertAfter(c),a.insertNodes([u.$createLineBreakNode()]),c.select(),c}return null}canInsertTab(){let a=u.$getSelection();return u.$isRangeSelection(a)&&a.isCollapsed()?!0:!1}canIndent(){return !1}collapseAtStart(){let a=u.$createParagraphNode();this.getChildren().forEach(b=>a.append(b));this.replace(a);return !0}setLanguage(a){this.getWritable().__language=F(a);}getLanguage(){return this.getLatest().__language}}
    	function L(a){return u.$applyNodeReplacement(new H(a))}function M(a){return a instanceof H}function I(){return {node:L(),preformatted:!0}}function aa(a){let b=null!==a.style.fontFamily.match("monospace");return b||da(a)?{after:c=>{let d=a.parentNode;null!=d&&a!==d.lastChild&&c.push(u.$createLineBreakNode());return c},node:b?L():null,preformatted:b}:{node:null}}function ba(){return {node:L(),preformatted:!0}}function K(){return {node:null}}
    	function ca(a){return {after:b=>{a.parentNode&&a.parentNode.nextSibling&&b.push(u.$createLineBreakNode());return b},node:null}}function da(a){for(a=a.parentElement;null!==a;){if(null!==a.style.fontFamily.match("monospace"))return !0;a=a.parentElement;}return !1}function J(a){return a.classList.contains("js-file-line-container")}let N={defaultLanguage:"javascript",tokenize(a,b){return e.tokenize(a,e.languages[b||""]||e.languages[this.defaultLanguage])}};
    	function O(a,b){var c=a.length;let d=-1;if(b)for(b=0;b<c;b++){let f=a[b];if(" "!==f&&"\t"!==f){d=b;break}}else for(--c;-1<c;c--)if(b=a[c]," "!==b&&"\t"!==b){d=c;break}return d}
    	function P(a){let b=null,c=-1;var d=a.getPreviousSiblings();for(d.push(a);0<d.length;){var f=d.pop();if(C(f)){var g=f.getTextContent();g=O(g,!0);-1!==g&&(b=f,c=g);}if(u.$isLineBreakNode(f))break}if(null===b)for(a=a.getNextSiblings();0<a.length;){d=a.shift();if(C(d)&&(f=d.getTextContent(),f=O(f,!0),-1!==f)){b=d;c=f;break}if(u.$isLineBreakNode(d))break}return {node:b,offset:c}}
    	function Q(a){let b=null,c=-1;var d=a.getNextSiblings();for(d.unshift(a);0<d.length;){var f=d.shift();if(C(f)){var g=f.getTextContent();g=O(g,!1);-1!==g&&(b=f,c=g+1);}if(u.$isLineBreakNode(f))break}if(null===b)for(a=a.getPreviousSiblings();0<a.length;){d=a.pop();if(C(d)&&(f=d.getTextContent(),f=O(f,!1),-1!==f)){b=d;c=f+1;break}if(u.$isLineBreakNode(d))break}return {node:b,offset:c}}function R(a,b,c){let d=a.getParent();M(d)?S(d,b,c):C(a)&&a.replace(u.$createTextNode(a.__text));}let T=new Set;
    	function S(a,b,c){let d=a.getKey();T.has(d)||(T.add(d),void 0===a.getLanguage()&&a.setLanguage(c.defaultLanguage),b.update(()=>{ea(d,()=>{var f=u.$getNodeByKey(d);if(!M(f)||!f.isAttached())return !1;var g=f.getTextContent();g=c.tokenize(g,f.getLanguage()||c.defaultLanguage);g=U(g);var k=f.getChildren();for(f=0;f<k.length&&V(k[f],g[f]);)f++;var h=k.length;let l=g.length,p=Math.min(h,l)-f,m=0;for(;m<p;)if(m++,!V(k[h-m],g[l-m])){m--;break}k=f;h-=m;g=g.slice(f,l-m);let {from:w,to:t,nodesForReplacement:r}=
    	{from:k,nodesForReplacement:g,to:h};return w!==t||r.length?(a.splice(w,t-w,r),!0):!1});},{onUpdate:()=>{T.delete(d);},skipTransforms:!0}));}
    	function U(a){let b=[];a.forEach(c=>{if("string"===typeof c){c=c.split("\n");for(var d=0;d<c.length;d++){let f=c[d];f.length&&b.push(B(f));d<c.length-1&&b.push(u.$createLineBreakNode());}}else (({content:d}=c)),"string"===typeof d?b.push(B(d,c.type)):Array.isArray(d)&&1===d.length&&"string"===typeof d[0]?b.push(B(d[0],c.type)):Array.isArray(d)&&b.push(...U(d));});return b}
    	function ea(a,b){a=u.$getNodeByKey(a);if(M(a)&&a.isAttached()){var c=u.$getSelection();if(u.$isRangeSelection(c)){c=c.anchor;var d=c.offset,f="element"===c.type&&u.$isLineBreakNode(a.getChildAtIndex(c.offset-1)),g=0;if(!f){let k=c.getNode();g=d+k.getPreviousSiblings().reduce((h,l)=>h+l.getTextContentSize(),0);}b()&&(f?c.getNode().select(d,d):a.getChildren().some(k=>{let h=u.$isTextNode(k);if(h||u.$isLineBreakNode(k)){let l=k.getTextContentSize();if(h&&l>=g)return k.select(g,g),!0;g-=l;}return !1}));}else b();}}
    	function V(a,b){return C(a)&&C(b)?a.__text===b.__text&&a.__highlightType===b.__highlightType:u.$isLineBreakNode(a)&&u.$isLineBreakNode(b)?!0:!1}function W(a){var b=u.$getSelection();if(!u.$isRangeSelection(b)||b.isCollapsed())return !1;b=b.getNodes();for(var c=0;c<b.length;c++){var d=b[c];if(!C(d)&&!u.$isLineBreakNode(d))return !1}c=D(b[0]);null!=c&&X(c,a);for(c=1;c<b.length;c++)d=b[c],u.$isLineBreakNode(b[c-1])&&C(d)&&X(d,a);return !0}
    	function X(a,b){let c=a.getTextContent();b===u.INDENT_CONTENT_COMMAND?0<c.length&&/\s/.test(c[0])?a.setTextContent("\t"+c):(b=B("\t"),a.insertBefore(b)):0===c.indexOf("\t")&&(1===c.length?a.remove():a.setTextContent(c.substring(1)));}
    	function Y(a,b){let c=u.$getSelection();if(!u.$isRangeSelection(c))return !1;let {anchor:d,focus:f}=c,g=d.offset,k=f.offset,h=d.getNode(),l=f.getNode();var p=a===u.KEY_ARROW_UP_COMMAND;if(!C(h)||!C(l))return !1;if(!b.altKey){if(c.isCollapsed())if(a=h.getParentOrThrow(),p&&0===g&&null===h.getPreviousSibling()){if(null===a.getPreviousSibling())return a.selectPrevious(),b.preventDefault(),!0}else if(!p&&g===h.getTextContentSize()&&null===h.getNextSibling()&&null===a.getNextSibling())return a.selectNext(),
    	b.preventDefault(),!0;return !1}var m=D(h);let w=E(l);if(null==m||null==w)return !1;let t=m.getNodesBetween(w);for(let q=0;q<t.length;q++){let Z=t[q];if(!C(Z)&&!u.$isLineBreakNode(Z))return !1}b.preventDefault();b.stopPropagation();b=p?m.getPreviousSibling():w.getNextSibling();if(!u.$isLineBreakNode(b))return !0;m=p?b.getPreviousSibling():b.getNextSibling();if(null==m)return !0;p=p?D(m):E(m);let r=null!=p?p:m;b.remove();t.forEach(q=>q.remove());a===u.KEY_ARROW_UP_COMMAND?(t.forEach(q=>r.insertBefore(q)),
    	r.insertBefore(b)):(r.insertAfter(b),r=b,t.forEach(q=>{r.insertAfter(q);r=q;}));c.setTextNodeRange(h,g,l,k);return !0}function fa(a,b){let c=u.$getSelection();if(!u.$isRangeSelection(c))return !1;let {anchor:d,focus:f}=c,g=d.getNode(),k=f.getNode();a=a===u.MOVE_TO_START;if(!C(g)||!C(k))return !1;let h,l;a?{node:h,offset:l}=P(k):{node:h,offset:l}=Q(k);null!==h&&-1!==l&&c.setTextNodeRange(h,l,h,l);b.preventDefault();b.stopPropagation();return !0}LexicalCode_prod.$createCodeHighlightNode=B;
    	LexicalCode_prod.$createCodeNode=L;LexicalCode_prod.$isCodeHighlightNode=C;LexicalCode_prod.$isCodeNode=M;LexicalCode_prod.CODE_LANGUAGE_FRIENDLY_NAME_MAP=v;LexicalCode_prod.CODE_LANGUAGE_MAP=x;LexicalCode_prod.CodeHighlightNode=z;LexicalCode_prod.CodeNode=H;LexicalCode_prod.DEFAULT_CODE_LANGUAGE="javascript";LexicalCode_prod.PrismTokenizer=N;LexicalCode_prod.getCodeLanguages=()=>Object.keys(e.languages).filter(a=>"function"!==typeof e.languages[a]).sort();LexicalCode_prod.getDefaultCodeLanguage=()=>"javascript";LexicalCode_prod.getEndOfCodeInLine=Q;LexicalCode_prod.getFirstCodeHighlightNodeOfLine=D;
    	LexicalCode_prod.getLanguageFriendlyName=function(a){a=y(a);return v[a]||a};LexicalCode_prod.getLastCodeHighlightNodeOfLine=E;LexicalCode_prod.getStartOfCodeInLine=P;LexicalCode_prod.normalizeCodeLang=y;
    	LexicalCode_prod.registerCodeHighlighting=function(a,b){if(!a.hasNodes([H,z]))throw Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");null==b&&(b=N);return n.mergeRegister(a.registerMutationListener(H,c=>{a.update(()=>{for(let [g,k]of c)if("destroyed"!==k){var d=u.$getNodeByKey(g);if(null!==d)a:{var f=d;d=a.getElementByKey(f.getKey());if(null===d)break a;f=f.getChildren();let h=f.length;if(h===d.__cachedChildrenLength)break a;d.__cachedChildrenLength=h;let l="1",p=1;for(let m=
    	0;m<h;m++)u.$isLineBreakNode(f[m])&&(l+="\n"+ ++p);d.setAttribute("data-gutter",l);}}});}),a.registerNodeTransform(H,c=>S(c,a,b)),a.registerNodeTransform(u.TextNode,c=>R(c,a,b)),a.registerNodeTransform(z,c=>R(c,a,b)),a.registerCommand(u.INDENT_CONTENT_COMMAND,()=>W(u.INDENT_CONTENT_COMMAND),u.COMMAND_PRIORITY_LOW),a.registerCommand(u.OUTDENT_CONTENT_COMMAND,()=>W(u.OUTDENT_CONTENT_COMMAND),u.COMMAND_PRIORITY_LOW),a.registerCommand(u.KEY_ARROW_UP_COMMAND,c=>Y(u.KEY_ARROW_UP_COMMAND,c),u.COMMAND_PRIORITY_LOW),
    	a.registerCommand(u.KEY_ARROW_DOWN_COMMAND,c=>Y(u.KEY_ARROW_DOWN_COMMAND,c),u.COMMAND_PRIORITY_LOW),a.registerCommand(u.MOVE_TO_END,c=>fa(u.MOVE_TO_END,c),u.COMMAND_PRIORITY_LOW),a.registerCommand(u.MOVE_TO_START,c=>fa(u.MOVE_TO_START,c),u.COMMAND_PRIORITY_LOW))};
    	return LexicalCode_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    process.env.NODE_ENV === 'development' ? requireLexicalCode_dev() : requireLexicalCode_prod();

    const isBold = writable(false);
    const isItalic = writable(false);
    const isUnderline = writable(false);
    const isStrikethrough = writable(false);
    const blockType = writable('paragraph');

    const selectedElementKey = writable(null); // TODO: why is this in store?

    /* src/components/toolbar/BlockTypeDropDown.svelte generated by Svelte v3.55.1 */

    function create_if_block$2(ctx) {
    	let div;
    	let button0;
    	let span0;
    	let t0;
    	let span1;
    	let t2;
    	let t3;
    	let button1;
    	let span2;
    	let t4;
    	let span3;
    	let t6;
    	let t7;
    	let button2;
    	let span4;
    	let t8;
    	let span5;
    	let t10;
    	let t11;
    	let button3;
    	let span6;
    	let t12;
    	let span7;
    	let t14;
    	let t15;
    	let button4;
    	let span8;
    	let t16;
    	let span9;
    	let t18;
    	let t19;
    	let button5;
    	let span10;
    	let t20;
    	let span11;
    	let t22;
    	let t23;
    	let button6;
    	let span12;
    	let t24;
    	let span13;
    	let t26;
    	let t27;
    	let button7;
    	let span14;
    	let t28;
    	let span15;
    	let t30;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$blockType*/ ctx[2] === 'paragraph' && create_if_block_8();
    	let if_block1 = /*$blockType*/ ctx[2] === 'h1' && create_if_block_7();
    	let if_block2 = /*$blockType*/ ctx[2] === 'h2' && create_if_block_6();
    	let if_block3 = /*$blockType*/ ctx[2] === 'h3' && create_if_block_5();
    	let if_block4 = /*$blockType*/ ctx[2] === 'bullet' && create_if_block_4();
    	let if_block5 = /*$blockType*/ ctx[2] === 'number' && create_if_block_3$1();
    	let if_block6 = /*$blockType*/ ctx[2] === 'check' && create_if_block_2$2();
    	let if_block7 = /*$blockType*/ ctx[2] === 'quote' && create_if_block_1$2();

    	return {
    		c() {
    			div = element("div");
    			button0 = element("button");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			span1.textContent = "Normal";
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			button1 = element("button");
    			span2 = element("span");
    			t4 = space();
    			span3 = element("span");
    			span3.textContent = "Heading 1";
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			button2 = element("button");
    			span4 = element("span");
    			t8 = space();
    			span5 = element("span");
    			span5.textContent = "Heading 2";
    			t10 = space();
    			if (if_block2) if_block2.c();
    			t11 = space();
    			button3 = element("button");
    			span6 = element("span");
    			t12 = space();
    			span7 = element("span");
    			span7.textContent = "Heading 3";
    			t14 = space();
    			if (if_block3) if_block3.c();
    			t15 = space();
    			button4 = element("button");
    			span8 = element("span");
    			t16 = space();
    			span9 = element("span");
    			span9.textContent = "Bullet List";
    			t18 = space();
    			if (if_block4) if_block4.c();
    			t19 = space();
    			button5 = element("button");
    			span10 = element("span");
    			t20 = space();
    			span11 = element("span");
    			span11.textContent = "Numbered List";
    			t22 = space();
    			if (if_block5) if_block5.c();
    			t23 = space();
    			button6 = element("button");
    			span12 = element("span");
    			t24 = space();
    			span13 = element("span");
    			span13.textContent = "Check List";
    			t26 = space();
    			if (if_block6) if_block6.c();
    			t27 = space();
    			button7 = element("button");
    			span14 = element("span");
    			t28 = space();
    			span15 = element("span");
    			span15.textContent = "Quote";
    			t30 = space();
    			if (if_block7) if_block7.c();
    			attr(span0, "class", "icon paragraph");
    			attr(span1, "class", "text");
    			attr(button0, "class", "item");
    			attr(span2, "class", "icon h1");
    			attr(span3, "class", "text");
    			attr(button1, "class", "item");
    			attr(span4, "class", "icon h2");
    			attr(span5, "class", "text");
    			attr(button2, "class", "item");
    			attr(span6, "class", "icon h3");
    			attr(span7, "class", "text");
    			attr(button3, "class", "item");
    			attr(span8, "class", "icon bullet-list");
    			attr(span9, "class", "text");
    			attr(button4, "class", "item");
    			attr(span10, "class", "icon numbered-list");
    			attr(span11, "class", "text");
    			attr(button5, "class", "item");
    			attr(span12, "class", "icon check-list");
    			attr(span13, "class", "text");
    			attr(button6, "class", "item");
    			attr(span14, "class", "icon quote");
    			attr(span15, "class", "text");
    			attr(button7, "class", "item");
    			attr(div, "class", "dropdown");
    			set_style(div, "top", "45px");
    			set_style(div, "left", "45px");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, button0);
    			append(button0, span0);
    			append(button0, t0);
    			append(button0, span1);
    			append(button0, t2);
    			if (if_block0) if_block0.m(button0, null);
    			append(div, t3);
    			append(div, button1);
    			append(button1, span2);
    			append(button1, t4);
    			append(button1, span3);
    			append(button1, t6);
    			if (if_block1) if_block1.m(button1, null);
    			append(div, t7);
    			append(div, button2);
    			append(button2, span4);
    			append(button2, t8);
    			append(button2, span5);
    			append(button2, t10);
    			if (if_block2) if_block2.m(button2, null);
    			append(div, t11);
    			append(div, button3);
    			append(button3, span6);
    			append(button3, t12);
    			append(button3, span7);
    			append(button3, t14);
    			if (if_block3) if_block3.m(button3, null);
    			append(div, t15);
    			append(div, button4);
    			append(button4, span8);
    			append(button4, t16);
    			append(button4, span9);
    			append(button4, t18);
    			if (if_block4) if_block4.m(button4, null);
    			append(div, t19);
    			append(div, button5);
    			append(button5, span10);
    			append(button5, t20);
    			append(button5, span11);
    			append(button5, t22);
    			if (if_block5) if_block5.m(button5, null);
    			append(div, t23);
    			append(div, button6);
    			append(button6, span12);
    			append(button6, t24);
    			append(button6, span13);
    			append(button6, t26);
    			if (if_block6) if_block6.m(button6, null);
    			append(div, t27);
    			append(div, button7);
    			append(button7, span14);
    			append(button7, t28);
    			append(button7, span15);
    			append(button7, t30);
    			if (if_block7) if_block7.m(button7, null);

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*formatParagraph*/ ctx[5]),
    					listen(button1, "click", /*click_handler*/ ctx[12]),
    					listen(button2, "click", /*click_handler_1*/ ctx[13]),
    					listen(button3, "click", /*click_handler_2*/ ctx[14]),
    					listen(button4, "click", /*formatBulletList*/ ctx[7]),
    					listen(button5, "click", /*formatNumberedList*/ ctx[9]),
    					listen(button6, "click", /*formatCheckList*/ ctx[8]),
    					listen(button7, "click", /*formatQuote*/ ctx[10])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (/*$blockType*/ ctx[2] === 'paragraph') {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_8();
    					if_block0.c();
    					if_block0.m(button0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'h1') {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_7();
    					if_block1.c();
    					if_block1.m(button1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'h2') {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_6();
    					if_block2.c();
    					if_block2.m(button2, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'h3') {
    				if (if_block3) ; else {
    					if_block3 = create_if_block_5();
    					if_block3.c();
    					if_block3.m(button3, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'bullet') {
    				if (if_block4) ; else {
    					if_block4 = create_if_block_4();
    					if_block4.c();
    					if_block4.m(button4, null);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'number') {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_3$1();
    					if_block5.c();
    					if_block5.m(button5, null);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'check') {
    				if (if_block6) ; else {
    					if_block6 = create_if_block_2$2();
    					if_block6.c();
    					if_block6.m(button6, null);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*$blockType*/ ctx[2] === 'quote') {
    				if (if_block7) ; else {
    					if_block7 = create_if_block_1$2();
    					if_block7.c();
    					if_block7.m(button7, null);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    // (131:6) {#if $blockType === 'paragraph'}
    function create_if_block_8(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (138:6) {#if $blockType === 'h1'}
    function create_if_block_7(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (145:6) {#if $blockType === 'h2'}
    function create_if_block_6(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (152:6) {#if $blockType === 'h3'}
    function create_if_block_5(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (160:6) {#if $blockType === 'bullet'}
    function create_if_block_4(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (167:6) {#if $blockType === 'number'}
    function create_if_block_3$1(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (174:6) {#if $blockType === 'check'}
    function create_if_block_2$2(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (181:6) {#if $blockType === 'quote'}
    function create_if_block_1$2(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", "active");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    function create_fragment$t(ctx) {
    	let button_1;
    	let span0;
    	let span0_class_value;
    	let t0;
    	let span1;
    	let t1_value = /*blockTypeToBlockName*/ ctx[3][/*$blockType*/ ctx[2]] + "";
    	let t1;
    	let t2;
    	let i;
    	let t3;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*showBlockOptionsDropDown*/ ctx[1] && create_if_block$2(ctx);

    	return {
    		c() {
    			button_1 = element("button");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			i = element("i");
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(span0, "class", span0_class_value = 'icon block-type ' + /*$blockType*/ ctx[2]);
    			attr(span1, "class", "text");
    			attr(i, "class", "chevron-down");
    			attr(button_1, "class", "toolbar-item block-controls");
    			attr(button_1, "aria-label", "Formatting Options");
    		},
    		m(target, anchor) {
    			insert(target, button_1, anchor);
    			append(button_1, span0);
    			append(button_1, t0);
    			append(button_1, span1);
    			append(span1, t1);
    			append(button_1, t2);
    			append(button_1, i);
    			/*button_1_binding*/ ctx[11](button_1);
    			insert(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = listen(button_1, "click", /*showDropdown*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$blockType*/ 4 && span0_class_value !== (span0_class_value = 'icon block-type ' + /*$blockType*/ ctx[2])) {
    				attr(span0, "class", span0_class_value);
    			}

    			if (dirty & /*$blockType*/ 4 && t1_value !== (t1_value = /*blockTypeToBlockName*/ ctx[3][/*$blockType*/ ctx[2]] + "")) set_data(t1, t1_value);

    			if (/*showBlockOptionsDropDown*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button_1);
    			/*button_1_binding*/ ctx[11](null);
    			if (detaching) detach(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $blockType;
    	component_subscribe($$self, blockType, $$value => $$invalidate(2, $blockType = $$value));

    	const blockTypeToBlockName = {
    		bullet: 'Bulleted List',
    		check: 'Check List',
    		code: 'Code Block',
    		h1: 'Heading 1',
    		h2: 'Heading 2',
    		h3: 'Heading 3',
    		h4: 'Heading 4',
    		h5: 'Heading 5',
    		h6: 'Heading 6',
    		number: 'Numbered List',
    		paragraph: 'Normal',
    		quote: 'Quote'
    	};

    	const editor = getContext('editor');
    	let button;
    	let showBlockOptionsDropDown = false;

    	async function showDropdown(event) {
    		$$invalidate(1, showBlockOptionsDropDown = !showBlockOptionsDropDown);

    		if (showBlockOptionsDropDown && button) {
    			const handle = event => {
    				if (button && !button.contains(event.target)) {
    					$$invalidate(1, showBlockOptionsDropDown = false);
    					button.removeEventListener('click', handle);
    				}
    			};

    			document.addEventListener('click', handle);
    		}
    	}

    	const formatParagraph = () => {
    		if ($blockType !== 'paragraph') {
    			editor.update(() => {
    				const selection = Lexical_1.$getSelection();
    				if (Lexical_1.$isRangeSelection(selection) || Lexical_1.DEPRECATED_$isGridSelection(selection)) LexicalSelectionExports.$setBlocksType_experimental(selection, () => Lexical_1.$createParagraphNode());
    			});
    		}
    	};

    	const formatHeading = headingSize => {
    		if ($blockType !== headingSize) {
    			editor.update(() => {
    				const selection = Lexical_1.$getSelection();

    				if (Lexical_1.$isRangeSelection(selection) || Lexical_1.DEPRECATED_$isGridSelection(selection)) {
    					LexicalSelectionExports.$setBlocksType_experimental(selection, () => LexicalRichText_1.$createHeadingNode(headingSize));
    				}
    			});
    		}
    	};

    	const formatBulletList = () => {
    		if ($blockType !== 'bullet') {
    			editor.dispatchCommand(LexicalList_1.INSERT_UNORDERED_LIST_COMMAND, undefined);
    		} else {
    			editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, undefined);
    		}
    	};

    	const formatCheckList = () => {
    		if ($blockType !== 'check') {
    			editor.dispatchCommand(LexicalList_1.INSERT_CHECK_LIST_COMMAND, undefined);
    		} else {
    			editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, undefined);
    		}
    	};

    	const formatNumberedList = () => {
    		if ($blockType !== 'number') {
    			editor.dispatchCommand(LexicalList_1.INSERT_ORDERED_LIST_COMMAND, undefined);
    		} else {
    			editor.dispatchCommand(LexicalList_1.REMOVE_LIST_COMMAND, undefined);
    		}
    	};

    	const formatQuote = () => {
    		if ($blockType !== 'quote') {
    			editor.update(() => {
    				const selection = Lexical_1.$getSelection();

    				if (Lexical_1.$isRangeSelection(selection) || Lexical_1.DEPRECATED_$isGridSelection(selection)) {
    					LexicalSelectionExports.$setBlocksType_experimental(selection, () => LexicalRichText_1.$createQuoteNode());
    				}
    			});
    		}
    	};

    	function button_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			button = $$value;
    			$$invalidate(0, button);
    		});
    	}

    	const click_handler = () => formatHeading('h1');
    	const click_handler_1 = () => formatHeading('h2');
    	const click_handler_2 = () => formatHeading('h3');

    	return [
    		button,
    		showBlockOptionsDropDown,
    		$blockType,
    		blockTypeToBlockName,
    		showDropdown,
    		formatParagraph,
    		formatHeading,
    		formatBulletList,
    		formatCheckList,
    		formatNumberedList,
    		formatQuote,
    		button_1_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class BlockTypeDropDown extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$r, create_fragment$t, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/BoldButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$s(ctx) {
    	let button;
    	let i;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format bold");
    			attr(button, "class", button_class_value = 'toolbar-item spaced ' + (/*$isBold*/ ctx[0] ? 'active' : ''));
    			attr(button, "aria-label", "Format Bold");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isBold*/ 1 && button_class_value !== (button_class_value = 'toolbar-item spaced ' + (/*$isBold*/ ctx[0] ? 'active' : ''))) {
    				attr(button, "class", button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $isBold;
    	component_subscribe($$self, isBold, $$value => $$invalidate(0, $isBold = $$value));
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_TEXT_COMMAND, 'bold');
    	};

    	return [$isBold, editor, click_handler];
    }

    class BoldButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$q, create_fragment$s, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/Divider.svelte generated by Svelte v3.55.1 */

    function create_fragment$r(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr(div, "class", "divider");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    		}
    	};
    }

    class Divider extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$r, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/RedoButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$q(ctx) {
    	let button;
    	let i;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format redo");
    			button.disabled = button_disabled_value = !/*canRedo*/ ctx[0];
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Redo");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*canRedo*/ 1 && button_disabled_value !== (button_disabled_value = !/*canRedo*/ ctx[0])) {
    				button.disabled = button_disabled_value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$p($$self, $$props, $$invalidate) {
    	const editor = getContext('editor');
    	let canRedo = false;

    	// unregisters onDestroy through returned callback
    	onMount(() => {
    		editor.registerCommand(
    			Lexical_1.CAN_REDO_COMMAND,
    			payload => {
    				$$invalidate(0, canRedo = payload);
    				return false;
    			},
    			Lexical_1.COMMAND_PRIORITY_CRITICAL
    		);
    	});

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.REDO_COMMAND);
    	};

    	return [canRedo, editor, click_handler];
    }

    class RedoButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/UndoButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$p(ctx) {
    	let button;
    	let i;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format undo");
    			button.disabled = button_disabled_value = !/*canUndo*/ ctx[0];
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Undo");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*canUndo*/ 1 && button_disabled_value !== (button_disabled_value = !/*canUndo*/ ctx[0])) {
    				button.disabled = button_disabled_value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$o($$self, $$props, $$invalidate) {
    	const editor = getContext('editor');
    	let canUndo = false;

    	// unregisters onDestroy through returned callback
    	onMount(() => {
    		editor.registerCommand(
    			Lexical_1.CAN_UNDO_COMMAND,
    			payload => {
    				$$invalidate(0, canUndo = payload);
    				return false;
    			},
    			Lexical_1.COMMAND_PRIORITY_CRITICAL
    		);
    	});

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.UNDO_COMMAND);
    	};

    	return [canUndo, editor, click_handler];
    }

    class UndoButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/ItalicButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$o(ctx) {
    	let button;
    	let i;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format italic");
    			attr(button, "class", button_class_value = 'toolbar-item spaced ' + (/*$isItalic*/ ctx[0] ? 'active' : ''));
    			attr(button, "aria-label", "Format Italics");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isItalic*/ 1 && button_class_value !== (button_class_value = 'toolbar-item spaced ' + (/*$isItalic*/ ctx[0] ? 'active' : ''))) {
    				attr(button, "class", button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $isItalic;
    	component_subscribe($$self, isItalic, $$value => $$invalidate(0, $isItalic = $$value));
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_TEXT_COMMAND, 'italic');
    	};

    	return [$isItalic, editor, click_handler];
    }

    class ItalicButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/UnderlineButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$n(ctx) {
    	let button;
    	let i;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format underline");
    			attr(button, "class", button_class_value = "toolbar-item spaced " + (/*$isUnderline*/ ctx[0] ? "active" : ""));
    			attr(button, "aria-label", "Format Underline");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isUnderline*/ 1 && button_class_value !== (button_class_value = "toolbar-item spaced " + (/*$isUnderline*/ ctx[0] ? "active" : ""))) {
    				attr(button, "class", button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $isUnderline;
    	component_subscribe($$self, isUnderline, $$value => $$invalidate(0, $isUnderline = $$value));
    	const editor = getContext("editor");

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_TEXT_COMMAND, "underline");
    	};

    	return [$isUnderline, editor, click_handler];
    }

    class UnderlineButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/StrikethroughButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$m(ctx) {
    	let button;
    	let i;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", "format strikethrough");
    			attr(button, "class", button_class_value = 'toolbar-item spaced ' + (/*$isStrikethrough*/ ctx[0] ? 'active' : ''));
    			attr(button, "aria-label", "Format Strikethrough");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[2]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*$isStrikethrough*/ 1 && button_class_value !== (button_class_value = 'toolbar-item spaced ' + (/*$isStrikethrough*/ ctx[0] ? 'active' : ''))) {
    				attr(button, "class", button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $isStrikethrough;
    	component_subscribe($$self, isStrikethrough, $$value => $$invalidate(0, $isStrikethrough = $$value));
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_TEXT_COMMAND, 'strikethrough');
    	};

    	return [$isStrikethrough, editor, click_handler];
    }

    class StrikethroughButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/FormatCodeButton.svelte generated by Svelte v3.55.1 */

    function instance$k($$self) {
    	getContext('editor');
    	return [];
    }

    class FormatCodeButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$k, null, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/LeftAlignButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$l(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="format left-align"></i>`;
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Left Align");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$j($$self) {
    	const editor = getContext("editor");

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, "left");
    	};

    	return [editor, click_handler];
    }

    class LeftAlignButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$j, create_fragment$l, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/CenterAlignButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$k(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="format center-align"></i>`;
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Center Align");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$i($$self) {
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, 'center');
    	};

    	return [editor, click_handler];
    }

    class CenterAlignButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$i, create_fragment$k, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/RightAlignButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$j(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="format right-align"></i>`;
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Right Align");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$h($$self) {
    	const editor = getContext("editor");

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, "right");
    	};

    	return [editor, click_handler];
    }

    class RightAlignButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$h, create_fragment$j, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/JustifyAlignButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$i(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="format justify-align"></i>`;
    			attr(button, "class", "toolbar-item spaced");
    			attr(button, "aria-label", "Justify Align");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$g($$self) {
    	const editor = getContext("editor");

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, "justify");
    	};

    	return [editor, click_handler];
    }

    class JustifyAlignButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$g, create_fragment$i, safe_not_equal, {});
    	}
    }

    /* src/components/richtext-basic/StateStoreBasicUpdator.svelte generated by Svelte v3.55.1 */

    function instance$f($$self, $$props, $$invalidate) {
    	let $blockType;
    	let $selectedElementKey;
    	let $isStrikethrough;
    	let $isUnderline;
    	let $isItalic;
    	let $isBold;
    	component_subscribe($$self, blockType, $$value => $$invalidate(0, $blockType = $$value));
    	component_subscribe($$self, selectedElementKey, $$value => $$invalidate(1, $selectedElementKey = $$value));
    	component_subscribe($$self, isStrikethrough, $$value => $$invalidate(2, $isStrikethrough = $$value));
    	component_subscribe($$self, isUnderline, $$value => $$invalidate(3, $isUnderline = $$value));
    	component_subscribe($$self, isItalic, $$value => $$invalidate(4, $isItalic = $$value));
    	component_subscribe($$self, isBold, $$value => $$invalidate(5, $isBold = $$value));
    	const editor = getContext('editor');

    	const updateState = () => {
    		const selection = Lexical_1.$getSelection();

    		if (Lexical_1.$isRangeSelection(selection)) {
    			const anchorNode = selection.anchor.getNode();

    			const element = anchorNode.getKey() === 'root'
    			? anchorNode
    			: anchorNode.getTopLevelElementOrThrow();

    			const elementKey = element.getKey();
    			const elementDOM = editor.getElementByKey(elementKey);

    			// Update text format
    			set_store_value(isBold, $isBold = selection.hasFormat('bold'), $isBold);

    			set_store_value(isItalic, $isItalic = selection.hasFormat('italic'), $isItalic);
    			set_store_value(isUnderline, $isUnderline = selection.hasFormat('underline'), $isUnderline);
    			set_store_value(isStrikethrough, $isStrikethrough = selection.hasFormat('strikethrough'), $isStrikethrough);

    			if (elementDOM !== null) {
    				set_store_value(selectedElementKey, $selectedElementKey = elementKey, $selectedElementKey);

    				if (LexicalList_1.$isListNode(element)) {
    					const parentList = LexicalUtils_1.$getNearestNodeOfType(anchorNode, LexicalList_1.ListNode);
    					const type = parentList ? parentList.getTag() : element.getTag();
    					set_store_value(blockType, $blockType = type, $blockType);
    				} else {
    					const type = LexicalRichText_1.$isHeadingNode(element)
    					? element.getTag()
    					: element.getType();

    					set_store_value(blockType, $blockType = type, $blockType);
    				}
    			}
    		}
    	};

    	// unregisters onDestory using returned callback
    	onMount(() => {
    		editor.registerUpdateListener(({ editorState }) => {
    			editorState.read(() => {
    				updateState();
    			});
    		});
    	});

    	return [];
    }

    class StateStoreBasicUpdator extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$f, null, safe_not_equal, {});
    	}
    }

    /* src/components/richtext-basic/ToolbarBasic.svelte generated by Svelte v3.55.1 */

    function create_fragment$h(ctx) {
    	let div;
    	let undobutton;
    	let t0;
    	let redobutton;
    	let t1;
    	let divider0;
    	let t2;
    	let blocktypedropdown;
    	let t3;
    	let divider1;
    	let t4;
    	let boldbutton;
    	let t5;
    	let italicbutton;
    	let t6;
    	let underlinebutton;
    	let t7;
    	let strikethroughbutton;
    	let t8;
    	let formatcodebutton;
    	let t9;
    	let divider2;
    	let t10;
    	let leftalignbutton;
    	let t11;
    	let centeralignbutton;
    	let t12;
    	let rightalignbutton;
    	let t13;
    	let justifyalignbutton;
    	let t14;
    	let statestoresbasicupdator;
    	let current;
    	undobutton = new UndoButton({});
    	redobutton = new RedoButton({});
    	divider0 = new Divider({});
    	blocktypedropdown = new BlockTypeDropDown({});
    	divider1 = new Divider({});
    	boldbutton = new BoldButton({});
    	italicbutton = new ItalicButton({});
    	underlinebutton = new UnderlineButton({});
    	strikethroughbutton = new StrikethroughButton({});
    	formatcodebutton = new FormatCodeButton({});
    	divider2 = new Divider({});
    	leftalignbutton = new LeftAlignButton({});
    	centeralignbutton = new CenterAlignButton({});
    	rightalignbutton = new RightAlignButton({});
    	justifyalignbutton = new JustifyAlignButton({});
    	statestoresbasicupdator = new StateStoreBasicUpdator({});

    	return {
    		c() {
    			div = element("div");
    			create_component(undobutton.$$.fragment);
    			t0 = space();
    			create_component(redobutton.$$.fragment);
    			t1 = space();
    			create_component(divider0.$$.fragment);
    			t2 = space();
    			create_component(blocktypedropdown.$$.fragment);
    			t3 = space();
    			create_component(divider1.$$.fragment);
    			t4 = space();
    			create_component(boldbutton.$$.fragment);
    			t5 = space();
    			create_component(italicbutton.$$.fragment);
    			t6 = space();
    			create_component(underlinebutton.$$.fragment);
    			t7 = space();
    			create_component(strikethroughbutton.$$.fragment);
    			t8 = space();
    			create_component(formatcodebutton.$$.fragment);
    			t9 = space();
    			create_component(divider2.$$.fragment);
    			t10 = space();
    			create_component(leftalignbutton.$$.fragment);
    			t11 = space();
    			create_component(centeralignbutton.$$.fragment);
    			t12 = space();
    			create_component(rightalignbutton.$$.fragment);
    			t13 = space();
    			create_component(justifyalignbutton.$$.fragment);
    			t14 = space();
    			create_component(statestoresbasicupdator.$$.fragment);
    			attr(div, "class", "toolbar");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(undobutton, div, null);
    			append(div, t0);
    			mount_component(redobutton, div, null);
    			append(div, t1);
    			mount_component(divider0, div, null);
    			append(div, t2);
    			mount_component(blocktypedropdown, div, null);
    			append(div, t3);
    			mount_component(divider1, div, null);
    			append(div, t4);
    			mount_component(boldbutton, div, null);
    			append(div, t5);
    			mount_component(italicbutton, div, null);
    			append(div, t6);
    			mount_component(underlinebutton, div, null);
    			append(div, t7);
    			mount_component(strikethroughbutton, div, null);
    			append(div, t8);
    			mount_component(formatcodebutton, div, null);
    			append(div, t9);
    			mount_component(divider2, div, null);
    			append(div, t10);
    			mount_component(leftalignbutton, div, null);
    			append(div, t11);
    			mount_component(centeralignbutton, div, null);
    			append(div, t12);
    			mount_component(rightalignbutton, div, null);
    			append(div, t13);
    			mount_component(justifyalignbutton, div, null);
    			insert(target, t14, anchor);
    			mount_component(statestoresbasicupdator, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(undobutton.$$.fragment, local);
    			transition_in(redobutton.$$.fragment, local);
    			transition_in(divider0.$$.fragment, local);
    			transition_in(blocktypedropdown.$$.fragment, local);
    			transition_in(divider1.$$.fragment, local);
    			transition_in(boldbutton.$$.fragment, local);
    			transition_in(italicbutton.$$.fragment, local);
    			transition_in(underlinebutton.$$.fragment, local);
    			transition_in(strikethroughbutton.$$.fragment, local);
    			transition_in(formatcodebutton.$$.fragment, local);
    			transition_in(divider2.$$.fragment, local);
    			transition_in(leftalignbutton.$$.fragment, local);
    			transition_in(centeralignbutton.$$.fragment, local);
    			transition_in(rightalignbutton.$$.fragment, local);
    			transition_in(justifyalignbutton.$$.fragment, local);
    			transition_in(statestoresbasicupdator.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(undobutton.$$.fragment, local);
    			transition_out(redobutton.$$.fragment, local);
    			transition_out(divider0.$$.fragment, local);
    			transition_out(blocktypedropdown.$$.fragment, local);
    			transition_out(divider1.$$.fragment, local);
    			transition_out(boldbutton.$$.fragment, local);
    			transition_out(italicbutton.$$.fragment, local);
    			transition_out(underlinebutton.$$.fragment, local);
    			transition_out(strikethroughbutton.$$.fragment, local);
    			transition_out(formatcodebutton.$$.fragment, local);
    			transition_out(divider2.$$.fragment, local);
    			transition_out(leftalignbutton.$$.fragment, local);
    			transition_out(centeralignbutton.$$.fragment, local);
    			transition_out(rightalignbutton.$$.fragment, local);
    			transition_out(justifyalignbutton.$$.fragment, local);
    			transition_out(statestoresbasicupdator.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(undobutton);
    			destroy_component(redobutton);
    			destroy_component(divider0);
    			destroy_component(blocktypedropdown);
    			destroy_component(divider1);
    			destroy_component(boldbutton);
    			destroy_component(italicbutton);
    			destroy_component(underlinebutton);
    			destroy_component(strikethroughbutton);
    			destroy_component(formatcodebutton);
    			destroy_component(divider2);
    			destroy_component(leftalignbutton);
    			destroy_component(centeralignbutton);
    			destroy_component(rightalignbutton);
    			destroy_component(justifyalignbutton);
    			if (detaching) detach(t14);
    			destroy_component(statestoresbasicupdator, detaching);
    		}
    	};
    }

    class ToolbarBasic extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$h, safe_not_equal, {});
    	}
    }

    const fontSize = writable('15px');
    const fontFamily = writable('Arial');
    const isRTL = writable(false);

    /* src/components/richtext/StateStoreRichTextUpdator.svelte generated by Svelte v3.55.1 */

    function instance$e($$self, $$props, $$invalidate) {
    	let $fontFamily;
    	let $fontSize;
    	let $blockType;
    	let $selectedElementKey;
    	let $isRTL;
    	let $isStrikethrough;
    	let $isUnderline;
    	let $isItalic;
    	let $isBold;
    	component_subscribe($$self, fontFamily, $$value => $$invalidate(0, $fontFamily = $$value));
    	component_subscribe($$self, fontSize, $$value => $$invalidate(1, $fontSize = $$value));
    	component_subscribe($$self, blockType, $$value => $$invalidate(2, $blockType = $$value));
    	component_subscribe($$self, selectedElementKey, $$value => $$invalidate(3, $selectedElementKey = $$value));
    	component_subscribe($$self, isRTL, $$value => $$invalidate(4, $isRTL = $$value));
    	component_subscribe($$self, isStrikethrough, $$value => $$invalidate(5, $isStrikethrough = $$value));
    	component_subscribe($$self, isUnderline, $$value => $$invalidate(6, $isUnderline = $$value));
    	component_subscribe($$self, isItalic, $$value => $$invalidate(7, $isItalic = $$value));
    	component_subscribe($$self, isBold, $$value => $$invalidate(8, $isBold = $$value));
    	const editor = getContext('editor');

    	const updateState = () => {
    		const selection = Lexical_1.$getSelection();

    		if (Lexical_1.$isRangeSelection(selection)) {
    			const anchorNode = selection.anchor.getNode();

    			const element = anchorNode.getKey() === 'root'
    			? anchorNode
    			: anchorNode.getTopLevelElementOrThrow();

    			const elementKey = element.getKey();
    			const elementDOM = editor.getElementByKey(elementKey);

    			// Update text format
    			set_store_value(isBold, $isBold = selection.hasFormat('bold'), $isBold);

    			set_store_value(isItalic, $isItalic = selection.hasFormat('italic'), $isItalic);
    			set_store_value(isUnderline, $isUnderline = selection.hasFormat('underline'), $isUnderline);
    			set_store_value(isStrikethrough, $isStrikethrough = selection.hasFormat('strikethrough'), $isStrikethrough);
    			set_store_value(isRTL, $isRTL = LexicalSelectionExports.$isParentElementRTL(selection), $isRTL);

    			// Update links
    			// const node = getSelectedNode(selection);
    			// const parent = node.getParent();
    			// if (isLinkNode(parent) || isLinkNode(node)) {
    			//   $isLink = true;
    			// } else {
    			//   $isLink = false;
    			// }
    			if (elementDOM !== null) {
    				set_store_value(selectedElementKey, $selectedElementKey = elementKey, $selectedElementKey);

    				if (LexicalList_1.$isListNode(element)) {
    					const parentList = LexicalUtils_1.$getNearestNodeOfType < LexicalList_1.ListNode > (LexicalList_1.ListNode);

    					const type = parentList
    					? parentList.getListType()
    					: element.getListType();

    					set_store_value(blockType, $blockType = type, $blockType);
    				} else {
    					const type = LexicalRichText_1.$isHeadingNode(element)
    					? element.getTag()
    					: element.getType();

    					set_store_value(blockType, $blockType = type, $blockType);
    				} // if (isCodeNode(element)) {
    				//   setCodeLanguage(element.getLanguage() || getDefaultCodeLanguage());
    			} //   return;
    			// }

    			// Hande buttons
    			set_store_value(fontSize, $fontSize = LexicalSelectionExports.$getSelectionStyleValueForProperty(selection, 'font-size', '15px'), $fontSize);

    			set_store_value(fontFamily, $fontFamily = LexicalSelectionExports.$getSelectionStyleValueForProperty(selection, 'font-family', 'Arial'), $fontFamily);
    		}
    	};

    	// unregisters onDestory using returned callback
    	onMount(() => {
    		editor.registerUpdateListener(({ editorState }) => {
    			editorState.read(() => {
    				updateState();
    			});
    		});
    	});

    	return [];
    }

    class StateStoreRichTextUpdator extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$e, null, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/controls/DropDown.svelte generated by Svelte v3.55.1 */

    function create_if_block_2$1(ctx) {
    	let span;

    	return {
    		c() {
    			span = element("span");
    			attr(span, "class", /*buttonIconClassName*/ ctx[3]);
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*buttonIconClassName*/ 8) {
    				attr(span, "class", /*buttonIconClassName*/ ctx[3]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (34:2) {#if buttonLabel}
    function create_if_block_1$1(ctx) {
    	let span;
    	let t;

    	return {
    		c() {
    			span = element("span");
    			t = text(/*buttonLabel*/ ctx[0]);
    			attr(span, "class", "text dropdown-button-text");
    		},
    		m(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*buttonLabel*/ 1) set_data(t, /*buttonLabel*/ ctx[0]);
    		},
    		d(detaching) {
    			if (detaching) detach(span);
    		}
    	};
    }

    // (40:0) {#if isDropDownOpen}
    function create_if_block$1(ctx) {
    	let div;
    	let div_style_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr(div, "class", "dropdown");
    			attr(div, "style", div_style_value = `top: 45px;left:${/*button*/ ctx[5].offsetLeft}px`);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*button*/ 32 && div_style_value !== (div_style_value = `top: 45px;left:${/*button*/ ctx[5].offsetLeft}px`)) {
    				attr(div, "style", div_style_value);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function create_fragment$g(ctx) {
    	let button_1;
    	let t0;
    	let t1;
    	let i;
    	let button_1_aria_label_value;
    	let t2;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*buttonClassName*/ ctx[2] && create_if_block_2$1(ctx);
    	let if_block1 = /*buttonLabel*/ ctx[0] && create_if_block_1$1(ctx);
    	let if_block2 = /*isDropDownOpen*/ ctx[4] && create_if_block$1(ctx);

    	return {
    		c() {
    			button_1 = element("button");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			i = element("i");
    			t2 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr(i, "class", "chevron-down");
    			attr(button_1, "aria-label", button_1_aria_label_value = /*buttonAriaLabel*/ ctx[1] || /*buttonLabel*/ ctx[0]);
    			attr(button_1, "class", /*buttonClassName*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, button_1, anchor);
    			if (if_block0) if_block0.m(button_1, null);
    			append(button_1, t0);
    			if (if_block1) if_block1.m(button_1, null);
    			append(button_1, t1);
    			append(button_1, i);
    			/*button_1_binding*/ ctx[9](button_1);
    			insert(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen(button_1, "click", /*showDropdown*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (/*buttonClassName*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(button_1, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*buttonLabel*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					if_block1.m(button_1, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*buttonAriaLabel, buttonLabel*/ 3 && button_1_aria_label_value !== (button_1_aria_label_value = /*buttonAriaLabel*/ ctx[1] || /*buttonLabel*/ ctx[0])) {
    				attr(button_1, "aria-label", button_1_aria_label_value);
    			}

    			if (!current || dirty & /*buttonClassName*/ 4) {
    				attr(button_1, "class", /*buttonClassName*/ ctx[2]);
    			}

    			if (/*isDropDownOpen*/ ctx[4]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isDropDownOpen*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(button_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*button_1_binding*/ ctx[9](null);
    			if (detaching) detach(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach(if_block2_anchor);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let isDropDownOpen = false;
    	let button;
    	let { buttonLabel } = $$props;
    	let { buttonAriaLabel = null } = $$props;
    	let { buttonClassName } = $$props;
    	let { buttonIconClassName } = $$props;

    	function showDropdown() {
    		$$invalidate(4, isDropDownOpen = !isDropDownOpen);

    		if (isDropDownOpen && button) {
    			const handle = event => {
    				if (button && !button.contains(event.target)) {
    					$$invalidate(4, isDropDownOpen = false);
    					button.removeEventListener('click', handle);
    				}
    			};

    			document.addEventListener('click', handle);
    		}
    	}

    	function button_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			button = $$value;
    			$$invalidate(5, button);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('buttonLabel' in $$props) $$invalidate(0, buttonLabel = $$props.buttonLabel);
    		if ('buttonAriaLabel' in $$props) $$invalidate(1, buttonAriaLabel = $$props.buttonAriaLabel);
    		if ('buttonClassName' in $$props) $$invalidate(2, buttonClassName = $$props.buttonClassName);
    		if ('buttonIconClassName' in $$props) $$invalidate(3, buttonIconClassName = $$props.buttonIconClassName);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	return [
    		buttonLabel,
    		buttonAriaLabel,
    		buttonClassName,
    		buttonIconClassName,
    		isDropDownOpen,
    		button,
    		showDropdown,
    		$$scope,
    		slots,
    		button_1_binding
    	];
    }

    class DropDown extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(this, options, instance$d, create_fragment$g, safe_not_equal, {
    			buttonLabel: 0,
    			buttonAriaLabel: 1,
    			buttonClassName: 2,
    			buttonIconClassName: 3
    		});
    	}
    }

    /* src/components/toolbar/DropDownAlign.svelte generated by Svelte v3.55.1 */

    function create_default_slot$3(ctx) {
    	let button0;
    	let t2;
    	let button1;
    	let t5;
    	let button2;
    	let t8;
    	let button3;
    	let t11;
    	let divider;
    	let t12;
    	let button4;
    	let i4;
    	let i4_class_value;
    	let t13;
    	let span4;
    	let t15;
    	let button5;
    	let i5;
    	let i5_class_value;
    	let t16;
    	let span5;
    	let current;
    	let mounted;
    	let dispose;
    	divider = new Divider({});

    	return {
    		c() {
    			button0 = element("button");

    			button0.innerHTML = `<i class="icon left-align"></i> 
    <span class="text">Left Align</span>`;

    			t2 = space();
    			button1 = element("button");

    			button1.innerHTML = `<i class="icon center-align"></i> 
    <span class="text">Center Align</span>`;

    			t5 = space();
    			button2 = element("button");

    			button2.innerHTML = `<i class="icon right-align"></i> 
    <span class="text">Right Align</span>`;

    			t8 = space();
    			button3 = element("button");

    			button3.innerHTML = `<i class="icon justify-align"></i> 
    <span class="text">Justify Align</span>`;

    			t11 = space();
    			create_component(divider.$$.fragment);
    			t12 = space();
    			button4 = element("button");
    			i4 = element("i");
    			t13 = space();
    			span4 = element("span");
    			span4.textContent = "Indent";
    			t15 = space();
    			button5 = element("button");
    			i5 = element("i");
    			t16 = space();
    			span5 = element("span");
    			span5.textContent = "Outdent";
    			attr(button0, "class", "item");
    			attr(button1, "class", "item");
    			attr(button2, "class", "item");
    			attr(button3, "class", "item");
    			attr(i4, "class", i4_class_value = 'icon ' + (/*$isRTL*/ ctx[0] ? 'outdent' : 'indent'));
    			attr(span4, "class", "text");
    			attr(button4, "class", "item");
    			attr(i5, "class", i5_class_value = 'icon ' + (/*$isRTL*/ ctx[0] ? 'indent' : 'outdent'));
    			attr(span5, "class", "text");
    			attr(button5, "class", "item");
    		},
    		m(target, anchor) {
    			insert(target, button0, anchor);
    			insert(target, t2, anchor);
    			insert(target, button1, anchor);
    			insert(target, t5, anchor);
    			insert(target, button2, anchor);
    			insert(target, t8, anchor);
    			insert(target, button3, anchor);
    			insert(target, t11, anchor);
    			mount_component(divider, target, anchor);
    			insert(target, t12, anchor);
    			insert(target, button4, anchor);
    			append(button4, i4);
    			append(button4, t13);
    			append(button4, span4);
    			insert(target, t15, anchor);
    			insert(target, button5, anchor);
    			append(button5, i5);
    			append(button5, t16);
    			append(button5, span5);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*click_handler*/ ctx[2]),
    					listen(button1, "click", /*click_handler_1*/ ctx[3]),
    					listen(button2, "click", /*click_handler_2*/ ctx[4]),
    					listen(button3, "click", /*click_handler_3*/ ctx[5]),
    					listen(button4, "click", /*click_handler_4*/ ctx[6]),
    					listen(button5, "click", /*click_handler_5*/ ctx[7])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (!current || dirty & /*$isRTL*/ 1 && i4_class_value !== (i4_class_value = 'icon ' + (/*$isRTL*/ ctx[0] ? 'outdent' : 'indent'))) {
    				attr(i4, "class", i4_class_value);
    			}

    			if (!current || dirty & /*$isRTL*/ 1 && i5_class_value !== (i5_class_value = 'icon ' + (/*$isRTL*/ ctx[0] ? 'indent' : 'outdent'))) {
    				attr(i5, "class", i5_class_value);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(divider.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(divider.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(button0);
    			if (detaching) detach(t2);
    			if (detaching) detach(button1);
    			if (detaching) detach(t5);
    			if (detaching) detach(button2);
    			if (detaching) detach(t8);
    			if (detaching) detach(button3);
    			if (detaching) detach(t11);
    			destroy_component(divider, detaching);
    			if (detaching) detach(t12);
    			if (detaching) detach(button4);
    			if (detaching) detach(t15);
    			if (detaching) detach(button5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$f(ctx) {
    	let dropdown;
    	let current;

    	dropdown = new DropDown({
    			props: {
    				buttonLabel: "Align",
    				buttonIconClassName: "icon left-align",
    				buttonClassName: "toolbar-item spaced",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			}
    		});

    	return {
    		c() {
    			create_component(dropdown.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const dropdown_changes = {};

    			if (dirty & /*$$scope, $isRTL*/ 257) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(dropdown, detaching);
    		}
    	};
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $isRTL;
    	component_subscribe($$self, isRTL, $$value => $$invalidate(0, $isRTL = $$value));
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, 'left');
    	};

    	const click_handler_1 = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, 'center');
    	};

    	const click_handler_2 = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, 'right');
    	};

    	const click_handler_3 = () => {
    		editor.dispatchCommand(Lexical_1.FORMAT_ELEMENT_COMMAND, 'justify');
    	};

    	const click_handler_4 = () => {
    		editor.dispatchCommand(Lexical_1.INDENT_CONTENT_COMMAND);
    	};

    	const click_handler_5 = () => {
    		editor.dispatchCommand(Lexical_1.OUTDENT_CONTENT_COMMAND);
    	};

    	return [
    		$isRTL,
    		editor,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5
    	];
    }

    class DropDownAlign extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$c, create_fragment$f, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/controls/Select.svelte generated by Svelte v3.55.1 */

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (10:2) {#each options as option}
    function create_each_block(ctx) {
    	let option;
    	let t0_value = /*option*/ ctx[5] + "";
    	let t0;
    	let t1;
    	let option_key_value;
    	let option_value_value;

    	return {
    		c() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = space();
    			attr(option, "key", option_key_value = /*option*/ ctx[5]);
    			option.__value = option_value_value = /*option*/ ctx[5];
    			option.value = option.__value;
    		},
    		m(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t0);
    			append(option, t1);
    		},
    		p(ctx, dirty) {
    			if (dirty & /*options*/ 2 && t0_value !== (t0_value = /*option*/ ctx[5] + "")) set_data(t0, t0_value);

    			if (dirty & /*options*/ 2 && option_key_value !== (option_key_value = /*option*/ ctx[5])) {
    				attr(option, "key", option_key_value);
    			}

    			if (dirty & /*options*/ 2 && option_value_value !== (option_value_value = /*option*/ ctx[5])) {
    				option.__value = option_value_value;
    				option.value = option.__value;
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(option);
    		}
    	};
    }

    function create_fragment$e(ctx) {
    	let select;
    	let option;
    	let t;
    	let mounted;
    	let dispose;
    	let each_value = /*options*/ ctx[1];
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	return {
    		c() {
    			select = element("select");
    			option = element("option");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = text("}");
    			option.hidden = true;
    			option.__value = "";
    			option.value = option.__value;
    			attr(select, "class", /*className*/ ctx[2]);
    			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[4].call(select));
    		},
    		m(target, anchor) {
    			insert(target, select, anchor);
    			append(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append(select, t);
    			select_option(select, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen(select, "change", /*change_handler*/ ctx[3]),
    					listen(select, "change", /*select_change_handler*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*options*/ 2) {
    				each_value = /*options*/ ctx[1];
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*className*/ 4) {
    				attr(select, "class", /*className*/ ctx[2]);
    			}

    			if (dirty & /*value, options*/ 3) {
    				select_option(select, /*value*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(select);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { options } = $$props;
    	let { class: className } = $$props;
    	let { value } = $$props;

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function select_change_handler() {
    		value = select_value(this);
    		$$invalidate(0, value);
    		$$invalidate(1, options);
    	}

    	$$self.$$set = $$props => {
    		if ('options' in $$props) $$invalidate(1, options = $$props.options);
    		if ('class' in $$props) $$invalidate(2, className = $$props.class);
    		if ('value' in $$props) $$invalidate(0, value = $$props.value);
    	};

    	return [value, options, className, change_handler, select_change_handler];
    }

    class Select extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$b, create_fragment$e, safe_not_equal, { options: 1, class: 2, value: 0 });
    	}
    }

    /* src/components/toolbar/FontFamilySelect.svelte generated by Svelte v3.55.1 */

    function create_fragment$d(ctx) {
    	let select;
    	let updating_value;
    	let t;
    	let i;
    	let current;

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[2](value);
    	}

    	let select_props = {
    		class: "toolbar-item font-family",
    		options: [
    			'Arial',
    			'Courier New',
    			'Georgia',
    			'Times New Roman',
    			'Trebuchet MS',
    			'Verdana'
    		]
    	};

    	if (/*$fontFamily*/ ctx[0] !== void 0) {
    		select_props.value = /*$fontFamily*/ ctx[0];
    	}

    	select = new Select({ props: select_props });
    	binding_callbacks.push(() => bind(select, 'value', select_value_binding));
    	select.$on("change", /*change_handler*/ ctx[3]);

    	return {
    		c() {
    			create_component(select.$$.fragment);
    			t = space();
    			i = element("i");
    			attr(i, "class", "chevron-down inside");
    		},
    		m(target, anchor) {
    			mount_component(select, target, anchor);
    			insert(target, t, anchor);
    			insert(target, i, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const select_changes = {};

    			if (!updating_value && dirty & /*$fontFamily*/ 1) {
    				updating_value = true;
    				select_changes.value = /*$fontFamily*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(select, detaching);
    			if (detaching) detach(t);
    			if (detaching) detach(i);
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $fontFamily;
    	component_subscribe($$self, fontFamily, $$value => $$invalidate(0, $fontFamily = $$value));
    	const editor = getContext('editor');

    	function applyStyleText(styles) {
    		editor.update(() => {
    			const selection = Lexical_1.$getSelection();

    			if (Lexical_1.$isRangeSelection(selection)) {
    				LexicalSelectionExports.$patchStyleText(selection, styles);
    			}
    		});
    	}

    	function select_value_binding(value) {
    		$fontFamily = value;
    		fontFamily.set($fontFamily);
    	}

    	const change_handler = e => applyStyleText({ 'font-family': e.target.value });
    	return [$fontFamily, applyStyleText, select_value_binding, change_handler];
    }

    class FontFamilySelect extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$a, create_fragment$d, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/FontSizeSelect.svelte generated by Svelte v3.55.1 */

    function create_fragment$c(ctx) {
    	let select;
    	let updating_value;
    	let t;
    	let i;
    	let current;

    	function select_value_binding(value) {
    		/*select_value_binding*/ ctx[2](value);
    	}

    	let select_props = {
    		class: "toolbar-item font-size",
    		options: [
    			'10px',
    			'11px',
    			'12px',
    			'13px',
    			'14px',
    			'15px',
    			'16px',
    			'17px',
    			'18px',
    			'19px',
    			'20px'
    		]
    	};

    	if (/*$fontSize*/ ctx[0] !== void 0) {
    		select_props.value = /*$fontSize*/ ctx[0];
    	}

    	select = new Select({ props: select_props });
    	binding_callbacks.push(() => bind(select, 'value', select_value_binding));
    	select.$on("change", /*change_handler*/ ctx[3]);

    	return {
    		c() {
    			create_component(select.$$.fragment);
    			t = space();
    			i = element("i");
    			attr(i, "class", "chevron-down inside");
    		},
    		m(target, anchor) {
    			mount_component(select, target, anchor);
    			insert(target, t, anchor);
    			insert(target, i, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const select_changes = {};

    			if (!updating_value && dirty & /*$fontSize*/ 1) {
    				updating_value = true;
    				select_changes.value = /*$fontSize*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			select.$set(select_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(select, detaching);
    			if (detaching) detach(t);
    			if (detaching) detach(i);
    		}
    	};
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $fontSize;
    	component_subscribe($$self, fontSize, $$value => $$invalidate(0, $fontSize = $$value));
    	const editor = getContext('editor');

    	function applyStyleText(styles) {
    		editor.update(() => {
    			const selection = Lexical_1.$getSelection();

    			if (Lexical_1.$isRangeSelection(selection)) {
    				LexicalSelectionExports.$patchStyleText(selection, styles);
    			}
    		});
    	}

    	function select_value_binding(value) {
    		$fontSize = value;
    		fontSize.set($fontSize);
    	}

    	const change_handler = e => applyStyleText({ 'font-size': e.target.value });
    	return [$fontSize, applyStyleText, select_value_binding, change_handler];
    }

    class FontSizeSelect extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$9, create_fragment$c, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/controls/ModalDialog.svelte generated by Svelte v3.55.1 */

    function add_css$1(target) {
    	append_styles(target, "svelte-dstsns", "#topModal.svelte-dstsns.svelte-dstsns{visibility:hidden;z-index:9999;position:fixed;top:0;left:0;right:0;bottom:0;background:#4448;display:flex;align-items:center;justify-content:center}#modal.svelte-dstsns.svelte-dstsns{position:relative;border-radius:6px;background:white;filter:drop-shadow(5px 5px 5px #555);padding:1em}.visible.svelte-dstsns.svelte-dstsns{visibility:visible !important}#close.svelte-dstsns.svelte-dstsns{position:absolute;top:-12px;right:-12px;width:24px;height:24px;cursor:pointer;fill:#f44;transition:transform 0.3s}#close.svelte-dstsns.svelte-dstsns:hover{transform:scale(2)}#close.svelte-dstsns line.svelte-dstsns{stroke:#fff;stroke-width:2}#modal-content.svelte-dstsns.svelte-dstsns{max-width:calc(100vw - 20px);max-height:calc(100vh - 20px);overflow:auto}");
    }

    function create_fragment$b(ctx) {
    	let div2;
    	let div1;
    	let svg;
    	let circle;
    	let line0;
    	let line1;
    	let t;
    	let div0;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	return {
    		c() {
    			div2 = element("div");
    			div1 = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			t = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr(circle, "cx", "6");
    			attr(circle, "cy", "6");
    			attr(circle, "r", "6");
    			attr(line0, "x1", "3");
    			attr(line0, "y1", "3");
    			attr(line0, "x2", "9");
    			attr(line0, "y2", "9");
    			attr(line0, "class", "svelte-dstsns");
    			attr(line1, "x1", "9");
    			attr(line1, "y1", "3");
    			attr(line1, "x2", "3");
    			attr(line1, "y2", "9");
    			attr(line1, "class", "svelte-dstsns");
    			attr(svg, "id", "close");
    			attr(svg, "viewBox", "0 0 12 12");
    			attr(svg, "class", "svelte-dstsns");
    			attr(div0, "id", "modal-content");
    			attr(div0, "class", "svelte-dstsns");
    			attr(div1, "id", "modal");
    			attr(div1, "class", "Modal__modal svelte-dstsns");
    			attr(div2, "id", "topModal");
    			attr(div2, "class", "svelte-dstsns");
    			toggle_class(div2, "visible", /*visible*/ ctx[1]);
    		},
    		m(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div1);
    			append(div1, svg);
    			append(svg, circle);
    			append(svg, line0);
    			append(svg, line1);
    			append(div1, t);
    			append(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div2_binding*/ ctx[7](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen(svg, "click", /*click_handler*/ ctx[6]),
    					listen(div1, "click", stop_propagation(click_handler_1)),
    					listen(div2, "click", /*click_handler_2*/ ctx[8])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*visible*/ 2) {
    				toggle_class(div2, "visible", /*visible*/ ctx[1]);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div2);
    			if (default_slot) default_slot.d(detaching);
    			/*div2_binding*/ ctx[7](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    let onTop; // keeping track of which open modal is on top
    const modals = {}; // all modals get registered here for easy future access
    const getModal = (id = '') => modals[id];

    const click_handler_1 = () => {
    	
    };

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let topDiv;
    	let visible = false;
    	let prevOnTop;
    	let closeCallback;
    	let { id = '' } = $$props;
    	let close;
    	let handleKeydown;

    	onMount(() => {
    		handleKeydown = ev => {
    			// only respond if the current modal is the top one
    			if (ev.key === 'Escape' && onTop === topDiv) close(); // ESC
    		};

    		const open = callback => {
    			closeCallback = callback;
    			if (visible) return;
    			prevOnTop = onTop;
    			onTop = topDiv;
    			window.addEventListener('keydown', handleKeydown);

    			// this prevents scrolling of the main window on larger screens
    			document.body.style.overflow = 'hidden';

    			$$invalidate(1, visible = true);

    			// Move the modal in the DOM to be the last child of <body> so that it can be on top of everything
    			document.body.appendChild(topDiv);
    		};

    		$$invalidate(2, close = retVal => {
    			if (!visible) return;
    			window.removeEventListener('keydown', handleKeydown);
    			onTop = prevOnTop;
    			if (onTop == null) document.body.style.overflow = '';
    			$$invalidate(1, visible = false);
    			if (closeCallback) closeCallback(retVal);
    		});

    		// expose the API
    		modals[id] = { open, close };
    	});

    	onDestroy(() => {
    		delete modals[id];

    		if (typeof window !== 'undefined') {
    			window.removeEventListener('keydown', handleKeydown);
    		}
    	});

    	const click_handler = () => close();

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			topDiv = $$value;
    			$$invalidate(0, topDiv);
    		});
    	}

    	const click_handler_2 = () => close();

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(3, id = $$props.id);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	return [
    		topDiv,
    		visible,
    		close,
    		id,
    		$$scope,
    		slots,
    		click_handler,
    		div2_binding,
    		click_handler_2
    	];
    }

    class ModalDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$8, create_fragment$b, safe_not_equal, { id: 3 }, add_css$1);
    	}
    }

    /* src/components/toolbar/InsertImageDialog.svelte generated by Svelte v3.55.1 */

    function create_default_slot$2(ctx) {
    	let h2;
    	let t1;
    	let div3;
    	let div0;
    	let label0;
    	let t3;
    	let input0;
    	let t4;
    	let div1;
    	let label1;
    	let t6;
    	let input1;
    	let t7;
    	let div2;
    	let button;
    	let t8;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			h2 = element("h2");
    			h2.textContent = "Insert Image";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Image URL";
    			t3 = space();
    			input0 = element("input");
    			t4 = space();
    			div1 = element("div");
    			label1 = element("label");
    			label1.textContent = "Alt Text";
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			div2 = element("div");
    			button = element("button");
    			t8 = text("Confirm");
    			attr(h2, "class", "Modal__title");
    			attr(label0, "class", "Input__label");
    			attr(label0, "for", "lexical-modal-image-url");
    			attr(input0, "type", "text");
    			attr(input0, "class", "Input__input");
    			attr(input0, "placeholder", "i.e. https://source.unsplash.com/random");
    			attr(input0, "id", "lexical-modal-image-url");
    			attr(div0, "class", "Input__wrapper");
    			attr(label1, "class", "Input__label");
    			attr(label1, "for", "lexical-modal-image-alttext");
    			attr(input1, "type", "text");
    			attr(input1, "class", "Input__input");
    			attr(input1, "placeholder", "Random unsplash image");
    			attr(input1, "id", "lexical-modal-image-alttext");
    			attr(div1, "class", "Input__wrapper");
    			button.disabled = /*isDisabled*/ ctx[2];
    			attr(button, "class", "Button__root");
    			attr(div2, "class", "ToolbarPlugin__dialogActions");
    			attr(div3, "class", "Modal__content");
    		},
    		m(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			insert(target, div3, anchor);
    			append(div3, div0);
    			append(div0, label0);
    			append(div0, t3);
    			append(div0, input0);
    			set_input_value(input0, /*src*/ ctx[0]);
    			append(div3, t4);
    			append(div3, div1);
    			append(div1, label1);
    			append(div1, t6);
    			append(div1, input1);
    			set_input_value(input1, /*altText*/ ctx[1]);
    			append(div3, t7);
    			append(div3, div2);
    			append(div2, button);
    			append(button, t8);

    			if (!mounted) {
    				dispose = [
    					listen(input0, "input", /*input0_input_handler*/ ctx[4]),
    					listen(input1, "input", /*input1_input_handler*/ ctx[5]),
    					listen(button, "click", /*click_handler*/ ctx[6])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty & /*src*/ 1 && input0.value !== /*src*/ ctx[0]) {
    				set_input_value(input0, /*src*/ ctx[0]);
    			}

    			if (dirty & /*altText*/ 2 && input1.value !== /*altText*/ ctx[1]) {
    				set_input_value(input1, /*altText*/ ctx[1]);
    			}

    			if (dirty & /*isDisabled*/ 4) {
    				button.disabled = /*isDisabled*/ ctx[2];
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(h2);
    			if (detaching) detach(t1);
    			if (detaching) detach(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$a(ctx) {
    	let modaldialog;
    	let current;

    	modaldialog = new ModalDialog({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			}
    		});

    	return {
    		c() {
    			create_component(modaldialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(modaldialog, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const modaldialog_changes = {};

    			if (dirty & /*$$scope, isDisabled, altText, src*/ 135) {
    				modaldialog_changes.$$scope = { dirty, ctx };
    			}

    			modaldialog.$set(modaldialog_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(modaldialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(modaldialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(modaldialog, detaching);
    		}
    	};
    }

    function open() {
    	getModal().open();
    }

    function close() {
    	getModal().close();
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let isDisabled;
    	const dispatch = createEventDispatcher();
    	let src = '';
    	let altText = '';

    	function input0_input_handler() {
    		src = this.value;
    		$$invalidate(0, src);
    	}

    	function input1_input_handler() {
    		altText = this.value;
    		$$invalidate(1, altText);
    	}

    	const click_handler = () => dispatch('confirm', { altText, src });

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*src*/ 1) {
    			$$invalidate(2, isDisabled = src === '');
    		}
    	};

    	return [
    		src,
    		altText,
    		isDisabled,
    		dispatch,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler
    	];
    }

    class InsertImageDialog extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$7, create_fragment$a, safe_not_equal, {});
    	}
    }

    /* src/components/toolbar/InsertDropDown.svelte generated by Svelte v3.55.1 */

    function create_default_slot$1(ctx) {
    	let button0;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button0 = element("button");

    			button0.innerHTML = `<i class="icon horizontal-rule"></i> 
    <span class="text">Horizontal Rule</span>`;

    			t2 = space();
    			button1 = element("button");

    			button1.innerHTML = `<i class="icon image"></i> 
    <span class="text">Image</span>`;

    			attr(button0, "class", "item");
    			attr(button1, "class", "item");
    		},
    		m(target, anchor) {
    			insert(target, button0, anchor);
    			insert(target, t2, anchor);
    			insert(target, button1, anchor);

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*click_handler*/ ctx[1]),
    					listen(button1, "click", /*click_handler_1*/ ctx[2])
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(button0);
    			if (detaching) detach(t2);
    			if (detaching) detach(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$9(ctx) {
    	let dropdown;
    	let t;
    	let insertimagedialog;
    	let current;

    	dropdown = new DropDown({
    			props: {
    				buttonLabel: "Insert",
    				buttonIconClassName: "icon plus",
    				buttonClassName: "toolbar-item spaced",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			}
    		});

    	insertimagedialog = new InsertImageDialog({});
    	insertimagedialog.$on("confirm", /*confirm_handler*/ ctx[3]);

    	return {
    		c() {
    			create_component(dropdown.$$.fragment);
    			t = space();
    			create_component(insertimagedialog.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			insert(target, t, anchor);
    			mount_component(insertimagedialog, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const dropdown_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			transition_in(insertimagedialog.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(dropdown.$$.fragment, local);
    			transition_out(insertimagedialog.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(dropdown, detaching);
    			if (detaching) detach(t);
    			destroy_component(insertimagedialog, detaching);
    		}
    	};
    }

    function instance$6($$self) {
    	const editor = getContext('editor');

    	const click_handler = () => {
    		editor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND);
    	};

    	const click_handler_1 = () => {
    		open();
    	};

    	const confirm_handler = payload => {
    		close();
    		editor.dispatchCommand(INSERT_IMAGE_COMMAND, payload.detail);
    	};

    	return [editor, click_handler, click_handler_1, confirm_handler];
    }

    class InsertDropDown extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$6, create_fragment$9, safe_not_equal, {});
    	}
    }

    /* src/components/richtext/ToolbarRichText.svelte generated by Svelte v3.55.1 */

    function create_fragment$8(ctx) {
    	let div;
    	let undobutton;
    	let t0;
    	let redobutton;
    	let t1;
    	let divider0;
    	let t2;
    	let blocktypedropdown;
    	let t3;
    	let divider1;
    	let t4;
    	let fontfamilyselect;
    	let t5;
    	let fontsizeselect;
    	let t6;
    	let divider2;
    	let t7;
    	let boldbutton;
    	let t8;
    	let italicbutton;
    	let t9;
    	let underlinebutton;
    	let t10;
    	let strikethroughbutton;
    	let t11;
    	let formatcodebutton;
    	let t12;
    	let divider3;
    	let t13;
    	let insertdropdown;
    	let t14;
    	let divider4;
    	let t15;
    	let dropdownalign;
    	let t16;
    	let statestorerichtextupdator;
    	let current;
    	undobutton = new UndoButton({});
    	redobutton = new RedoButton({});
    	divider0 = new Divider({});
    	blocktypedropdown = new BlockTypeDropDown({});
    	divider1 = new Divider({});
    	fontfamilyselect = new FontFamilySelect({});
    	fontsizeselect = new FontSizeSelect({});
    	divider2 = new Divider({});
    	boldbutton = new BoldButton({});
    	italicbutton = new ItalicButton({});
    	underlinebutton = new UnderlineButton({});
    	strikethroughbutton = new StrikethroughButton({});
    	formatcodebutton = new FormatCodeButton({});
    	divider3 = new Divider({});
    	insertdropdown = new InsertDropDown({});
    	divider4 = new Divider({});
    	dropdownalign = new DropDownAlign({});
    	statestorerichtextupdator = new StateStoreRichTextUpdator({});

    	return {
    		c() {
    			div = element("div");
    			create_component(undobutton.$$.fragment);
    			t0 = space();
    			create_component(redobutton.$$.fragment);
    			t1 = space();
    			create_component(divider0.$$.fragment);
    			t2 = space();
    			create_component(blocktypedropdown.$$.fragment);
    			t3 = space();
    			create_component(divider1.$$.fragment);
    			t4 = space();
    			create_component(fontfamilyselect.$$.fragment);
    			t5 = space();
    			create_component(fontsizeselect.$$.fragment);
    			t6 = space();
    			create_component(divider2.$$.fragment);
    			t7 = space();
    			create_component(boldbutton.$$.fragment);
    			t8 = space();
    			create_component(italicbutton.$$.fragment);
    			t9 = space();
    			create_component(underlinebutton.$$.fragment);
    			t10 = space();
    			create_component(strikethroughbutton.$$.fragment);
    			t11 = space();
    			create_component(formatcodebutton.$$.fragment);
    			t12 = space();
    			create_component(divider3.$$.fragment);
    			t13 = space();
    			create_component(insertdropdown.$$.fragment);
    			t14 = space();
    			create_component(divider4.$$.fragment);
    			t15 = space();
    			create_component(dropdownalign.$$.fragment);
    			t16 = space();
    			create_component(statestorerichtextupdator.$$.fragment);
    			attr(div, "class", "toolbar");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(undobutton, div, null);
    			append(div, t0);
    			mount_component(redobutton, div, null);
    			append(div, t1);
    			mount_component(divider0, div, null);
    			append(div, t2);
    			mount_component(blocktypedropdown, div, null);
    			append(div, t3);
    			mount_component(divider1, div, null);
    			append(div, t4);
    			mount_component(fontfamilyselect, div, null);
    			append(div, t5);
    			mount_component(fontsizeselect, div, null);
    			append(div, t6);
    			mount_component(divider2, div, null);
    			append(div, t7);
    			mount_component(boldbutton, div, null);
    			append(div, t8);
    			mount_component(italicbutton, div, null);
    			append(div, t9);
    			mount_component(underlinebutton, div, null);
    			append(div, t10);
    			mount_component(strikethroughbutton, div, null);
    			append(div, t11);
    			mount_component(formatcodebutton, div, null);
    			append(div, t12);
    			mount_component(divider3, div, null);
    			append(div, t13);
    			mount_component(insertdropdown, div, null);
    			append(div, t14);
    			mount_component(divider4, div, null);
    			append(div, t15);
    			mount_component(dropdownalign, div, null);
    			insert(target, t16, anchor);
    			mount_component(statestorerichtextupdator, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(undobutton.$$.fragment, local);
    			transition_in(redobutton.$$.fragment, local);
    			transition_in(divider0.$$.fragment, local);
    			transition_in(blocktypedropdown.$$.fragment, local);
    			transition_in(divider1.$$.fragment, local);
    			transition_in(fontfamilyselect.$$.fragment, local);
    			transition_in(fontsizeselect.$$.fragment, local);
    			transition_in(divider2.$$.fragment, local);
    			transition_in(boldbutton.$$.fragment, local);
    			transition_in(italicbutton.$$.fragment, local);
    			transition_in(underlinebutton.$$.fragment, local);
    			transition_in(strikethroughbutton.$$.fragment, local);
    			transition_in(formatcodebutton.$$.fragment, local);
    			transition_in(divider3.$$.fragment, local);
    			transition_in(insertdropdown.$$.fragment, local);
    			transition_in(divider4.$$.fragment, local);
    			transition_in(dropdownalign.$$.fragment, local);
    			transition_in(statestorerichtextupdator.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(undobutton.$$.fragment, local);
    			transition_out(redobutton.$$.fragment, local);
    			transition_out(divider0.$$.fragment, local);
    			transition_out(blocktypedropdown.$$.fragment, local);
    			transition_out(divider1.$$.fragment, local);
    			transition_out(fontfamilyselect.$$.fragment, local);
    			transition_out(fontsizeselect.$$.fragment, local);
    			transition_out(divider2.$$.fragment, local);
    			transition_out(boldbutton.$$.fragment, local);
    			transition_out(italicbutton.$$.fragment, local);
    			transition_out(underlinebutton.$$.fragment, local);
    			transition_out(strikethroughbutton.$$.fragment, local);
    			transition_out(formatcodebutton.$$.fragment, local);
    			transition_out(divider3.$$.fragment, local);
    			transition_out(insertdropdown.$$.fragment, local);
    			transition_out(divider4.$$.fragment, local);
    			transition_out(dropdownalign.$$.fragment, local);
    			transition_out(statestorerichtextupdator.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(undobutton);
    			destroy_component(redobutton);
    			destroy_component(divider0);
    			destroy_component(blocktypedropdown);
    			destroy_component(divider1);
    			destroy_component(fontfamilyselect);
    			destroy_component(fontsizeselect);
    			destroy_component(divider2);
    			destroy_component(boldbutton);
    			destroy_component(italicbutton);
    			destroy_component(underlinebutton);
    			destroy_component(strikethroughbutton);
    			destroy_component(formatcodebutton);
    			destroy_component(divider3);
    			destroy_component(insertdropdown);
    			destroy_component(divider4);
    			destroy_component(dropdownalign);
    			if (detaching) detach(t16);
    			destroy_component(statestorerichtextupdator, detaching);
    		}
    	};
    }

    class ToolbarRichText extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$8, safe_not_equal, {});
    	}
    }

    var LexicalFile_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalFile_dev;

    function requireLexicalFile_dev () {
    	if (hasRequiredLexicalFile_dev) return LexicalFile_dev;
    	hasRequiredLexicalFile_dev = 1;

    	var lexical = Lexical_1;

    	var version = "0.7.6";

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */
    	function importFile(editor) {
    	  readTextFileFromSystem(text => {
    	    const json = JSON.parse(text);
    	    const editorState = editor.parseEditorState(JSON.stringify(json.editorState));
    	    editor.setEditorState(editorState);
    	    editor.dispatchCommand(lexical.CLEAR_HISTORY_COMMAND, undefined);
    	  });
    	}

    	function readTextFileFromSystem(callback) {
    	  const input = document.createElement('input');
    	  input.type = 'file';
    	  input.accept = '.lexical';
    	  input.addEventListener('change', event => {
    	    const target = event.target;

    	    if (target.files) {
    	      const file = target.files[0];
    	      const reader = new FileReader();
    	      reader.readAsText(file, 'UTF-8');

    	      reader.onload = readerEvent => {
    	        if (readerEvent.target) {
    	          const content = readerEvent.target.result;
    	          callback(content);
    	        }
    	      };
    	    }
    	  });
    	  input.click();
    	}

    	function exportFile(editor, config = Object.freeze({})) {
    	  const now = new Date();
    	  const editorState = editor.getEditorState();
    	  const documentJSON = {
    	    editorState: editorState,
    	    lastSaved: now.getTime(),
    	    source: config.source || 'Lexical',
    	    version
    	  };
    	  const fileName = config.fileName || now.toISOString();
    	  exportBlob(documentJSON, `${fileName}.lexical`);
    	} // Adapted from https://stackoverflow.com/a/19328891/2013580

    	function exportBlob(data, fileName) {
    	  const a = document.createElement('a');
    	  const body = document.body;

    	  if (body === null) {
    	    return;
    	  }

    	  body.appendChild(a);
    	  a.style.display = 'none';
    	  const json = JSON.stringify(data);
    	  const blob = new Blob([json], {
    	    type: 'octet/stream'
    	  });
    	  const url = window.URL.createObjectURL(blob);
    	  a.href = url;
    	  a.download = fileName;
    	  a.click();
    	  window.URL.revokeObjectURL(url);
    	  a.remove();
    	}

    	LexicalFile_dev.exportFile = exportFile;
    	LexicalFile_dev.importFile = importFile;
    	return LexicalFile_dev;
    }

    var LexicalFile_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalFile_prod;

    function requireLexicalFile_prod () {
    	if (hasRequiredLexicalFile_prod) return LexicalFile_prod;
    	hasRequiredLexicalFile_prod = 1;
    var f=Lexical_1;function g(a){let c=document.createElement("input");c.type="file";c.accept=".lexical";c.addEventListener("change",b=>{b=b.target;if(b.files){b=b.files[0];let d=new FileReader;d.readAsText(b,"UTF-8");d.onload=e=>{e.target&&a(e.target.result);};}});c.click();}
    	LexicalFile_prod.exportFile=function(a,c=Object.freeze({})){var b=new Date;a={editorState:a.getEditorState(),lastSaved:b.getTime(),source:c.source||"Lexical",version:"0.7.6"};{c=`${c.fileName||b.toISOString()}.lexical`;b=document.createElement("a");let d=document.body;null!==d&&(d.appendChild(b),b.style.display="none",a=JSON.stringify(a),a=new Blob([a],{type:"octet/stream"}),a=window.URL.createObjectURL(a),b.href=a,b.download=c,b.click(),window.URL.revokeObjectURL(a),b.remove());}};
    	LexicalFile_prod.importFile=function(a){g(c=>{c=JSON.parse(c);c=a.parseEditorState(JSON.stringify(c.editorState));a.setEditorState(c);a.dispatchCommand(f.CLEAR_HISTORY_COMMAND,void 0);});};
    	return LexicalFile_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalFile = process.env.NODE_ENV === 'development' ? requireLexicalFile_dev() : requireLexicalFile_prod();
    var LexicalFile_1 = LexicalFile;

    /* src/components/actionbar/ImportButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$7(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="import"></i>`;
    			attr(button, "class", "action-button import");
    			attr(button, "title", "Import");
    			attr(button, "aria-label", "Import editor state from JSON");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$5($$self) {
    	const editor = getContext('editor');
    	const click_handler = () => LexicalFile_1.importFile(editor);
    	return [editor, click_handler];
    }

    class ImportButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
    	}
    }

    /* src/components/actionbar/ExportButton.svelte generated by Svelte v3.55.1 */

    function create_fragment$6(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			button.innerHTML = `<i class="export"></i>`;
    			attr(button, "class", "action-button export");
    			attr(button, "title", "Export");
    			attr(button, "aria-label", "Export editor state to JSON");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    function instance$4($$self) {
    	const editor = getContext('editor');

    	const click_handler = () => LexicalFile_1.exportFile(editor, {
    		fileName: `Playground ${new Date().toISOString()}`,
    		source: 'Playground'
    	});

    	return [editor, click_handler];
    }

    class ExportButton extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$4, create_fragment$6, safe_not_equal, {});
    	}
    }

    /* src/components/actionbar/ActionBar.svelte generated by Svelte v3.55.1 */

    function create_fragment$5(ctx) {
    	let div;
    	let importbutton;
    	let t;
    	let exportbutton;
    	let current;
    	importbutton = new ImportButton({});
    	exportbutton = new ExportButton({});

    	return {
    		c() {
    			div = element("div");
    			create_component(importbutton.$$.fragment);
    			t = space();
    			create_component(exportbutton.$$.fragment);
    			attr(div, "class", "actions");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(importbutton, div, null);
    			append(div, t);
    			mount_component(exportbutton, div, null);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(importbutton.$$.fragment, local);
    			transition_in(exportbutton.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(importbutton.$$.fragment, local);
    			transition_out(exportbutton.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			destroy_component(importbutton);
    			destroy_component(exportbutton);
    		}
    	};
    }

    class ActionBar extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$5, safe_not_equal, {});
    	}
    }

    var LexicalLink_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalLink_dev;

    function requireLexicalLink_dev () {
    	if (hasRequiredLexicalLink_dev) return LexicalLink_dev;
    	hasRequiredLexicalLink_dev = 1;

    	var utils = LexicalUtils_1;
    	var lexical = Lexical_1;

    	/** @module @lexical/link */

    	/** @noInheritDoc */
    	class LinkNode extends lexical.ElementNode {
    	  /** @internal */

    	  /** @internal */

    	  /** @internal */
    	  static getType() {
    	    return 'link';
    	  }

    	  static clone(node) {
    	    return new LinkNode(node.__url, {
    	      rel: node.__rel,
    	      target: node.__target
    	    }, node.__key);
    	  }

    	  constructor(url, attributes = {}, key) {
    	    super(key);
    	    const {
    	      target = null,
    	      rel = null
    	    } = attributes;
    	    this.__url = url;
    	    this.__target = target;
    	    this.__rel = rel;
    	  }

    	  createDOM(config) {
    	    const element = document.createElement('a');
    	    element.href = this.__url;

    	    if (this.__target !== null) {
    	      element.target = this.__target;
    	    }

    	    if (this.__rel !== null) {
    	      element.rel = this.__rel;
    	    }

    	    utils.addClassNamesToElement(element, config.theme.link);
    	    return element;
    	  }

    	  updateDOM(prevNode, anchor, config) {
    	    const url = this.__url;
    	    const target = this.__target;
    	    const rel = this.__rel;

    	    if (url !== prevNode.__url) {
    	      anchor.href = url;
    	    }

    	    if (target !== prevNode.__target) {
    	      if (target) {
    	        anchor.target = target;
    	      } else {
    	        anchor.removeAttribute('target');
    	      }
    	    }

    	    if (rel !== prevNode.__rel) {
    	      if (rel) {
    	        anchor.rel = rel;
    	      } else {
    	        anchor.removeAttribute('rel');
    	      }
    	    }

    	    return false;
    	  }

    	  static importDOM() {
    	    return {
    	      a: node => ({
    	        conversion: convertAnchorElement,
    	        priority: 1
    	      })
    	    };
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createLinkNode(serializedNode.url, {
    	      rel: serializedNode.rel,
    	      target: serializedNode.target
    	    });
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      rel: this.getRel(),
    	      target: this.getTarget(),
    	      type: 'link',
    	      url: this.getURL(),
    	      version: 1
    	    };
    	  }

    	  getURL() {
    	    return this.getLatest().__url;
    	  }

    	  setURL(url) {
    	    const writable = this.getWritable();
    	    writable.__url = url;
    	  }

    	  getTarget() {
    	    return this.getLatest().__target;
    	  }

    	  setTarget(target) {
    	    const writable = this.getWritable();
    	    writable.__target = target;
    	  }

    	  getRel() {
    	    return this.getLatest().__rel;
    	  }

    	  setRel(rel) {
    	    const writable = this.getWritable();
    	    writable.__rel = rel;
    	  }

    	  insertNewAfter(selection, restoreSelection = true) {
    	    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);

    	    if (lexical.$isElementNode(element)) {
    	      const linkNode = $createLinkNode(this.__url, {
    	        rel: this.__rel,
    	        target: this.__target
    	      });
    	      element.append(linkNode);
    	      return linkNode;
    	    }

    	    return null;
    	  }

    	  canInsertTextBefore() {
    	    return false;
    	  }

    	  canInsertTextAfter() {
    	    return false;
    	  }

    	  canBeEmpty() {
    	    return false;
    	  }

    	  isInline() {
    	    return true;
    	  }

    	  extractWithChild(child, selection, destination) {
    	    if (!lexical.$isRangeSelection(selection)) {
    	      return false;
    	    }

    	    const anchorNode = selection.anchor.getNode();
    	    const focusNode = selection.focus.getNode();
    	    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
    	  }

    	}

    	function convertAnchorElement(domNode) {
    	  let node = null;

    	  if (domNode instanceof HTMLAnchorElement) {
    	    const content = domNode.textContent;

    	    if (content !== null && content !== '') {
    	      node = $createLinkNode(domNode.getAttribute('href') || '', {
    	        rel: domNode.getAttribute('rel'),
    	        target: domNode.getAttribute('target')
    	      });
    	    }
    	  }

    	  return {
    	    node
    	  };
    	}

    	function $createLinkNode(url, attributes) {
    	  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));
    	}
    	function $isLinkNode(node) {
    	  return node instanceof LinkNode;
    	}
    	// Custom node type to override `canInsertTextAfter` that will
    	// allow typing within the link
    	class AutoLinkNode extends LinkNode {
    	  static getType() {
    	    return 'autolink';
    	  }

    	  static clone(node) {
    	    return new AutoLinkNode(node.__url, {
    	      rel: node.__rel,
    	      target: node.__target
    	    }, node.__key);
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createAutoLinkNode(serializedNode.url, {
    	      rel: serializedNode.rel,
    	      target: serializedNode.target
    	    });
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  static importDOM() {
    	    // TODO: Should link node should handle the import over autolink?
    	    return null;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      type: 'autolink',
    	      version: 1
    	    };
    	  }

    	  insertNewAfter(selection, restoreSelection = true) {
    	    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);

    	    if (lexical.$isElementNode(element)) {
    	      const linkNode = $createAutoLinkNode(this.__url, {
    	        rel: this._rel,
    	        target: this.__target
    	      });
    	      element.append(linkNode);
    	      return linkNode;
    	    }

    	    return null;
    	  }

    	}
    	function $createAutoLinkNode(url, attributes) {
    	  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));
    	}
    	function $isAutoLinkNode(node) {
    	  return node instanceof AutoLinkNode;
    	}
    	const TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');
    	function toggleLink(url, attributes = {}) {
    	  const {
    	    target
    	  } = attributes;
    	  const rel = attributes.rel === undefined ? 'noopener' : attributes.rel;
    	  const selection = lexical.$getSelection();

    	  if (!lexical.$isRangeSelection(selection)) {
    	    return;
    	  }

    	  const nodes = selection.extract();

    	  if (url === null) {
    	    // Remove LinkNodes
    	    nodes.forEach(node => {
    	      const parent = node.getParent();

    	      if ($isLinkNode(parent)) {
    	        const children = parent.getChildren();

    	        for (let i = 0; i < children.length; i++) {
    	          parent.insertBefore(children[i]);
    	        }

    	        parent.remove();
    	      }
    	    });
    	  } else {
    	    // Add or merge LinkNodes
    	    if (nodes.length === 1) {
    	      const firstNode = nodes[0]; // if the first node is a LinkNode or if its
    	      // parent is a LinkNode, we update the URL, target and rel.

    	      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);

    	      if (linkNode !== null) {
    	        linkNode.setURL(url);

    	        if (target !== undefined) {
    	          linkNode.setTarget(target);
    	        }

    	        if (rel !== null) {
    	          linkNode.setRel(rel);
    	        }

    	        return;
    	      }
    	    }

    	    let prevParent = null;
    	    let linkNode = null;
    	    nodes.forEach(node => {
    	      const parent = node.getParent();

    	      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {
    	        return;
    	      }

    	      if ($isLinkNode(parent)) {
    	        linkNode = parent;
    	        parent.setURL(url);

    	        if (target !== undefined) {
    	          parent.setTarget(target);
    	        }

    	        if (rel !== null) {
    	          linkNode.setRel(rel);
    	        }

    	        return;
    	      }

    	      if (!parent.is(prevParent)) {
    	        prevParent = parent;
    	        linkNode = $createLinkNode(url, {
    	          rel,
    	          target
    	        });

    	        if ($isLinkNode(parent)) {
    	          if (node.getPreviousSibling() === null) {
    	            parent.insertBefore(linkNode);
    	          } else {
    	            parent.insertAfter(linkNode);
    	          }
    	        } else {
    	          node.insertBefore(linkNode);
    	        }
    	      }

    	      if ($isLinkNode(node)) {
    	        if (node.is(linkNode)) {
    	          return;
    	        }

    	        if (linkNode !== null) {
    	          const children = node.getChildren();

    	          for (let i = 0; i < children.length; i++) {
    	            linkNode.append(children[i]);
    	          }
    	        }

    	        node.remove();
    	        return;
    	      }

    	      if (linkNode !== null) {
    	        linkNode.append(node);
    	      }
    	    });
    	  }
    	}

    	function $getLinkAncestor(node) {
    	  return $getAncestor(node, ancestor => $isLinkNode(ancestor));
    	}

    	function $getAncestor(node, predicate) {
    	  let parent = node;

    	  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));

    	  return parent;
    	}

    	LexicalLink_dev.$createAutoLinkNode = $createAutoLinkNode;
    	LexicalLink_dev.$createLinkNode = $createLinkNode;
    	LexicalLink_dev.$isAutoLinkNode = $isAutoLinkNode;
    	LexicalLink_dev.$isLinkNode = $isLinkNode;
    	LexicalLink_dev.AutoLinkNode = AutoLinkNode;
    	LexicalLink_dev.LinkNode = LinkNode;
    	LexicalLink_dev.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;
    	LexicalLink_dev.toggleLink = toggleLink;
    	return LexicalLink_dev;
    }

    var LexicalLink_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalLink_prod;

    function requireLexicalLink_prod () {
    	if (hasRequiredLexicalLink_prod) return LexicalLink_prod;
    	hasRequiredLexicalLink_prod = 1;
    var k=LexicalUtils_1,m=Lexical_1;
    	class n extends m.ElementNode{static getType(){return "link"}static clone(a){return new n(a.__url,{rel:a.__rel,target:a.__target},a.__key)}constructor(a,b={},c){super(c);let {target:h=null,rel:e=null}=b;this.__url=a;this.__target=h;this.__rel=e;}createDOM(a){let b=document.createElement("a");b.href=this.__url;null!==this.__target&&(b.target=this.__target);null!==this.__rel&&(b.rel=this.__rel);k.addClassNamesToElement(b,a.theme.link);return b}updateDOM(a,b){let c=this.__url,h=this.__target,e=this.__rel;
    	c!==a.__url&&(b.href=c);h!==a.__target&&(h?b.target=h:b.removeAttribute("target"));e!==a.__rel&&(e?b.rel=e:b.removeAttribute("rel"));return !1}static importDOM(){return {a:()=>({conversion:p,priority:1})}}static importJSON(a){let b=q(a.url,{rel:a.rel,target:a.target});b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {...super.exportJSON(),rel:this.getRel(),target:this.getTarget(),type:"link",url:this.getURL(),version:1}}getURL(){return this.getLatest().__url}setURL(a){this.getWritable().__url=
    	a;}getTarget(){return this.getLatest().__target}setTarget(a){this.getWritable().__target=a;}getRel(){return this.getLatest().__rel}setRel(a){this.getWritable().__rel=a;}insertNewAfter(a,b=!0){a=this.getParentOrThrow().insertNewAfter(a,b);return m.$isElementNode(a)?(b=q(this.__url,{rel:this.__rel,target:this.__target}),a.append(b),b):null}canInsertTextBefore(){return !1}canInsertTextAfter(){return !1}canBeEmpty(){return !1}isInline(){return !0}extractWithChild(a,b){if(!m.$isRangeSelection(b))return !1;a=b.anchor.getNode();
    	let c=b.focus.getNode();return this.isParentOf(a)&&this.isParentOf(c)&&0<b.getTextContent().length}}function p(a){let b=null;if(a instanceof HTMLAnchorElement){let c=a.textContent;null!==c&&""!==c&&(b=q(a.getAttribute("href")||"",{rel:a.getAttribute("rel"),target:a.getAttribute("target")}));}return {node:b}}function q(a,b){return m.$applyNodeReplacement(new n(a,b))}function r(a){return a instanceof n}
    	class u extends n{static getType(){return "autolink"}static clone(a){return new u(a.__url,{rel:a.__rel,target:a.__target},a.__key)}static importJSON(a){let b=v(a.url,{rel:a.rel,target:a.target});b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}static importDOM(){return null}exportJSON(){return {...super.exportJSON(),type:"autolink",version:1}}insertNewAfter(a,b=!0){a=this.getParentOrThrow().insertNewAfter(a,b);return m.$isElementNode(a)?(b=v(this.__url,{rel:this._rel,
    	target:this.__target}),a.append(b),b):null}}function v(a,b){return m.$applyNodeReplacement(new u(a,b))}let w=m.createCommand("TOGGLE_LINK_COMMAND");function x(a){return y(a,b=>r(b))}function y(a,b){for(;null!==a&&null!==(a=a.getParent())&&!b(a););return a}LexicalLink_prod.$createAutoLinkNode=v;LexicalLink_prod.$createLinkNode=q;LexicalLink_prod.$isAutoLinkNode=function(a){return a instanceof u};LexicalLink_prod.$isLinkNode=r;LexicalLink_prod.AutoLinkNode=u;LexicalLink_prod.LinkNode=n;LexicalLink_prod.TOGGLE_LINK_COMMAND=w;
    	LexicalLink_prod.toggleLink=function(a,b={}){let {target:c}=b,h=void 0===b.rel?"noopener":b.rel;b=m.$getSelection();if(m.$isRangeSelection(b))if(b=b.extract(),null===a)b.forEach(l=>{l=l.getParent();if(r(l)){let d=l.getChildren();for(let f=0;f<d.length;f++)l.insertBefore(d[f]);l.remove();}});else {if(1===b.length){var e=b[0];e=r(e)?e:x(e);if(null!==e){e.setURL(a);void 0!==c&&e.setTarget(c);null!==h&&e.setRel(h);return}}let l=null,d=null;b.forEach(f=>{var g=f.getParent();if(g!==d&&null!==g&&(!m.$isElementNode(f)||
    	f.isInline()))if(r(g))d=g,g.setURL(a),void 0!==c&&g.setTarget(c),null!==h&&d.setRel(h);else if(g.is(l)||(l=g,d=q(a,{rel:h,target:c}),r(g)?null===f.getPreviousSibling()?g.insertBefore(d):g.insertAfter(d):f.insertBefore(d)),r(f)){if(!f.is(d)){if(null!==d){g=f.getChildren();for(let t=0;t<g.length;t++)d.append(g[t]);}f.remove();}}else null!==d&&d.append(f);});}};
    	return LexicalLink_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalLink = process.env.NODE_ENV === 'development' ? requireLexicalLink_dev() : requireLexicalLink_prod();
    var LexicalLink_1 = LexicalLink;

    var LexicalMark_dev = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalMark_dev;

    function requireLexicalMark_dev () {
    	if (hasRequiredLexicalMark_dev) return LexicalMark_dev;
    	hasRequiredLexicalMark_dev = 1;

    	var lexical = Lexical_1;
    	var utils = LexicalUtils_1;

    	/**
    	 * Copyright (c) Meta Platforms, Inc. and affiliates.
    	 *
    	 * This source code is licensed under the MIT license found in the
    	 * LICENSE file in the root directory of this source tree.
    	 *
    	 */

    	/** @noInheritDoc */
    	class MarkNode extends lexical.ElementNode {
    	  /** @internal */
    	  static getType() {
    	    return 'mark';
    	  }

    	  static clone(node) {
    	    return new MarkNode(Array.from(node.__ids), node.__key);
    	  }

    	  static importDOM() {
    	    return null;
    	  }

    	  static importJSON(serializedNode) {
    	    const node = $createMarkNode(serializedNode.ids);
    	    node.setFormat(serializedNode.format);
    	    node.setIndent(serializedNode.indent);
    	    node.setDirection(serializedNode.direction);
    	    return node;
    	  }

    	  exportJSON() {
    	    return { ...super.exportJSON(),
    	      ids: this.getIDs(),
    	      type: 'mark',
    	      version: 1
    	    };
    	  }

    	  constructor(ids, key) {
    	    super(key);
    	    this.__ids = ids || [];
    	  }

    	  createDOM(config) {
    	    const element = document.createElement('mark');
    	    utils.addClassNamesToElement(element, config.theme.mark);

    	    if (this.__ids.length > 1) {
    	      utils.addClassNamesToElement(element, config.theme.markOverlap);
    	    }

    	    return element;
    	  }

    	  updateDOM(prevNode, element, config) {
    	    const prevIDs = prevNode.__ids;
    	    const nextIDs = this.__ids;
    	    const prevIDsCount = prevIDs.length;
    	    const nextIDsCount = nextIDs.length;
    	    const overlapTheme = config.theme.markOverlap;

    	    if (prevIDsCount !== nextIDsCount) {
    	      if (prevIDsCount === 1) {
    	        if (nextIDsCount === 2) {
    	          utils.addClassNamesToElement(element, overlapTheme);
    	        }
    	      } else if (nextIDsCount === 1) {
    	        utils.removeClassNamesFromElement(element, overlapTheme);
    	      }
    	    }

    	    return false;
    	  }

    	  hasID(id) {
    	    const ids = this.getIDs();

    	    for (let i = 0; i < ids.length; i++) {
    	      if (id === ids[i]) {
    	        return true;
    	      }
    	    }

    	    return false;
    	  }

    	  getIDs() {
    	    const self = this.getLatest();
    	    return $isMarkNode(self) ? self.__ids : [];
    	  }

    	  addID(id) {
    	    const self = this.getWritable();

    	    if ($isMarkNode(self)) {
    	      const ids = self.__ids;
    	      self.__ids = ids;

    	      for (let i = 0; i < ids.length; i++) {
    	        // If we already have it, don't add again
    	        if (id === ids[i]) return;
    	      }

    	      ids.push(id);
    	    }
    	  }

    	  deleteID(id) {
    	    const self = this.getWritable();

    	    if ($isMarkNode(self)) {
    	      const ids = self.__ids;
    	      self.__ids = ids;

    	      for (let i = 0; i < ids.length; i++) {
    	        if (id === ids[i]) {
    	          ids.splice(i, 1);
    	          return;
    	        }
    	      }
    	    }
    	  }

    	  insertNewAfter(selection, restoreSelection = true) {
    	    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);

    	    if (lexical.$isElementNode(element)) {
    	      const markNode = $createMarkNode(this.__ids);
    	      element.append(markNode);
    	      return markNode;
    	    }

    	    return null;
    	  }

    	  canInsertTextBefore() {
    	    return false;
    	  }

    	  canInsertTextAfter() {
    	    return false;
    	  }

    	  canBeEmpty() {
    	    return false;
    	  }

    	  isInline() {
    	    return true;
    	  }

    	  extractWithChild(child, selection, destination) {
    	    if (!lexical.$isRangeSelection(selection) || destination === 'html') {
    	      return false;
    	    }

    	    const anchor = selection.anchor;
    	    const focus = selection.focus;
    	    const anchorNode = anchor.getNode();
    	    const focusNode = focus.getNode();
    	    const isBackward = selection.isBackward();
    	    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;
    	    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;
    	  }

    	  excludeFromCopy(destination) {
    	    return destination !== 'clone';
    	  }

    	}
    	function $createMarkNode(ids) {
    	  return lexical.$applyNodeReplacement(new MarkNode(ids));
    	}
    	function $isMarkNode(node) {
    	  return node instanceof MarkNode;
    	}

    	/** @module @lexical/mark */
    	function $unwrapMarkNode(node) {
    	  const children = node.getChildren();
    	  let target = null;

    	  for (let i = 0; i < children.length; i++) {
    	    const child = children[i];

    	    if (target === null) {
    	      node.insertBefore(child);
    	    } else {
    	      target.insertAfter(child);
    	    }

    	    target = child;
    	  }

    	  node.remove();
    	}
    	function $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {
    	  const nodes = selection.getNodes();
    	  const anchorOffset = selection.anchor.offset;
    	  const focusOffset = selection.focus.offset;
    	  const nodesLength = nodes.length;
    	  const startOffset = isBackward ? focusOffset : anchorOffset;
    	  const endOffset = isBackward ? anchorOffset : focusOffset;
    	  let currentNodeParent;
    	  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes
    	  // and inline element nodes. For decorator nodes and block
    	  // element nodes, we step out of their boundary and start
    	  // again after, if there are more nodes.

    	  for (let i = 0; i < nodesLength; i++) {
    	    const node = nodes[i];

    	    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {
    	      // If the current node is a child of the last created mark node, there is nothing to do here
    	      continue;
    	    }

    	    const isFirstNode = i === 0;
    	    const isLastNode = i === nodesLength - 1;
    	    let targetNode = null;

    	    if (lexical.$isTextNode(node)) {
    	      // Case 1: The node is a text node and we can split it
    	      const textContentSize = node.getTextContentSize();
    	      const startTextOffset = isFirstNode ? startOffset : 0;
    	      const endTextOffset = isLastNode ? endOffset : textContentSize;

    	      if (startTextOffset === 0 && endTextOffset === 0) {
    	        continue;
    	      }

    	      const splitNodes = node.splitText(startTextOffset, endTextOffset);
    	      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];
    	    } else if ($isMarkNode(node)) {
    	      // Case 2: the node is a mark node and we can ignore it as a target,
    	      // moving on to its children. Note that when we make a mark inside
    	      // another mark, it may utlimately be unnested by a call to
    	      // `registerNestedElementResolver<MarkNode>` somewhere else in the
    	      // codebase.
    	      continue;
    	    } else if (lexical.$isElementNode(node) && node.isInline()) {
    	      // Case 3: inline element nodes can be added in their entirety to the new
    	      // mark
    	      targetNode = node;
    	    }

    	    if (targetNode !== null) {
    	      // Now that we have a target node for wrapping with a mark, we can run
    	      // through special cases.
    	      if (targetNode && targetNode.is(currentNodeParent)) {
    	        // The current node is a child of the target node to be wrapped, there
    	        // is nothing to do here.
    	        continue;
    	      }

    	      const parentNode = targetNode.getParent();

    	      if (parentNode == null || !parentNode.is(currentNodeParent)) {
    	        // If the parent node is not the current node's parent node, we can
    	        // clear the last created mark node.
    	        lastCreatedMarkNode = undefined;
    	      }

    	      currentNodeParent = parentNode;

    	      if (lastCreatedMarkNode === undefined) {
    	        // If we don't have a created mark node, we can make one
    	        const createMarkNode = createNode || $createMarkNode;
    	        lastCreatedMarkNode = createMarkNode([id]);
    	        targetNode.insertBefore(lastCreatedMarkNode);
    	      } // Add the target node to be wrapped in the latest created mark node


    	      lastCreatedMarkNode.append(targetNode);
    	    } else {
    	      // If we don't have a target node to wrap we can clear our state and
    	      // continue on with the next node
    	      currentNodeParent = undefined;
    	      lastCreatedMarkNode = undefined;
    	    }
    	  }
    	}
    	function $getMarkIDs(node, offset) {
    	  let currentNode = node;

    	  while (currentNode !== null) {
    	    if ($isMarkNode(currentNode)) {
    	      return currentNode.getIDs();
    	    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {
    	      const nextSibling = currentNode.getNextSibling();

    	      if ($isMarkNode(nextSibling)) {
    	        return nextSibling.getIDs();
    	      }
    	    }

    	    currentNode = currentNode.getParent();
    	  }

    	  return null;
    	}

    	LexicalMark_dev.$createMarkNode = $createMarkNode;
    	LexicalMark_dev.$getMarkIDs = $getMarkIDs;
    	LexicalMark_dev.$isMarkNode = $isMarkNode;
    	LexicalMark_dev.$unwrapMarkNode = $unwrapMarkNode;
    	LexicalMark_dev.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;
    	LexicalMark_dev.MarkNode = MarkNode;
    	return LexicalMark_dev;
    }

    var LexicalMark_prod = {};

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredLexicalMark_prod;

    function requireLexicalMark_prod () {
    	if (hasRequiredLexicalMark_prod) return LexicalMark_prod;
    	hasRequiredLexicalMark_prod = 1;
    var k=Lexical_1,n=LexicalUtils_1;
    	class p extends k.ElementNode{static getType(){return "mark"}static clone(a){return new p(Array.from(a.__ids),a.__key)}static importDOM(){return null}static importJSON(a){let b=q(a.ids);b.setFormat(a.format);b.setIndent(a.indent);b.setDirection(a.direction);return b}exportJSON(){return {...super.exportJSON(),ids:this.getIDs(),type:"mark",version:1}}constructor(a,b){super(b);this.__ids=a||[];}createDOM(a){let b=document.createElement("mark");n.addClassNamesToElement(b,a.theme.mark);1<this.__ids.length&&
    	n.addClassNamesToElement(b,a.theme.markOverlap);return b}updateDOM(a,b,c){a=a.__ids.length;let d=this.__ids.length;c=c.theme.markOverlap;a!==d&&(1===a?2===d&&n.addClassNamesToElement(b,c):1===d&&n.removeClassNamesFromElement(b,c));return !1}hasID(a){let b=this.getIDs();for(let c=0;c<b.length;c++)if(a===b[c])return !0;return !1}getIDs(){let a=this.getLatest();return r(a)?a.__ids:[]}addID(a){var b=this.getWritable();if(r(b)){let c=b.__ids;b.__ids=c;for(b=0;b<c.length;b++)if(a===c[b])return;c.push(a);}}deleteID(a){var b=
    	this.getWritable();if(r(b)){let c=b.__ids;b.__ids=c;for(b=0;b<c.length;b++)if(a===c[b]){c.splice(b,1);break}}}insertNewAfter(a,b=!0){a=this.getParentOrThrow().insertNewAfter(a,b);return k.$isElementNode(a)?(b=q(this.__ids),a.append(b),b):null}canInsertTextBefore(){return !1}canInsertTextAfter(){return !1}canBeEmpty(){return !1}isInline(){return !0}extractWithChild(a,b,c){if(!k.$isRangeSelection(b)||"html"===c)return !1;let d=b.anchor,g=b.focus;a=d.getNode();c=g.getNode();b=b.isBackward()?d.offset-g.offset:
    	g.offset-d.offset;return this.isParentOf(a)&&this.isParentOf(c)&&this.getTextContent().length===b}excludeFromCopy(a){return "clone"!==a}}function q(a){return k.$applyNodeReplacement(new p(a))}function r(a){return a instanceof p}LexicalMark_prod.$createMarkNode=q;LexicalMark_prod.$getMarkIDs=function(a,b){for(;null!==a;){if(r(a))return a.getIDs();if(k.$isTextNode(a)&&b===a.getTextContentSize()){let c=a.getNextSibling();if(r(c))return c.getIDs()}a=a.getParent();}return null};LexicalMark_prod.$isMarkNode=r;
    	LexicalMark_prod.$unwrapMarkNode=function(a){let b=a.getChildren(),c=null;for(let d=0;d<b.length;d++){let g=b[d];null===c?a.insertBefore(g):c.insertAfter(g);c=g;}a.remove();};
    	LexicalMark_prod.$wrapSelectionInMarkNode=function(a,b,c,d){let g=a.getNodes();var l=a.anchor.offset,h=a.focus.offset;a=g.length;let x=b?h:l;b=b?l:h;let t,m;for(l=0;l<a;l++){var e=g[l];if(k.$isElementNode(m)&&m.isParentOf(e))continue;h=0===l;let v=l===a-1;var f=null;if(k.$isTextNode(e)){f=e.getTextContentSize();let w=h?x:0,u=v?b:f;if(0===w&&0===u)continue;e=e.splitText(w,u);f=1<e.length&&(3===e.length||h&&!v||u===f)?e[1]:e[0];}else if(r(e))continue;else k.$isElementNode(e)&&e.isInline()&&(f=e);null!==f?f&&
    	f.is(t)||(h=f.getParent(),null!=h&&h.is(t)||(m=void 0),t=h,void 0===m&&(m=(d||q)([c]),f.insertBefore(m)),m.append(f)):m=t=void 0;}};LexicalMark_prod.MarkNode=p;
    	return LexicalMark_prod;
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    const LexicalMark = process.env.NODE_ENV === 'development' ? requireLexicalMark_dev() : requireLexicalMark_prod();
    var LexicalMark_1 = LexicalMark;

    /* src/core/plugins/TreeView.svelte generated by Svelte v3.55.1 */

    function create_if_block_3(ctx) {
    	let div;
    	let span;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "Detected large EditorState, this can impact debugging performance.";
    			t1 = space();
    			button = element("button");
    			button.textContent = "Show full tree";
    			set_style(span, "marginRight", "20");
    			set_style(button, "background", "transparent");
    			set_style(button, "border", "1px solid white");
    			set_style(button, "color", "white");
    			set_style(button, "cursor", "pointer");
    			set_style(button, "padding", "5px");
    			set_style(div, "padding", "20px");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span);
    			append(div, t1);
    			append(div, button);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler*/ ctx[19]);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (385:2) {#if !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2}
    function create_if_block_2(ctx) {
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			button = element("button");
    			t = text("Time Travel");
    			attr(button, "class", /*timeTravelButtonClassName*/ ctx[0]);
    			attr(button, "type", "button");
    		},
    		m(target, anchor) {
    			insert(target, button, anchor);
    			append(button, t);

    			if (!mounted) {
    				dispose = listen(button, "click", /*click_handler_1*/ ctx[20]);
    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*timeTravelButtonClassName*/ 1) {
    				attr(button, "class", /*timeTravelButtonClassName*/ ctx[0]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(button);
    			mounted = false;
    			dispose();
    		}
    	};
    }

    // (401:2) {#if showLimited || !isLimited}
    function create_if_block_1(ctx) {
    	let pre;
    	let t;

    	return {
    		c() {
    			pre = element("pre");
    			t = text(/*content*/ ctx[8]);
    		},
    		m(target, anchor) {
    			insert(target, pre, anchor);
    			append(pre, t);
    			/*pre_binding*/ ctx[21](pre);
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*content*/ 256) set_data(t, /*content*/ ctx[8]);
    		},
    		d(detaching) {
    			if (detaching) detach(pre);
    			/*pre_binding*/ ctx[21](null);
    		}
    	};
    }

    // (404:2) {#if timeTravelEnabled && (showLimited || !isLimited)}
    function create_if_block(ctx) {
    	let div;
    	let button0;
    	let t0_value = (/*isPlaying*/ ctx[6] ? 'Pause' : 'Play') + "";
    	let t0;
    	let t1;
    	let input_1;
    	let input_1_max_value;
    	let t2;
    	let button1;
    	let t3;
    	let mounted;
    	let dispose;

    	return {
    		c() {
    			div = element("div");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			input_1 = element("input");
    			t2 = space();
    			button1 = element("button");
    			t3 = text("Exit");
    			attr(button0, "class", /*timeTravelPanelButtonClassName*/ ctx[1]);
    			attr(button0, "type", "button");
    			attr(input_1, "class", /*timeTravelPanelSliderClassName*/ ctx[3]);
    			attr(input_1, "type", "range");
    			attr(input_1, "min", "1");
    			attr(input_1, "max", input_1_max_value = /*totalEditorStates*/ ctx[15] - 1);
    			attr(button1, "class", /*timeTravelPanelButtonClassName*/ ctx[1]);
    			attr(button1, "type", "button");
    			attr(div, "class", /*timeTravelPanelClassName*/ ctx[2]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			append(div, button0);
    			append(button0, t0);
    			append(div, t1);
    			append(div, input_1);
    			/*input_1_binding*/ ctx[23](input_1);
    			append(div, t2);
    			append(div, button1);
    			append(button1, t3);

    			if (!mounted) {
    				dispose = [
    					listen(button0, "click", /*click_handler_2*/ ctx[22]),
    					listen(input_1, "change", /*change_handler*/ ctx[24]),
    					listen(button1, "click", /*click_handler_3*/ ctx[25])
    				];

    				mounted = true;
    			}
    		},
    		p(ctx, dirty) {
    			if (dirty[0] & /*isPlaying*/ 64 && t0_value !== (t0_value = (/*isPlaying*/ ctx[6] ? 'Pause' : 'Play') + "")) set_data(t0, t0_value);

    			if (dirty[0] & /*timeTravelPanelButtonClassName*/ 2) {
    				attr(button0, "class", /*timeTravelPanelButtonClassName*/ ctx[1]);
    			}

    			if (dirty[0] & /*timeTravelPanelSliderClassName*/ 8) {
    				attr(input_1, "class", /*timeTravelPanelSliderClassName*/ ctx[3]);
    			}

    			if (dirty[0] & /*totalEditorStates*/ 32768 && input_1_max_value !== (input_1_max_value = /*totalEditorStates*/ ctx[15] - 1)) {
    				attr(input_1, "max", input_1_max_value);
    			}

    			if (dirty[0] & /*timeTravelPanelButtonClassName*/ 2) {
    				attr(button1, "class", /*timeTravelPanelButtonClassName*/ ctx[1]);
    			}

    			if (dirty[0] & /*timeTravelPanelClassName*/ 4) {
    				attr(div, "class", /*timeTravelPanelClassName*/ ctx[2]);
    			}
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			/*input_1_binding*/ ctx[23](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$4(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let if_block0 = !/*showLimited*/ ctx[7] && /*isLimited*/ ctx[13] && create_if_block_3(ctx);
    	let if_block1 = !/*timeTravelEnabled*/ ctx[9] && (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13]) && /*totalEditorStates*/ ctx[15] > 2 && create_if_block_2(ctx);
    	let if_block2 = (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13]) && create_if_block_1(ctx);
    	let if_block3 = /*timeTravelEnabled*/ ctx[9] && (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13]) && create_if_block(ctx);

    	return {
    		c() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			attr(div, "class", /*viewClassName*/ ctx[4]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append(div, t2);
    			if (if_block3) if_block3.m(div, null);
    		},
    		p(ctx, dirty) {
    			if (!/*showLimited*/ ctx[7] && /*isLimited*/ ctx[13]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*timeTravelEnabled*/ ctx[9] && (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13]) && /*totalEditorStates*/ ctx[15] > 2) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1(ctx);
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*timeTravelEnabled*/ ctx[9] && (/*showLimited*/ ctx[7] || !/*isLimited*/ ctx[13])) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block(ctx);
    					if_block3.c();
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty[0] & /*viewClassName*/ 16) {
    				attr(div, "class", /*viewClassName*/ ctx[4]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};
    }

    function printObjectSelection(selection) {
    	return `: node\n  └ [${Array.from(selection._nodes).join(', ')}]`;
    }

    function printGridSelection(selection) {
    	return `: grid\n  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;
    }

    function printAllLinkNodeProperties(node) {
    	return [printTargetProperties(node), printRelProperties(node)].filter(Boolean).join(', ');
    }

    function printTargetProperties(node) {
    	let str = node.getTarget();

    	// TODO Fix nullish on LinkNode
    	if (str != null) {
    		str = 'target: ' + str;
    	}

    	return str;
    }

    function printRelProperties(node) {
    	let str = node.getRel();

    	// TODO Fix nullish on LinkNode
    	if (str != null) {
    		str = 'rel: ' + str;
    	}

    	return str;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let totalEditorStates;
    	const NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({ '\t': '\\t', '\n': '\\n' });
    	const NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');

    	const SYMBOLS = Object.freeze({
    		ancestorHasNextSibling: '|',
    		ancestorIsLastChild: ' ',
    		hasNextSibling: '├',
    		isLastChild: '└',
    		selectedChar: '^',
    		selectedLine: '>'
    	});

    	let { timeTravelButtonClassName } = $$props;
    	let { timeTravelPanelButtonClassName } = $$props;
    	let { timeTravelPanelClassName } = $$props;
    	let { timeTravelPanelSliderClassName } = $$props;
    	let { viewClassName } = $$props;
    	const editor = getContext('editor');
    	let timeStampedEditorStates = [];
    	let content = '';
    	let timeTravelEnabled = false;
    	let playingIndexRef = 0;
    	let treeElementRef = null;
    	let inputRef = null;
    	let isPlaying = false;
    	let isLimited = false;
    	let showLimited = false;
    	let lastEditorStateRef = null;

    	function generateTree(editorState) {
    		const treeText = generateContent(editor.getEditorState(), editor._config, editor._compositionKey, editor._editable);
    		$$invalidate(8, content = treeText);

    		if (!timeTravelEnabled) {
    			$$invalidate(5, timeStampedEditorStates = [...timeStampedEditorStates, [Date.now(), editorState]]);
    		}
    	}

    	let timeoutId;

    	function play() {
    		const currentIndex = playingIndexRef;

    		if (currentIndex === totalEditorStates - 1) {
    			$$invalidate(6, isPlaying = false);
    			return;
    		}

    		const currentTime = timeStampedEditorStates[currentIndex][0];
    		const nextTime = timeStampedEditorStates[currentIndex + 1][0];
    		const timeDiff = nextTime - currentTime;

    		$$invalidate(18, timeoutId = setTimeout(
    			() => {
    				$$invalidate(10, playingIndexRef++, playingIndexRef);
    				const index = playingIndexRef;
    				const input = inputRef;

    				if (input !== null) {
    					input.value = String(index);
    				}

    				editor.setEditorState(timeStampedEditorStates[index][1]);
    				play();
    			},
    			timeDiff
    		));
    	}

    	onMount(() => {
    		const element = treeElementRef;

    		if (element !== null) {
    			// @ts-ignore Internal field
    			element.__lexicalEditor = editor;
    		}

    		return LexicalUtils_1.mergeRegister(
    			// @ts-ignore Internal field
    			() => $$invalidate(11, treeElementRef.__lexicalEditor = null, treeElementRef),
    			editor.registerUpdateListener(({ editorState }) => {
    				if (!showLimited && editorState._nodeMap.size > 1000) {
    					$$invalidate(14, lastEditorStateRef = editorState);
    					$$invalidate(13, isLimited = true);

    					if (!showLimited) {
    						return;
    					}
    				}

    				generateTree(editorState);
    			}),
    			editor.registerEditableListener(() => {
    				const treeText = generateContent(editor.getEditorState(), editor._config, editor._compositionKey, editor._editable);
    				$$invalidate(8, content = treeText);
    			})
    		);
    	});

    	function printRangeSelection(selection) {
    		let res = '';
    		const formatText = printFormatProperties(selection);
    		res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''}`;
    		const anchor = selection.anchor;
    		const focus = selection.focus;
    		const anchorOffset = anchor.offset;
    		const focusOffset = focus.offset;
    		res += `\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;
    		res += `\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;
    		return res;
    	}

    	function generateContent(editorState, editorConfig, compositionKey, editable) {
    		let res = ' root\n';

    		const selectionString = editorState.read(() => {
    			const selection = Lexical_1.$getSelection();

    			visitTree(Lexical_1.$getRoot(), (node, indent) => {
    				const nodeKey = node.getKey();
    				const nodeKeyDisplay = `(${nodeKey})`;
    				const typeDisplay = node.getType() || '';
    				const isSelected = node.isSelected();

    				const idsDisplay = LexicalMark_1.$isMarkNode(node)
    				? ` id: [ ${node.getIDs().join(', ')} ] `
    				: '';

    				res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\n`;

    				res += printSelectedCharsLine({
    					indent,
    					isSelected,
    					node,
    					nodeKeyDisplay,
    					selection,
    					typeDisplay
    				});
    			});

    			return selection === null
    			? ': null'
    			: Lexical_1.$isRangeSelection(selection)
    				? printRangeSelection(selection)
    				: Lexical_1.DEPRECATED_$isGridSelection(selection)
    					? printGridSelection(selection)
    					: printObjectSelection(selection);
    		});

    		res += '\n selection' + selectionString;
    		res += '\n\n editor:';
    		res += `\n  └ namespace ${editorConfig.namespace}`;

    		if (compositionKey !== null) {
    			res += `\n  └ compositionKey ${compositionKey}`;
    		}

    		res += `\n  └ editable ${String(editable)}`;
    		return res;
    	}

    	function visitTree(currentNode, visitor, indent = []) {
    		const childNodes = currentNode.getChildren();
    		const childNodesLength = childNodes.length;

    		childNodes.forEach((childNode, i) => {
    			visitor(childNode, indent.concat(i === childNodesLength - 1
    			? SYMBOLS.isLastChild
    			: SYMBOLS.hasNextSibling));

    			if (Lexical_1.$isElementNode(childNode)) {
    				visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1
    				? SYMBOLS.ancestorIsLastChild
    				: SYMBOLS.ancestorHasNextSibling));
    			}
    		});
    	}

    	function normalize(text) {
    		return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);
    	}

    	// TODO Pass via props to allow customizability
    	function printNode(node) {
    		if (Lexical_1.$isTextNode(node)) {
    			const text = node.getTextContent();
    			const title = text.length === 0 ? '(empty)' : `"${normalize(text)}"`;
    			const properties = printAllTextNodeProperties(node);
    			return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();
    		} else if (LexicalLink_1.$isLinkNode(node)) {
    			const link = node.getURL();
    			const title = link.length === 0 ? '(empty)' : `"${normalize(link)}"`;
    			const properties = printAllLinkNodeProperties(node);
    			return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();
    		} else {
    			return '';
    		}
    	}

    	const FORMAT_PREDICATES = [
    		node => node.hasFormat('bold') && 'Bold',
    		node => node.hasFormat('code') && 'Code',
    		node => node.hasFormat('italic') && 'Italic',
    		node => node.hasFormat('strikethrough') && 'Strikethrough',
    		node => node.hasFormat('subscript') && 'Subscript',
    		node => node.hasFormat('superscript') && 'Superscript',
    		node => node.hasFormat('underline') && 'Underline'
    	];

    	const DETAIL_PREDICATES = [
    		node => node.isDirectionless() && 'Directionless',
    		node => node.isUnmergeable() && 'Unmergeable'
    	];

    	const MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];

    	function printAllTextNodeProperties(node) {
    		return [
    			printFormatProperties(node),
    			printDetailProperties(node),
    			printModeProperties(node)
    		].filter(Boolean).join(', ');
    	}

    	function printDetailProperties(nodeOrSelection) {
    		let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();

    		if (str !== '') {
    			str = 'detail: ' + str;
    		}

    		return str;
    	}

    	function printModeProperties(nodeOrSelection) {
    		let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();

    		if (str !== '') {
    			str = 'mode: ' + str;
    		}

    		return str;
    	}

    	function printFormatProperties(nodeOrSelection) {
    		let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();

    		if (str !== '') {
    			str = 'format: ' + str;
    		}

    		return str;
    	}

    	function printSelectedCharsLine({ indent, isSelected, node, nodeKeyDisplay, selection, typeDisplay }) {
    		// No selection or node is not selected.
    		if (!Lexical_1.$isTextNode(node) || !Lexical_1.$isRangeSelection(selection) || !isSelected || Lexical_1.$isElementNode(node)) {
    			return '';
    		}

    		// No selected characters.
    		const anchor = selection.anchor;

    		const focus = selection.focus;

    		if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {
    			return '';
    		}

    		const [start, end] = getSelectionStartEnd(node, selection);

    		if (start === end) {
    			return '';
    		}

    		const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling
    		? SYMBOLS.ancestorHasNextSibling
    		: SYMBOLS.ancestorIsLastChild;

    		const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];
    		const unselectedChars = Array(start + 1).fill(' ');
    		const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);
    		const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.
    		const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');

    		return [
    			SYMBOLS.selectedLine,
    			indentionChars.join(' '),
    			[...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')
    		].join(' ') + '\n';
    	}

    	function getSelectionStartEnd(node, selection) {
    		const anchor = selection.anchor;
    		const focus = selection.focus;
    		const textContent = node.getTextContent();
    		const textLength = textContent.length;
    		let start = -1;
    		let end = -1;

    		// Only one node is being selected.
    		if (anchor.type === 'text' && focus.type === 'text') {
    			const anchorNode = anchor.getNode();
    			const focusNode = focus.getNode();

    			if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {
    				[start, end] = anchor.offset < focus.offset
    				? [anchor.offset, focus.offset]
    				: [focus.offset, anchor.offset];
    			} else if (node === anchorNode) {
    				[start, end] = anchorNode.isBefore(focusNode)
    				? [anchor.offset, textLength]
    				: [0, anchor.offset];
    			} else if (node === focusNode) {
    				[start, end] = focusNode.isBefore(anchorNode)
    				? [focus.offset, textLength]
    				: [0, focus.offset];
    			} else {
    				// Node is within selection but not the anchor nor focus.
    				[start, end] = [0, textLength];
    			}
    		}

    		// Account for non-single width characters.
    		const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;

    		const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;

    		return [
    			start + numNonSingleWidthCharBeforeSelection,
    			end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection
    		];
    	}

    	const click_handler = () => {
    		$$invalidate(7, showLimited = true);
    		const editorState = lastEditorStateRef;

    		if (editorState !== null) {
    			$$invalidate(14, lastEditorStateRef = null);
    			generateTree(editorState);
    		}
    	};

    	const click_handler_1 = () => {
    		const rootElement = editor.getRootElement();

    		if (rootElement !== null) {
    			rootElement.contentEditable = 'false';
    			$$invalidate(10, playingIndexRef = totalEditorStates - 1);
    			$$invalidate(9, timeTravelEnabled = true);
    		}
    	};

    	function pre_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			treeElementRef = $$value;
    			$$invalidate(11, treeElementRef);
    		});
    	}

    	const click_handler_2 = () => {
    		if (playingIndexRef === totalEditorStates - 1) {
    			$$invalidate(10, playingIndexRef = 1);
    		}

    		$$invalidate(6, isPlaying = !isPlaying);
    	};

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputRef = $$value;
    			$$invalidate(12, inputRef);
    		});
    	}

    	const change_handler = event => {
    		const editorStateIndex = Number(event.target.value);
    		const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];

    		if (timeStampedEditorState) {
    			$$invalidate(10, playingIndexRef = editorStateIndex);
    			editor.setEditorState(timeStampedEditorState[1]);
    		}
    	};

    	const click_handler_3 = () => {
    		const rootElement = editor.getRootElement();

    		if (rootElement !== null) {
    			rootElement.contentEditable = 'true';
    			const index = timeStampedEditorStates.length - 1;
    			const timeStampedEditorState = timeStampedEditorStates[index];
    			editor.setEditorState(timeStampedEditorState[1]);
    			const input = inputRef;

    			if (input !== null) {
    				input.value = String(index);
    			}

    			$$invalidate(9, timeTravelEnabled = false);
    			$$invalidate(6, isPlaying = false);
    		}
    	};

    	$$self.$$set = $$props => {
    		if ('timeTravelButtonClassName' in $$props) $$invalidate(0, timeTravelButtonClassName = $$props.timeTravelButtonClassName);
    		if ('timeTravelPanelButtonClassName' in $$props) $$invalidate(1, timeTravelPanelButtonClassName = $$props.timeTravelPanelButtonClassName);
    		if ('timeTravelPanelClassName' in $$props) $$invalidate(2, timeTravelPanelClassName = $$props.timeTravelPanelClassName);
    		if ('timeTravelPanelSliderClassName' in $$props) $$invalidate(3, timeTravelPanelSliderClassName = $$props.timeTravelPanelSliderClassName);
    		if ('viewClassName' in $$props) $$invalidate(4, viewClassName = $$props.viewClassName);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*showLimited*/ 128) {
    			{
    				const editorState = editor.getEditorState();

    				if (!showLimited && editorState._nodeMap.size > 1000) {
    					$$invalidate(8, content = generateContent(editorState, editor._config, editor._compositionKey, editor._editable));
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*timeStampedEditorStates*/ 32) {
    			$$invalidate(15, totalEditorStates = timeStampedEditorStates.length);
    		}

    		if ($$self.$$.dirty[0] & /*isPlaying*/ 64) {
    			if (isPlaying) {
    				play();
    			}
    		}

    		if ($$self.$$.dirty[0] & /*isPlaying, timeoutId*/ 262208) {
    			if (!isPlaying) {
    				clearInterval(timeoutId);
    			}
    		}
    	};

    	return [
    		timeTravelButtonClassName,
    		timeTravelPanelButtonClassName,
    		timeTravelPanelClassName,
    		timeTravelPanelSliderClassName,
    		viewClassName,
    		timeStampedEditorStates,
    		isPlaying,
    		showLimited,
    		content,
    		timeTravelEnabled,
    		playingIndexRef,
    		treeElementRef,
    		inputRef,
    		isLimited,
    		lastEditorStateRef,
    		totalEditorStates,
    		editor,
    		generateTree,
    		timeoutId,
    		click_handler,
    		click_handler_1,
    		pre_binding,
    		click_handler_2,
    		input_1_binding,
    		change_handler,
    		click_handler_3
    	];
    }

    class TreeView extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$3,
    			create_fragment$4,
    			safe_not_equal,
    			{
    				timeTravelButtonClassName: 0,
    				timeTravelPanelButtonClassName: 1,
    				timeTravelPanelClassName: 2,
    				timeTravelPanelSliderClassName: 3,
    				viewClassName: 4
    			},
    			null,
    			[-1, -1]
    		);
    	}
    }

    /* src/core/plugins/TreeViewPlugin.svelte generated by Svelte v3.55.1 */

    function create_fragment$3(ctx) {
    	let treeview;
    	let current;

    	treeview = new TreeView({
    			props: {
    				viewClassName: "tree-view-output",
    				timeTravelPanelClassName: "debug-timetravel-panel",
    				timeTravelButtonClassName: "debug-timetravel-button",
    				timeTravelPanelSliderClassName: "debug-timetravel-panel-slider",
    				timeTravelPanelButtonClassName: "debug-timetravel-panel-button"
    			}
    		});

    	return {
    		c() {
    			create_component(treeview.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(treeview, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(treeview.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(treeview.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			destroy_component(treeview, detaching);
    		}
    	};
    }

    class TreeViewPlugin extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, null, create_fragment$3, safe_not_equal, {});
    	}
    }

    /* src/core/ContentEditable.svelte generated by Svelte v3.55.1 */

    function add_css(target) {
    	append_styles(target, "svelte-l8squr", ".ContentEditable__root.svelte-l8squr{border:0;font-size:15px;display:block;position:relative;tab-size:1;outline:0;padding:10px;min-height:150px}");
    }

    function create_fragment$2(ctx) {
    	let div;
    	let div_aria_activedescendant_value;
    	let div_aria_autocomplete_value;
    	let div_aria_controls_value;
    	let div_aria_owns_value;
    	let div_autocapitalize_value;
    	let div_autocorrect_value;
    	let div_role_value;

    	return {
    		c() {
    			div = element("div");

    			attr(div, "aria-activedescendant", div_aria_activedescendant_value = !/*isEditable*/ ctx[19]
    			? null
    			: /*ariaActiveDescendantID*/ ctx[0]);

    			attr(div, "aria-autocomplete", div_aria_autocomplete_value = !/*isEditable*/ ctx[19]
    			? null
    			: /*ariaAutoComplete*/ ctx[1]);

    			attr(div, "aria-controls", div_aria_controls_value = !/*isEditable*/ ctx[19] ? null : /*ariaControls*/ ctx[2]);
    			attr(div, "aria-describedby", /*ariaDescribedBy*/ ctx[3]);
    			attr(div, "aria-expanded", /*ariaExpanded*/ ctx[4]);
    			attr(div, "aria-label", /*ariaLabel*/ ctx[5]);
    			attr(div, "aria-labelledby", /*ariaLabelledBy*/ ctx[6]);
    			attr(div, "aria-multiline", /*ariaMultiline*/ ctx[7]);
    			attr(div, "aria-owns", div_aria_owns_value = !/*isEditable*/ ctx[19] ? null : /*ariaOwneeID*/ ctx[8]);
    			attr(div, "aria-required", /*ariaRequired*/ ctx[9]);

    			attr(div, "autocapitalize", div_autocapitalize_value = /*autoCapitalize*/ ctx[10] !== undefined
    			? String(/*autoCapitalize*/ ctx[10])
    			: undefined);

    			attr(div, "autocomplete", /*autoComplete*/ ctx[11]);

    			attr(div, "autocorrect", div_autocorrect_value = /*autoCorrect*/ ctx[12] !== undefined
    			? String(/*autoCorrect*/ ctx[12])
    			: undefined);

    			attr(div, "class", "ContentEditable__root svelte-l8squr");
    			attr(div, "contenteditable", /*isEditable*/ ctx[19]);
    			attr(div, "data-testid", /*testid*/ ctx[18]);
    			attr(div, "id", /*id*/ ctx[13]);
    			attr(div, "role", div_role_value = !/*isEditable*/ ctx[19] ? undefined : /*role*/ ctx[14]);
    			attr(div, "spellcheck", /*spellCheck*/ ctx[15]);
    			attr(div, "style", /*style*/ ctx[16]);
    			attr(div, "tabindex", /*tabIndex*/ ctx[17]);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			/*div_binding*/ ctx[21](div);
    		},
    		p(ctx, [dirty]) {
    			if (dirty & /*isEditable, ariaActiveDescendantID*/ 524289 && div_aria_activedescendant_value !== (div_aria_activedescendant_value = !/*isEditable*/ ctx[19]
    			? null
    			: /*ariaActiveDescendantID*/ ctx[0])) {
    				attr(div, "aria-activedescendant", div_aria_activedescendant_value);
    			}

    			if (dirty & /*isEditable, ariaAutoComplete*/ 524290 && div_aria_autocomplete_value !== (div_aria_autocomplete_value = !/*isEditable*/ ctx[19]
    			? null
    			: /*ariaAutoComplete*/ ctx[1])) {
    				attr(div, "aria-autocomplete", div_aria_autocomplete_value);
    			}

    			if (dirty & /*isEditable, ariaControls*/ 524292 && div_aria_controls_value !== (div_aria_controls_value = !/*isEditable*/ ctx[19] ? null : /*ariaControls*/ ctx[2])) {
    				attr(div, "aria-controls", div_aria_controls_value);
    			}

    			if (dirty & /*ariaDescribedBy*/ 8) {
    				attr(div, "aria-describedby", /*ariaDescribedBy*/ ctx[3]);
    			}

    			if (dirty & /*ariaExpanded*/ 16) {
    				attr(div, "aria-expanded", /*ariaExpanded*/ ctx[4]);
    			}

    			if (dirty & /*ariaLabel*/ 32) {
    				attr(div, "aria-label", /*ariaLabel*/ ctx[5]);
    			}

    			if (dirty & /*ariaLabelledBy*/ 64) {
    				attr(div, "aria-labelledby", /*ariaLabelledBy*/ ctx[6]);
    			}

    			if (dirty & /*ariaMultiline*/ 128) {
    				attr(div, "aria-multiline", /*ariaMultiline*/ ctx[7]);
    			}

    			if (dirty & /*isEditable, ariaOwneeID*/ 524544 && div_aria_owns_value !== (div_aria_owns_value = !/*isEditable*/ ctx[19] ? null : /*ariaOwneeID*/ ctx[8])) {
    				attr(div, "aria-owns", div_aria_owns_value);
    			}

    			if (dirty & /*ariaRequired*/ 512) {
    				attr(div, "aria-required", /*ariaRequired*/ ctx[9]);
    			}

    			if (dirty & /*autoCapitalize*/ 1024 && div_autocapitalize_value !== (div_autocapitalize_value = /*autoCapitalize*/ ctx[10] !== undefined
    			? String(/*autoCapitalize*/ ctx[10])
    			: undefined)) {
    				attr(div, "autocapitalize", div_autocapitalize_value);
    			}

    			if (dirty & /*autoComplete*/ 2048) {
    				attr(div, "autocomplete", /*autoComplete*/ ctx[11]);
    			}

    			if (dirty & /*autoCorrect*/ 4096 && div_autocorrect_value !== (div_autocorrect_value = /*autoCorrect*/ ctx[12] !== undefined
    			? String(/*autoCorrect*/ ctx[12])
    			: undefined)) {
    				attr(div, "autocorrect", div_autocorrect_value);
    			}

    			if (dirty & /*isEditable*/ 524288) {
    				attr(div, "contenteditable", /*isEditable*/ ctx[19]);
    			}

    			if (dirty & /*testid*/ 262144) {
    				attr(div, "data-testid", /*testid*/ ctx[18]);
    			}

    			if (dirty & /*id*/ 8192) {
    				attr(div, "id", /*id*/ ctx[13]);
    			}

    			if (dirty & /*isEditable, role*/ 540672 && div_role_value !== (div_role_value = !/*isEditable*/ ctx[19] ? undefined : /*role*/ ctx[14])) {
    				attr(div, "role", div_role_value);
    			}

    			if (dirty & /*spellCheck*/ 32768) {
    				attr(div, "spellcheck", /*spellCheck*/ ctx[15]);
    			}

    			if (dirty & /*style*/ 65536) {
    				attr(div, "style", /*style*/ ctx[16]);
    			}

    			if (dirty & /*tabIndex*/ 131072) {
    				attr(div, "tabindex", /*tabIndex*/ ctx[17]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d(detaching) {
    			if (detaching) detach(div);
    			/*div_binding*/ ctx[21](null);
    		}
    	};
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { ariaActiveDescendantID } = $$props;
    	let { ariaAutoComplete } = $$props;
    	let { ariaControls } = $$props;
    	let { ariaDescribedBy } = $$props;
    	let { ariaExpanded } = $$props;
    	let { ariaLabel } = $$props;
    	let { ariaLabelledBy } = $$props;
    	let { ariaMultiline } = $$props;
    	let { ariaOwneeID } = $$props;
    	let { ariaRequired } = $$props;
    	let { autoCapitalize } = $$props;
    	let { autoComplete } = $$props;
    	let { autoCorrect } = $$props;
    	let { id } = $$props;
    	let { role } = $$props;
    	let { spellCheck = true } = $$props;
    	let { style } = $$props;
    	let { tabIndex } = $$props;
    	let { testid } = $$props;
    	let isEditable = false;
    	const editor = getContext('editor');
    	let ref;

    	onMount(() => {
    		editor.setRootElement(ref);
    		$$invalidate(19, isEditable = editor.isEditable());

    		editor.registerEditableListener(currentIsEditable => {
    			$$invalidate(19, isEditable = currentIsEditable);
    		});
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			ref = $$value;
    			$$invalidate(20, ref);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('ariaActiveDescendantID' in $$props) $$invalidate(0, ariaActiveDescendantID = $$props.ariaActiveDescendantID);
    		if ('ariaAutoComplete' in $$props) $$invalidate(1, ariaAutoComplete = $$props.ariaAutoComplete);
    		if ('ariaControls' in $$props) $$invalidate(2, ariaControls = $$props.ariaControls);
    		if ('ariaDescribedBy' in $$props) $$invalidate(3, ariaDescribedBy = $$props.ariaDescribedBy);
    		if ('ariaExpanded' in $$props) $$invalidate(4, ariaExpanded = $$props.ariaExpanded);
    		if ('ariaLabel' in $$props) $$invalidate(5, ariaLabel = $$props.ariaLabel);
    		if ('ariaLabelledBy' in $$props) $$invalidate(6, ariaLabelledBy = $$props.ariaLabelledBy);
    		if ('ariaMultiline' in $$props) $$invalidate(7, ariaMultiline = $$props.ariaMultiline);
    		if ('ariaOwneeID' in $$props) $$invalidate(8, ariaOwneeID = $$props.ariaOwneeID);
    		if ('ariaRequired' in $$props) $$invalidate(9, ariaRequired = $$props.ariaRequired);
    		if ('autoCapitalize' in $$props) $$invalidate(10, autoCapitalize = $$props.autoCapitalize);
    		if ('autoComplete' in $$props) $$invalidate(11, autoComplete = $$props.autoComplete);
    		if ('autoCorrect' in $$props) $$invalidate(12, autoCorrect = $$props.autoCorrect);
    		if ('id' in $$props) $$invalidate(13, id = $$props.id);
    		if ('role' in $$props) $$invalidate(14, role = $$props.role);
    		if ('spellCheck' in $$props) $$invalidate(15, spellCheck = $$props.spellCheck);
    		if ('style' in $$props) $$invalidate(16, style = $$props.style);
    		if ('tabIndex' in $$props) $$invalidate(17, tabIndex = $$props.tabIndex);
    		if ('testid' in $$props) $$invalidate(18, testid = $$props.testid);
    	};

    	return [
    		ariaActiveDescendantID,
    		ariaAutoComplete,
    		ariaControls,
    		ariaDescribedBy,
    		ariaExpanded,
    		ariaLabel,
    		ariaLabelledBy,
    		ariaMultiline,
    		ariaOwneeID,
    		ariaRequired,
    		autoCapitalize,
    		autoComplete,
    		autoCorrect,
    		id,
    		role,
    		spellCheck,
    		style,
    		tabIndex,
    		testid,
    		isEditable,
    		ref,
    		div_binding
    	];
    }

    class ContentEditable extends SvelteComponent {
    	constructor(options) {
    		super();

    		init(
    			this,
    			options,
    			instance$2,
    			create_fragment$2,
    			safe_not_equal,
    			{
    				ariaActiveDescendantID: 0,
    				ariaAutoComplete: 1,
    				ariaControls: 2,
    				ariaDescribedBy: 3,
    				ariaExpanded: 4,
    				ariaLabel: 5,
    				ariaLabelledBy: 6,
    				ariaMultiline: 7,
    				ariaOwneeID: 8,
    				ariaRequired: 9,
    				autoCapitalize: 10,
    				autoComplete: 11,
    				autoCorrect: 12,
    				id: 13,
    				role: 14,
    				spellCheck: 15,
    				style: 16,
    				tabIndex: 17,
    				testid: 18
    			},
    			add_css
    		);
    	}
    }

    const HISTORY_MERGE_OPTIONS = { tag: 'history-merge' };
    function initializeEditor(editor, initialEditorState) {
        if (initialEditorState === null) {
            return;
        }
        else if (initialEditorState === undefined) {
            editor.update(() => {
                const root = Lexical_1.$getRoot();
                if (root.isEmpty()) {
                    const paragraph = Lexical_1.$createParagraphNode();
                    root.append(paragraph);
                    const activeElement = document.activeElement;
                    if (Lexical_1.$getSelection() !== null ||
                        (activeElement !== null && activeElement === editor.getRootElement())) {
                        paragraph.select();
                    }
                }
            }, HISTORY_MERGE_OPTIONS);
        }
        else if (initialEditorState !== null) {
            switch (typeof initialEditorState) {
                case 'string': {
                    const parsedEditorState = editor.parseEditorState(initialEditorState);
                    editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);
                    break;
                }
                case 'object': {
                    editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);
                    break;
                }
                case 'function': {
                    editor.update(() => {
                        const root = Lexical_1.$getRoot();
                        if (root.isEmpty()) {
                            initialEditorState(editor);
                        }
                    }, HISTORY_MERGE_OPTIONS);
                    break;
                }
            }
        }
    }

    /* src/core/Composer.svelte generated by Svelte v3.55.1 */

    function create_fragment$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	return {
    		c() {
    			if (default_slot) default_slot.c();
    		},
    		m(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { config = {} } = $$props;
    	const editor = Lexical_1.createEditor(config);
    	initializeEditor(editor);
    	setContext('editor', editor);

    	$$self.$$set = $$props => {
    		if ('config' in $$props) $$invalidate(0, config = $$props.config);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	return [config, $$scope, slots];
    }

    class Composer extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { config: 0 });
    	}
    }

    /* src/components/richtext/RichTextComposer.svelte generated by Svelte v3.55.1 */

    function create_default_slot(ctx) {
    	let div3;
    	let toolbarrichtext;
    	let t0;
    	let div2;
    	let div1;
    	let div0;
    	let contenteditable;
    	let t1;
    	let richtextplugin;
    	let t2;
    	let historyplugin;
    	let t3;
    	let listplugin;
    	let t4;
    	let checklistplugin;
    	let t5;
    	let horizontalruleplugin;
    	let t6;
    	let imageplugin;
    	let t7;
    	let actionbar;
    	let current;
    	toolbarrichtext = new ToolbarRichText({});
    	contenteditable = new ContentEditable({});
    	richtextplugin = new RichTextPlugin({});
    	historyplugin = new HistoryPlugin({});
    	listplugin = new ListPlugin({});
    	checklistplugin = new CheckListPlugin({});
    	horizontalruleplugin = new HorizontalRulePlugin({});
    	imageplugin = new ImagePlugin({});
    	actionbar = new ActionBar({});

    	return {
    		c() {
    			div3 = element("div");
    			create_component(toolbarrichtext.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(contenteditable.$$.fragment);
    			t1 = space();
    			create_component(richtextplugin.$$.fragment);
    			t2 = space();
    			create_component(historyplugin.$$.fragment);
    			t3 = space();
    			create_component(listplugin.$$.fragment);
    			t4 = space();
    			create_component(checklistplugin.$$.fragment);
    			t5 = space();
    			create_component(horizontalruleplugin.$$.fragment);
    			t6 = space();
    			create_component(imageplugin.$$.fragment);
    			t7 = space();
    			create_component(actionbar.$$.fragment);
    			attr(div0, "class", "editor");
    			attr(div1, "class", "editor-scroller");
    			attr(div2, "class", "editor-container");
    			attr(div3, "class", "editor-shell");
    		},
    		m(target, anchor) {
    			insert(target, div3, anchor);
    			mount_component(toolbarrichtext, div3, null);
    			append(div3, t0);
    			append(div3, div2);
    			append(div2, div1);
    			append(div1, div0);
    			mount_component(contenteditable, div0, null);
    			append(div2, t1);
    			mount_component(richtextplugin, div2, null);
    			append(div2, t2);
    			mount_component(historyplugin, div2, null);
    			append(div2, t3);
    			mount_component(listplugin, div2, null);
    			append(div2, t4);
    			mount_component(checklistplugin, div2, null);
    			append(div2, t5);
    			mount_component(horizontalruleplugin, div2, null);
    			append(div2, t6);
    			mount_component(imageplugin, div2, null);
    			append(div2, t7);
    			mount_component(actionbar, div2, null);
    			current = true;
    		},
    		p: noop,
    		i(local) {
    			if (current) return;
    			transition_in(toolbarrichtext.$$.fragment, local);
    			transition_in(contenteditable.$$.fragment, local);
    			transition_in(richtextplugin.$$.fragment, local);
    			transition_in(historyplugin.$$.fragment, local);
    			transition_in(listplugin.$$.fragment, local);
    			transition_in(checklistplugin.$$.fragment, local);
    			transition_in(horizontalruleplugin.$$.fragment, local);
    			transition_in(imageplugin.$$.fragment, local);
    			transition_in(actionbar.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(toolbarrichtext.$$.fragment, local);
    			transition_out(contenteditable.$$.fragment, local);
    			transition_out(richtextplugin.$$.fragment, local);
    			transition_out(historyplugin.$$.fragment, local);
    			transition_out(listplugin.$$.fragment, local);
    			transition_out(checklistplugin.$$.fragment, local);
    			transition_out(horizontalruleplugin.$$.fragment, local);
    			transition_out(imageplugin.$$.fragment, local);
    			transition_out(actionbar.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div3);
    			destroy_component(toolbarrichtext);
    			destroy_component(contenteditable);
    			destroy_component(richtextplugin);
    			destroy_component(historyplugin);
    			destroy_component(listplugin);
    			destroy_component(checklistplugin);
    			destroy_component(horizontalruleplugin);
    			destroy_component(imageplugin);
    			destroy_component(actionbar);
    		}
    	};
    }

    function create_fragment(ctx) {
    	let composer_1;
    	let current;

    	let composer_1_props = {
    		config: /*config*/ ctx[1],
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	composer_1 = new Composer({ props: composer_1_props });
    	/*composer_1_binding*/ ctx[4](composer_1);

    	return {
    		c() {
    			create_component(composer_1.$$.fragment);
    		},
    		m(target, anchor) {
    			mount_component(composer_1, target, anchor);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			const composer_1_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				composer_1_changes.$$scope = { dirty, ctx };
    			}

    			composer_1.$set(composer_1_changes);
    		},
    		i(local) {
    			if (current) return;
    			transition_in(composer_1.$$.fragment, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(composer_1.$$.fragment, local);
    			current = false;
    		},
    		d(detaching) {
    			/*composer_1_binding*/ ctx[4](null);
    			destroy_component(composer_1, detaching);
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { theme } = $$props;
    	let composer;

    	const config = {
    		theme,
    		nodes: [
    			LexicalRichText_1.HeadingNode,
    			LexicalList_1.ListNode,
    			LexicalList_1.ListItemNode,
    			LexicalRichText_1.QuoteNode,
    			HorizontalRuleNode,
    			ImageNode
    		],
    		onError: error => {
    			throw error;
    		}
    	};

    	function getEditor() {
    		return composer.$$.context.get('editor');
    	}

    	function composer_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			composer = $$value;
    			$$invalidate(0, composer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('theme' in $$props) $$invalidate(2, theme = $$props.theme);
    	};

    	return [composer, config, theme, getEditor, composer_1_binding];
    }

    class RichTextComposer extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance, create_fragment, safe_not_equal, { theme: 2, getEditor: 3 });
    	}

    	get getEditor() {
    		return this.$$.ctx[3];
    	}
    }

    exports.ActionBar = ActionBar;
    exports.CheckListPlugin = CheckListPlugin;
    exports.Composer = Composer;
    exports.ContentEditable = ContentEditable;
    exports.HeadingNode = LexicalRichText_1.HeadingNode;
    exports.HistoryPlugin = HistoryPlugin;
    exports.HorizontalRuleNode = HorizontalRuleNode;
    exports.HorizontalRulePlugin = HorizontalRulePlugin;
    exports.ImageNode = ImageNode;
    exports.ImagePlugin = ImagePlugin;
    exports.ListItemNode = LexicalList_1.ListItemNode;
    exports.ListNode = LexicalList_1.ListNode;
    exports.ListPlugin = ListPlugin;
    exports.PlainTextPlugin = PlainTextPlugin;
    exports.QuoteNode = LexicalRichText_1.QuoteNode;
    exports.RichTextComposer = RichTextComposer;
    exports.RichTextPlugin = RichTextPlugin;
    exports.ToolbarBasic = ToolbarBasic;
    exports.ToolbarRichText = ToolbarRichText;
    exports.TreeViewPlugin = TreeViewPlugin;

}));
