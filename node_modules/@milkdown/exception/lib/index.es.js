var p = Object.defineProperty;
var u = (e, o, i) => o in e ? p(e, o, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[o] = i;
var m = (e, o, i) => (u(e, typeof o != "symbol" ? o + "" : o, i), i);
var n = /* @__PURE__ */ ((e) => (e.docTypeError = "docTypeError", e.contextNotFound = "contextNotFound", e.timerNotFound = "timerNotFound", e.ctxCallOutOfScope = "ctxCallOutOfScope", e.createNodeInParserFail = "createNodeInParserFail", e.stackOverFlow = "stackOverFlow", e.parserMatchError = "parserMatchError", e.serializerMatchError = "serializerMatchError", e.getAtomFromSchemaFail = "getAtomFromSchemaFail", e.expectDomTypeError = "expectDomTypeError", e.callCommandBeforeEditorView = "callCommandBeforeEditorView", e.themeMustInstalled = "themeMustInstalled", e.missingRootElement = "missingRootElement", e.missingNodeInSchema = "missingNodeInSchema", e.missingMarkInSchema = "missingMarkInSchema", e.missingIcon = "missingIcon", e.vueRendererCallOutOfScope = "vueRendererCallOutOfScope", e.ctxNotBind = "ctxNotBind", e.missingYjsDoc = "missingYjsDoc", e.repeatCallsToMenuWrapperInit = "repeatCallsToMenuWrapperInit", e.missingMenuWrapper = "missingMenuWrapper", e))(n || {});
class t extends Error {
  constructor(i, a) {
    super(a);
    m(this, "code");
    this.name = "MilkdownError", this.code = i;
  }
}
const d = (e, o) => typeof o == "function" ? "[Function]" : o, s = (e) => JSON.stringify(e, d), g = (e) => new t(n.docTypeError, `Doc type error, unsupported type: ${s(e)}`), f = (e) => new t(n.contextNotFound, `Context "${e}" not found, do you forget to inject it?`), w = (e) => new t(n.timerNotFound, `Timer "${e}" not found, do you forget to record it?`), M = () => new t(n.ctxCallOutOfScope, "Should not call a context out of the plugin."), S = (...e) => {
  const o = e.reduce((i, a) => {
    if (!a)
      return i;
    const c = (r) => Array.isArray(r) ? r.map((l) => c(l)).join(", ") : r.toJSON ? s(r.toJSON()) : r.spec ? s(r.spec) : r.toString();
    return `${i}, ${c(a)}`;
  }, "Create prosemirror node from remark failed in parser");
  return new t(n.createNodeInParserFail, o);
}, y = () => new t(n.stackOverFlow, "Stack over flow, cannot pop on an empty stack."), F = (e) => new t(n.parserMatchError, `Cannot match target parser for node: ${s(e)}.`), I = (e) => new t(n.serializerMatchError, `Cannot match target serializer for node: ${s(e)}.`), N = (e, o) => new t(n.getAtomFromSchemaFail, `Cannot get ${e}: ${o} from schema.`), O = (e) => new t(n.expectDomTypeError, `Expect to be a dom, but get: ${s(e)}.`), k = () => new t(
  n.callCommandBeforeEditorView,
  "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
), x = () => new t(
  n.themeMustInstalled,
  "It seems that no theme found in editor, please make sure you have use theme in front of all plugins.\nIf you prefer to use an empty theme, you can use `themeFactory({})`."
), v = () => new t(
  n.missingRootElement,
  "Missing root element, milkdown cannot find root element of the editor."
), T = (e) => new t(
  n.missingNodeInSchema,
  `Missing node in schema, milkdown cannot find "${e}" in schema.`
), $ = (e) => new t(
  n.missingMarkInSchema,
  `Missing mark in schema, milkdown cannot find "${e}" in schema.`
), z = (e) => new t(n.missingIcon, `Missing icon in theme, milkdown cannot find icon "${e}" in theme.`), R = () => new t(n.ctxNotBind, "Context not bind, please make sure the plugin has been initialized."), b = () => new t(n.missingYjsDoc, "Missing yjs doc, please make sure you have bind one."), D = () => new t(n.vueRendererCallOutOfScope, "Should not call vue renderer before it has been created."), B = () => new t(n.missingMenuWrapper, "Missing menu wrapper, should init menu wrapper first."), E = () => new t(n.repeatCallsToMenuWrapperInit, "Repeated calls to menu wrapper initialization");
export {
  k as callCommandBeforeEditorView,
  f as contextNotFound,
  S as createNodeInParserFail,
  M as ctxCallOutOfScope,
  R as ctxNotBind,
  g as docTypeError,
  O as expectDomTypeError,
  N as getAtomFromSchemaFail,
  z as missingIcon,
  $ as missingMarkInSchema,
  B as missingMenuWrapper,
  T as missingNodeInSchema,
  v as missingRootElement,
  b as missingYjsDoc,
  F as parserMatchError,
  E as repeatCallsToMenuWrapperInit,
  I as serializerMatchError,
  y as stackOverFlow,
  x as themeMustInstalled,
  w as timerNotFound,
  D as vueRendererCallOutOfScope
};
//# sourceMappingURL=index.es.js.map
