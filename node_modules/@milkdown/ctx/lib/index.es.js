var P = Object.defineProperty;
var k = (e, t, i) => t in e ? P(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var r = (e, t, i) => (k(e, typeof t != "symbol" ? t + "" : t, i), i), T = (e, t, i) => {
  if (!t.has(e))
    throw TypeError("Cannot " + i);
};
var n = (e, t, i) => (T(e, t, "read from private field"), i ? i.call(e) : t.get(e)), u = (e, t, i) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, i);
}, h = (e, t, i, s) => (T(e, t, "write to private field"), s ? s.call(e, i) : t.set(e, i), i);
import { contextNotFound as M, ctxCallOutOfScope as b, timerNotFound as x } from "@milkdown/exception";
const F = () => {
  const e = /* @__PURE__ */ new Map();
  return { sliceMap: e, getSlice: (s) => {
    const o = typeof s == "string" ? [...e.values()].find((c) => c.name === s) : e.get(s.id);
    if (!o) {
      const c = typeof s == "string" ? s : s.sliceName;
      throw M(c);
    }
    return o;
  }, removeSlice: (s) => {
    const o = typeof s == "string" ? [...e.values()].find((c) => c.name === s) : e.get(s.id);
    !o || e.delete(o.id);
  } };
}, j = (e) => Array.isArray(e) ? [...e] : typeof e == "object" ? { ...e } : e, I = (e, t) => {
  const i = Symbol(`Context-${t}`), s = (o, c = j(e)) => {
    let a = c;
    const g = {
      name: t,
      id: i,
      set: (m) => {
        a = m;
      },
      get: () => a,
      update: (m) => {
        a = m(a);
      }
    };
    return o.set(i, g), g;
  };
  return s.sliceName = t, s.id = i, s._typeInfo = () => {
    throw b();
  }, s;
};
var p, v;
class O {
  constructor(t, i) {
    u(this, p, void 0);
    u(this, v, void 0);
    r(this, "use", (t) => n(this, p).getSlice(t));
    r(this, "get", (t) => this.use(t).get());
    r(this, "set", (t, i) => this.use(t).set(i));
    r(this, "update", (t, i) => this.use(t).update(i));
    r(this, "timing", (t) => n(this, v).get(t));
    r(this, "done", (t) => this.timing(t).done());
    r(this, "wait", (t) => this.timing(t)());
    r(this, "waitTimers", async (t) => {
      await Promise.all(this.get(t).map((i) => this.wait(i)));
    });
    h(this, p, t), h(this, v, i);
  }
}
p = new WeakMap(), v = new WeakMap();
var l, d;
class $ {
  constructor(t, i) {
    u(this, l, void 0);
    u(this, d, void 0);
    r(this, "inject", (t, i) => (t(n(this, l).sliceMap, i), this));
    r(this, "remove", (t) => (n(this, l).removeSlice(t), this));
    r(this, "record", (t) => (t(n(this, d).store), this));
    r(this, "clearTimer", (t) => (n(this, d).remove(t), this));
    r(this, "use", (t) => n(this, l).getSlice(t));
    r(this, "get", (t) => this.use(t).get());
    r(this, "set", (t, i) => this.use(t).set(i));
    r(this, "update", (t, i) => this.use(t).update(i));
    r(this, "timing", (t) => n(this, d).get(t));
    r(this, "wait", (t) => this.timing(t)());
    r(this, "done", (t) => this.timing(t).done());
    r(this, "waitTimers", async (t) => {
      await Promise.all(this.get(t).map((i) => this.wait(i)));
    });
    h(this, l, t), h(this, d, i);
  }
}
l = new WeakMap(), d = new WeakMap();
var f, w;
class _ {
  constructor(t, i) {
    u(this, f, void 0);
    u(this, w, void 0);
    r(this, "clearTimer", (t) => (n(this, w).remove(t), this));
    r(this, "remove", (t) => (n(this, f).removeSlice(t), this));
    h(this, f, t), h(this, w, i);
  }
}
f = new WeakMap(), w = new WeakMap();
var y, S;
class q {
  constructor(t, i) {
    u(this, y, void 0);
    u(this, S, void 0);
    r(this, "inject", (t, i) => (t(n(this, y).sliceMap, i), this));
    r(this, "record", (t) => (t(n(this, S).store), this));
    h(this, y, t), h(this, S, i);
  }
}
y = new WeakMap(), S = new WeakMap();
const z = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    store: e,
    get: (s) => {
      const o = e.get(s.id);
      if (!o)
        throw x(s.timerName);
      return o;
    },
    remove: (s) => {
      e.delete(s.id);
    }
  };
}, B = (e, t = 3e3) => {
  const i = Symbol("Timer"), s = (o) => {
    let c = null, a;
    const g = Symbol(e), m = () => c != null ? c : c = new Promise((C, N) => {
      a = (E) => {
        E instanceof CustomEvent && E.detail.id === g && (removeEventListener(e, a), E.stopImmediatePropagation(), C());
      }, setTimeout(() => {
        N(new Error(`Timing ${e} timeout.`)), removeEventListener(e, a);
      }, t), addEventListener(e, a);
    });
    return m.done = () => {
      const C = new CustomEvent(e, { detail: { id: g } });
      dispatchEvent(C);
    }, o.set(i, m), m;
  };
  return s.id = i, s.timerName = e, s;
};
export {
  O as Ctx,
  $ as Env,
  _ as Post,
  q as Pre,
  z as createClock,
  F as createContainer,
  I as createSlice,
  B as createTimer
};
//# sourceMappingURL=index.es.js.map
