{"version":3,"file":"index.es.js","sources":["../src/context/container.ts","../src/context/shallow-clone.ts","../src/context/slice.ts","../src/plugin/ctx.ts","../src/plugin/env.ts","../src/plugin/post.ts","../src/plugin/pre.ts","../src/timing/clock.ts","../src/timing/timing.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { contextNotFound } from '@milkdown/exception'\n\nimport type { Slice, SliceValue } from './slice'\n\nexport interface Container {\n  readonly sliceMap: Map<symbol, SliceValue>\n  readonly getSlice: <T, N extends string = string>(slice: Slice<T, N> | N) => SliceValue<T, N>\n  readonly removeSlice: <T, N extends string = string>(slice: Slice<T, N> | N) => void\n}\n\nexport const createContainer = (): Container => {\n  const sliceMap: Map<symbol, SliceValue> = new Map()\n\n  const getSlice = <T, N extends string = string>(slice: Slice<T, N> | N): SliceValue<T, N> => {\n    const context\n      = typeof slice === 'string' ? [...sliceMap.values()].find(x => x.name === slice) : sliceMap.get(slice.id)\n\n    if (!context) {\n      const name = typeof slice === 'string' ? slice : slice.sliceName\n      throw contextNotFound(name)\n    }\n    return context as SliceValue<T, N>\n  }\n\n  const removeSlice = <T, N extends string = string>(slice: Slice<T, N> | N): void => {\n    const context\n      = typeof slice === 'string' ? [...sliceMap.values()].find(x => x.name === slice) : sliceMap.get(slice.id)\n\n    if (!context)\n      return\n\n    sliceMap.delete(context.id)\n  }\n\n  return { sliceMap, getSlice, removeSlice }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nexport const shallowClone = <T>(x: T): T => {\n  if (Array.isArray(x))\n    return [...(x as unknown[])] as unknown as T\n\n  if (typeof x === 'object')\n    return { ...x }\n\n  return x\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { ctxCallOutOfScope } from '@milkdown/exception'\n\nimport { shallowClone } from './shallow-clone'\n\nexport interface SliceValue<T = unknown, N extends string = string> {\n  readonly id: symbol\n  readonly name: N\n  readonly set: (value: T) => void\n  readonly get: () => T\n  readonly update: (updater: (prev: T) => T) => void\n}\n\nexport type SliceMap = Map<symbol, SliceValue>\n\nexport interface Slice<T, N extends string = string> {\n  readonly id: symbol\n  readonly sliceName: N\n  readonly _typeInfo: () => T\n  (container: SliceMap, resetValue?: T): SliceValue<T>\n}\n\nexport const createSlice = <T, N extends string = string>(value: T, name: N): Slice<T, N> => {\n  const id = Symbol(`Context-${name}`)\n\n  const factory = (container: SliceMap, resetValue = shallowClone(value)) => {\n    let inner = resetValue\n\n    const context: SliceValue<T> = {\n      name,\n      id,\n      set: (next) => {\n        inner = next\n      },\n      get: () => inner,\n      update: (updater) => {\n        inner = updater(inner)\n      },\n    }\n    container.set(id, context as SliceValue)\n    return context\n  }\n  factory.sliceName = name\n  factory.id = id\n  factory._typeInfo = (): T => {\n    throw ctxCallOutOfScope()\n  }\n\n  return factory\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice, SliceValue } from '../context'\nimport type { Clock, Timer } from '../timing'\n\n/**\n * The ctx object that can be accessed in plugin and action.\n */\nexport class Ctx {\n  #container: Container\n  #clock: Clock\n\n  constructor(container: Container, clock: Clock) {\n    this.#container = container\n    this.#clock = clock\n  }\n\n  /**\n      * Get the slice instance.\n      *\n      * @param slice - The slice or slice name that needs to be used.\n      * @returns The slice instance.\n      */\n  readonly use = <T, N extends string = string>(slice: Slice<T, N> | N): SliceValue<T, N> =>\n    this.#container.getSlice(slice)\n\n  /**\n      * Get the slice value.\n      *\n      * @param slice - The slice needs to be used.\n      * @returns The slice value.\n      */\n  readonly get = <T, N extends string>(slice: Slice<T, N>) => this.use(slice).get()\n\n  /**\n      * Set the slice value.\n      *\n      * @param slice - The slice needs to be used.\n      * @param value - The default value.\n      * @returns\n      */\n  readonly set = <T, N extends string>(slice: Slice<T, N>, value: T) => this.use(slice).set(value)\n\n  /**\n      * Update the slice by its current value.\n      *\n      * @example\n      * ```\n      * update(NumberSlice, x => x + 1);\n      * ```\n      *\n      * @param slice - The slice needs to be used.\n      * @param updater - The update function, gets current value as parameter and returns new value.\n      * @returns\n      */\n  readonly update = <T, N extends string>(slice: Slice<T, N>, updater: (prev: T) => T) =>\n    this.use(slice).update(updater)\n\n  /**\n      * Get the timer instance.\n      *\n      * @param timer - The timer needs to be used.\n      * @returns The timer instance.\n      */\n  readonly timing = (timer: Timer) => this.#clock.get(timer)\n\n  /**\n      * Finish a timer\n      *\n      * @param timer - The timer needs to be finished.\n      * @returns\n      */\n  readonly done = (timer: Timer) => this.timing(timer).done()\n\n  /**\n      * Wait for a timer to finish.\n      *\n      * @param timer - The timer needs to be used.\n      * @returns A promise that will be resolved when timer finish.\n      */\n  readonly wait = (timer: Timer) => this.timing(timer)()\n\n  /**\n      * Wait for a list of timers in target slice to be all finished.\n      *\n      * @param slice - The slice that holds a list of timer.\n      * @returns A promise that will be resolved when all timers finish.\n      */\n  readonly waitTimers = async (slice: Slice<Timer[]>) => {\n    await Promise.all(this.get(slice).map(x => this.wait(x)))\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice, SliceValue } from '../context'\nimport type { Clock, Timer } from '../timing'\n\nexport class Env {\n  #container: Container\n  #clock: Clock\n\n  constructor(container: Container, clock: Clock) {\n    this.#container = container\n    this.#clock = clock\n  }\n\n  /**\n      * Inject a context into current editor.\n      *\n      * @param ctx - The context needs to be injected.\n      * @param defaultValue - The default value of this context.\n      * @returns Env.\n      */\n  readonly inject = <T>(ctx: Slice<T>, defaultValue?: T) => {\n    ctx(this.#container.sliceMap, defaultValue)\n    return this\n  }\n\n  /**\n      * Remove a context from current editor.\n      *\n      * @param ctx - The context needs to be removed.\n      * @returns Env.\n      */\n  readonly remove = <T, N extends string = string>(ctx: Slice<T, N> | N) => {\n    this.#container.removeSlice(ctx)\n    return this\n  }\n\n  /**\n      * Start to record for a timer.\n      *\n      * @param timer - The timer needs to be recorded.\n      * @returns Env.\n      */\n  readonly record = (timer: Timer) => {\n    timer(this.#clock.store)\n    return this\n  }\n\n  /**\n      * Clear a timer record.\n      *\n      * @param timer - The timer needs to be cleared.\n      * @returns Env.\n      */\n  readonly clearTimer = (timer: Timer) => {\n    this.#clock.remove(timer)\n    return this\n  }\n\n  /**\n      * Get the slice instance.\n      *\n      * @param slice - The slice or slice name that needs to be used.\n      * @returns The slice instance.\n      */\n  readonly use = <T, N extends string = string>(slice: Slice<T, N> | N): SliceValue<T, N> =>\n    this.#container.getSlice(slice)\n\n  /**\n      * Get the slice value.\n      *\n      * @param slice - The slice needs to be used.\n      * @returns The slice value.\n      */\n  readonly get = <T, N extends string>(slice: Slice<T, N>) => this.use(slice).get()\n\n  /**\n      * Set the slice value.\n      *\n      * @param slice - The slice needs to be used.\n      * @param value - The default value.\n      * @returns\n      */\n  readonly set = <T, N extends string>(slice: Slice<T, N>, value: T) => this.use(slice).set(value)\n\n  /**\n      * Update the slice by its current value.\n      *\n      * @example\n      * ```\n      * update(NumberSlice, x => x + 1);\n      * ```\n      *\n      * @param slice - The slice needs to be used.\n      * @param updater - The update function, gets current value as parameter and returns new value.\n      * @returns\n      */\n  readonly update = <T, N extends string>(slice: Slice<T, N>, updater: (prev: T) => T) =>\n    this.use(slice).update(updater)\n\n  /**\n      * Get the timer instance.\n      *\n      * @param timer - The timer needs to be used.\n      * @returns The timer instance.\n      */\n  readonly timing = (timer: Timer) => this.#clock.get(timer)\n\n  /**\n      * Wait for a timer to finish.\n      *\n      * @param timer - The timer needs to be used.\n      * @returns A promise that will be resolved when timer finish.\n      */\n  readonly wait = (timer: Timer) => this.timing(timer)()\n\n  /**\n      * Finish a timer\n      *\n      * @param timer - The timer needs to be finished.\n      * @returns\n      */\n  readonly done = (timer: Timer) => this.timing(timer).done()\n\n  /**\n      * Wait for a list of timers in target slice to be all finished.\n      *\n      * @param slice - The slice that holds a list of timer.\n      * @returns A promise that will be resolved when all timers finish.\n      */\n  readonly waitTimers = async (slice: Slice<Timer[]>) => {\n    await Promise.all(this.get(slice).map(x => this.wait(x)))\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice } from '../context'\nimport type { Clock, Timer } from '../timing'\n\nexport class Post {\n  #container: Container\n  #clock: Clock\n\n  constructor(container: Container, clock: Clock) {\n    this.#container = container\n    this.#clock = clock\n  }\n\n  /**\n     * Clear a timer record.\n     *\n     * @param timer - The timer needs to be cleared.\n     * @returns Env.\n     */\n  readonly clearTimer = (timer: Timer) => {\n    this.#clock.remove(timer)\n    return this\n  }\n\n  /**\n     * Remove a context from current editor.\n     *\n     * @param ctx - The context needs to be removed.\n     * @returns Ctx.\n     */\n  readonly remove = <T, N extends string = string>(ctx: Slice<T, N> | N) => {\n    this.#container.removeSlice(ctx)\n    return this\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Container, Slice } from '../context'\nimport type { Clock, Timer } from '../timing'\n\nexport class Pre {\n  #container: Container\n  #clock: Clock\n\n  constructor(container: Container, clock: Clock) {\n    this.#container = container\n    this.#clock = clock\n  }\n\n  /**\n     * Inject a context into current editor.\n     *\n     * @param ctx - The context needs to be injected.\n     * @param defaultValue - The default value of this context.\n     * @returns Pre.\n     */\n  readonly inject = <T>(ctx: Slice<T>, defaultValue?: T) => {\n    ctx(this.#container.sliceMap, defaultValue)\n    return this\n  }\n\n  /**\n     * Start to record for a timer.\n     *\n     * @param timer - The timer needs to be recorded.\n     * @returns Pre.\n     */\n  readonly record = (timer: Timer) => {\n    timer(this.#clock.store)\n    return this\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { timerNotFound } from '@milkdown/exception'\n\nimport type { Timing } from './timing'\n\nexport type ClockMap = Map<symbol, Timing>\n\nexport interface Timer {\n  (store: ClockMap): Timing\n  id: symbol\n  timerName: string\n}\n\nexport interface Clock {\n  store: ClockMap\n  get: (timer: Timer) => Timing\n  remove: (timer: Timer) => void\n}\n\nexport const createClock = (): Clock => {\n  const store: ClockMap = new Map()\n  const get = (timer: Timer) => {\n    const meta = store.get(timer.id)\n    if (!meta)\n      throw timerNotFound(timer.timerName)\n    return meta\n  }\n\n  const remove = (timer: Timer) => {\n    store.delete(timer.id)\n  }\n\n  return {\n    store,\n    get,\n    remove,\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { ClockMap, Timer } from './clock'\n\nexport interface Timing {\n  (): Promise<void>\n  done: () => void\n}\n\nexport const createTimer = (name: string, timeout = 3000): Timer => {\n  const id = Symbol('Timer')\n\n  const timer = (store: ClockMap) => {\n    let promise: Promise<void> | null = null\n    let listener: EventListener\n\n    const data = Symbol(name)\n\n    const timing: Timing = () =>\n      (promise ??= new Promise((resolve, reject) => {\n        listener = (e: Event) => {\n          if (!(e instanceof CustomEvent))\n            return\n\n          if (e.detail.id === data) {\n            removeEventListener(name, listener)\n            e.stopImmediatePropagation()\n            resolve()\n          }\n        }\n        setTimeout(() => {\n          reject(new Error(`Timing ${name} timeout.`))\n          removeEventListener(name, listener)\n        }, timeout)\n        addEventListener(name, listener)\n      }))\n    timing.done = () => {\n      const event = new CustomEvent(name, { detail: { id: data } })\n      dispatchEvent(event)\n    }\n\n    store.set(id, timing)\n\n    return timing\n  }\n  timer.id = id\n  timer.timerName = name\n\n  return timer\n}\n"],"names":["createContainer","sliceMap","slice","context","x","name","contextNotFound","shallowClone","createSlice","value","id","factory","container","resetValue","inner","next","updater","ctxCallOutOfScope","Ctx","clock","__privateAdd","_container","_clock","__publicField","__privateGet","timer","__privateSet","Env","ctx","defaultValue","Post","Pre","createClock","store","meta","timerNotFound","createTimer","timeout","promise","listener","data","timing","resolve","reject","e","event"],"mappings":"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"}