var Ne = Object.defineProperty;
var ze = (r, e, t) => e in r ? Ne(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var g = (r, e, t) => (ze(r, typeof e != "symbol" ? e + "" : e, t), t), Se = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
};
var o = (r, e, t) => (Se(r, e, "read from private field"), t ? t.call(r) : e.get(r)), c = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
}, V = (r, e, t, n) => (Se(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
import { createTimer as w, createSlice as a, createContainer as be, createClock as _e, Ctx as Le, Pre as Ae, Post as We } from "@milkdown/ctx";
export * from "@milkdown/ctx";
import { createThemeManager as $e, emotionConfigCtx as ee, emotionCtx as L, themeManagerCtx as ye, initEmotion as qe, internalThemeKeys as Ie, ThemeGlobal as Be } from "@milkdown/design-system";
export * from "@milkdown/design-system";
import { createParser as Ge, createSerializer as He } from "@milkdown/transformer";
export * from "@milkdown/transformer";
import { PluginKey as ke, Plugin as Ee, EditorState as Je } from "@milkdown/prose/state";
import we from "remark-parse";
import ge from "remark-stringify";
import { unified as fe } from "unified";
import { Schema as Fe, DOMParser as Qe, Node as Ue } from "@milkdown/prose/model";
import { docTypeError as Xe, callCommandBeforeEditorView as Ye } from "@milkdown/exception";
import { EditorView as Ze } from "@milkdown/prose/view";
import { customInputRules as xe } from "@milkdown/prose";
import { baseKeymap as et } from "@milkdown/prose/commands";
import { keymap as tt } from "@milkdown/prose/keymap";
const A = w("ConfigReady"), rt = (r) => (e) => (e.record(A), async (t) => (await r(t), t.done(A), (n) => {
  n.clearTimer(A);
})), te = a([], "themeTimer"), W = w("ThemeEnvironmentReady"), $ = w("ThemeReady"), nt = new ke("MILKDOWN_THEME_RESET"), ot = (r) => {
  const e = $e();
  return r.inject(ee).inject(L).inject(ye, e).inject(te, [A]).record($).record(W), async (t) => {
    await t.waitTimers(te);
    const n = qe(t.get(ee));
    return Ie.forEach((s) => {
      e.inject(s);
    }), t.set(L, n), t.done(W), t.done($), await t.wait(T), t.update(
      P,
      (s) => s.concat(
        new Ee({
          key: nt,
          view: () => (e.runExecutor(), {
            destroy: () => {
              n.flush();
            }
          })
        })
      )
    ), (s) => {
      s.remove(ee).remove(L).remove(ye).remove(te).clearTimer($).clearTimer(W);
    };
  };
}, Nt = (r) => {
  let e = null;
  const t = () => async (n) => {
    await n.wait(W);
    const s = n.get(L), m = n.get(ye);
    m.setExecutor(() => {
      r == null || r(s, m), e == null || e(s, m), Ie.forEach((u) => {
        m.has(u) || console.warn("Theme key not found: ", u.sliceName);
      }), m.get(Be, void 0);
    });
  };
  return t.override = (n) => (e = n, t), t;
}, T = w("InitReady"), re = a([], "initTimer"), De = a({}, "editor"), Ce = a([], "inputRules"), P = a([], "prosePlugins"), ve = a([], "remarkPlugins"), Te = a([], "nodeView"), je = a([], "markView"), C = a(fe().use(we).use(ge), "remark"), st = {}, ne = a(st, "remarkStringifyOptions"), it = (r) => (e) => (e.inject(De, r).inject(P).inject(ve).inject(Ce).inject(Te).inject(je).inject(ne).inject(C, fe().use(we).use(ge)).inject(re, [$]).record(T), async (t) => {
  await t.waitTimers(re);
  const n = t.get(ne);
  return t.set(C, fe().use(we).use(ge, n)), t.done(T), (s) => {
    s.remove(De).remove(P).remove(ve).remove(Ce).remove(Te).remove(je).remove(ne).remove(C).remove(re).clearTimer(T);
  };
}), j = w("schemaReady"), O = a({}, "schema"), oe = a([], "schemaTimer"), I = a([], "nodes"), K = a([], "marks"), Me = (r) => {
  var e;
  return {
    ...r,
    parseDOM: (e = r.parseDOM) == null ? void 0 : e.map((t) => ({ priority: r.priority, ...t }))
  };
}, at = (r) => (r.inject(O).inject(I).inject(K).inject(oe, [T]).record(j), async (e) => {
  await e.waitTimers(oe);
  const t = e.get(C), s = e.get(ve).reduce((d, i) => d.use(i), t);
  e.set(C, s);
  const m = Object.fromEntries(e.get(I).map(([d, i]) => [d, Me(i)])), u = Object.fromEntries(e.get(K).map(([d, i]) => [d, Me(i)]));
  return e.set(
    O,
    new Fe({
      nodes: m,
      marks: u
    })
  ), e.done(j), (d) => {
    d.remove(O).remove(I).remove(K).remove(oe).clearTimer(j);
  };
}), q = a(() => {
}, "parser"), se = a([], "parserTimer"), B = w("ParserReady"), mt = (r) => (r.inject(q).inject(se, [j]).record(B), async (e) => {
  await e.waitTimers(se);
  const t = e.get(I), n = e.get(K), s = e.get(C), m = e.get(O), u = [
    ...t.map(([i, l]) => ({ id: i, ...l })).map((i) => ({ ...i, is: "node" })),
    ...n.map(([i, l]) => ({ id: i, ...l })).map((i) => ({ ...i, is: "mark" }))
  ], d = Object.fromEntries(
    u.map(({ id: i, parseMarkdown: l, is: v }) => [i, { ...l, is: v, key: i }])
  );
  return e.set(q, Ge(m, d, s)), e.done(B), (i) => {
    i.remove(q).remove(se).clearTimer(B);
  };
}), ie = a(() => "", "serializer"), ae = a([], "serializerTimer"), G = w("SerializerReady"), ct = (r) => (r.inject(ie).inject(ae, [j]).record(G), async (e) => {
  await e.waitTimers(ae);
  const t = e.get(I), n = e.get(K), s = e.get(C), m = e.get(O), u = [...t, ...n], d = Object.fromEntries(u.map(([i, l]) => [i, l.toMarkdown]));
  return e.set(ie, He(m, d, s)), e.done(G), (i) => {
    i.remove(ie).remove(ae).clearTimer(G);
  };
}), me = a("", "defaultValue"), b = a({}, "editorState"), ce = a((r) => r, "stateOptions"), de = a([], "editorStateTimer"), H = w("EditorStateReady"), dt = new ke("MILKDOWN_STATE_TRACKER"), ht = (r, e, t) => {
  if (typeof r == "string")
    return e(r);
  if (r.type === "html")
    return Qe.fromSchema(t).parse(r.dom);
  if (r.type === "json")
    return Ue.fromJSON(t, r.value);
  throw Xe(r);
}, lt = (r) => (r.inject(me).inject(b).inject(ce).inject(de, [B, G, Q]).record(H), async (e) => {
  await e.waitTimers(de);
  const t = e.get(O), n = e.get(q), s = e.get(Ce), m = e.get(ce), u = e.get(P), d = e.get(me), i = ht(d, n, t), l = [
    ...u,
    new Ee({
      key: dt,
      state: {
        init: () => {
        },
        apply: (Z, x, vt, Ke) => {
          e.set(b, Ke);
        }
      }
    }),
    xe({ rules: s }),
    tt(et)
  ];
  e.set(P, l);
  const v = m({
    schema: t,
    doc: i,
    plugins: l
  }), h = Je.create(v);
  return e.set(b, h), e.done(H), (Z) => {
    Z.remove(me).remove(b).remove(ce).remove(de).clearTimer(H);
  };
}), J = a({}, "editorView"), he = a({}, "editorViewOptions"), le = a(null, "root"), ue = a([], "editorViewTimer"), Oe = a(null, "rootDOM"), F = w("EditorViewReady"), ut = (r, e) => {
  const t = document.createElement("div");
  return t.className = "milkdown", r.appendChild(t), e.set(Oe, t), t;
}, pt = (r) => {
  r.classList.add("editor"), r.setAttribute("role", "textbox");
}, yt = new ke("MILKDOWN_VIEW_CLEAR"), wt = (r) => (r.inject(le, document.body).inject(J).inject(he).inject(Oe).inject(ue, [H]).record(F), async (e) => {
  await e.wait(T);
  const t = e.get(le) || document.body, n = typeof t == "string" ? document.querySelector(t) : t;
  e.update(P, (l) => [
    new Ee({
      key: yt,
      view: (v) => {
        const h = n ? ut(n, e) : void 0;
        return (() => {
          if (h && n) {
            const x = v.dom;
            n.replaceChild(h, x), h.appendChild(x);
          }
        })(), {
          destroy: () => {
            h != null && h.parentNode && (h == null || h.parentNode.replaceChild(v.dom, h)), h == null || h.remove();
          }
        };
      }
    }),
    ...l
  ]), await e.waitTimers(ue);
  const s = e.get(b), m = e.get(he), u = Object.fromEntries(e.get(Te)), d = Object.fromEntries(e.get(je)), i = new Ze(n, {
    state: s,
    nodeViews: u,
    markViews: d,
    ...m
  });
  return pt(i.dom), e.set(J, i), e.done(F), (l) => {
    i == null || i.destroy(), l.remove(le).remove(J).remove(he).remove(Oe).remove(ue).clearTimer(F);
  };
});
var k, E;
class gt {
  constructor() {
    c(this, k, be());
    c(this, E, null);
    g(this, "setCtx", (e) => {
      V(this, E, e);
    });
  }
  create(e, t) {
    return e(o(this, k).sliceMap, t);
  }
  get(e) {
    return o(this, k).getSlice(e).get();
  }
  call(e, t) {
    if (o(this, E) == null)
      throw Ye();
    const s = this.get(e)(t), m = o(this, E).get(J);
    return s(m.state, m.dispatch, m);
  }
  remove(e) {
    return o(this, k).removeSlice(e);
  }
}
k = new WeakMap(), E = new WeakMap();
const zt = (r, e) => [r, e], _t = (r = "cmdKey") => a(() => () => !1, r), Pe = a({}, "commands"), pe = a([], "commandsTimer"), Q = w("CommandsReady"), ft = (r) => {
  const e = new gt();
  return r.inject(Pe, e).inject(pe, [j]).record(Q), async (t) => (await t.waitTimers(pe), t.done(Q), await t.wait(F), e.setCtx(t), (n) => {
    n.remove(Pe).remove(pe).clearTimer(Q);
  });
};
var Ct = /* @__PURE__ */ ((r) => (r.Idle = "Idle", r.OnCreate = "OnCreate", r.Created = "Created", r.OnDestroy = "OnDestroy", r.Destroyed = "Destroyed", r))(Ct || {}), y, R, N, S, D, p, M, z, U, X, Y, _, f;
const Re = class {
  constructor() {
    c(this, y, "Idle");
    c(this, R, []);
    c(this, N, () => {
    });
    c(this, S, be());
    c(this, D, _e());
    c(this, p, /* @__PURE__ */ new Map());
    c(this, M, new Le(o(this, S), o(this, D)));
    c(this, z, new Ae(o(this, S), o(this, D)));
    c(this, U, new We(o(this, S), o(this, D)));
    c(this, X, () => {
      const e = [
        ot,
        at,
        mt,
        ct,
        ft,
        lt,
        wt,
        it(this)
      ], t = rt(async (n) => {
        await Promise.all(o(this, R).map((s) => s(n)));
      });
      this.use(e.concat(t));
    });
    c(this, Y, () => {
      [...o(this, p).entries()].map(async ([e, t]) => {
        var s;
        const n = (s = t.handler) != null ? s : e(o(this, z));
        o(this, p).set(e, { ...t, handler: n });
      });
    });
    c(this, _, (e, t = !1) => Promise.all(
      [e].flat().map((n) => {
        const s = o(this, p).get(n), m = s == null ? void 0 : s.cleanup;
        if (t && o(this, p).delete(n), typeof m == "function")
          return m(o(this, U));
      })
    ));
    c(this, f, (e) => {
      V(this, y, e), o(this, N).call(this, e);
    });
    g(this, "use", (e) => ([e].flat().forEach((t) => {
      const n = o(this, y) === "Created" ? t(o(this, z)) : void 0;
      o(this, p).set(t, {
        handler: n,
        cleanup: void 0
      });
    }), this));
    g(this, "config", (e) => (o(this, R).push(e), this));
    g(this, "onStatusChange", (e) => (V(this, N, e), this));
    g(this, "create", async () => o(this, y) === "OnCreate" ? this : (o(this, y) === "Created" && await this.destroy(), o(this, f).call(this, "OnCreate"), o(this, X).call(this), o(this, Y).call(this), await Promise.all(
      [...o(this, p).entries()].map(async ([e, t]) => {
        const n = t.handler;
        if (!n)
          return;
        const s = await n(o(this, M));
        return o(this, p).set(e, { handler: n, cleanup: s }), s;
      })
    ), o(this, f).call(this, "Created"), this));
    g(this, "remove", async (e) => (await o(this, _).call(this, [e].flat(), !0), this));
    g(this, "destroy", async (e = !1) => o(this, y) === "Destroyed" || o(this, y) === "OnDestroy" ? this : (e && V(this, R, []), o(this, f).call(this, "OnDestroy"), await o(this, _).call(this, [...o(this, p).keys()], e), o(this, f).call(this, "Destroyed"), this));
    g(this, "action", (e) => e(o(this, M)));
  }
  static make() {
    return new Re();
  }
  get ctx() {
    return o(this, M);
  }
  get status() {
    return o(this, y);
  }
};
let Ve = Re;
y = new WeakMap(), R = new WeakMap(), N = new WeakMap(), S = new WeakMap(), D = new WeakMap(), p = new WeakMap(), M = new WeakMap(), z = new WeakMap(), U = new WeakMap(), X = new WeakMap(), Y = new WeakMap(), _ = new WeakMap(), f = new WeakMap();
export {
  gt as CommandManager,
  Q as CommandsReady,
  A as ConfigReady,
  Ve as Editor,
  H as EditorStateReady,
  Ct as EditorStatus,
  F as EditorViewReady,
  T as InitReady,
  B as ParserReady,
  j as SchemaReady,
  G as SerializerReady,
  W as ThemeEnvironmentReady,
  $ as ThemeReady,
  ft as commands,
  Pe as commandsCtx,
  pe as commandsTimerCtx,
  rt as config,
  zt as createCmd,
  _t as createCmdKey,
  me as defaultValueCtx,
  De as editorCtx,
  lt as editorState,
  b as editorStateCtx,
  ce as editorStateOptionsCtx,
  de as editorStateTimerCtx,
  wt as editorView,
  J as editorViewCtx,
  he as editorViewOptionsCtx,
  ue as editorViewTimerCtx,
  ht as getDoc,
  it as init,
  re as initTimerCtx,
  Ce as inputRulesCtx,
  je as markViewCtx,
  K as marksCtx,
  Te as nodeViewCtx,
  I as nodesCtx,
  mt as parser,
  q as parserCtx,
  se as parserTimerCtx,
  P as prosePluginsCtx,
  C as remarkCtx,
  ve as remarkPluginsCtx,
  st as remarkStringifyDefaultOptions,
  ne as remarkStringifyOptionsCtx,
  le as rootCtx,
  Oe as rootDOMCtx,
  at as schema,
  O as schemaCtx,
  oe as schemaTimerCtx,
  ct as serializer,
  ie as serializerCtx,
  ae as serializerTimerCtx,
  ot as themeEnvironment,
  Nt as themeFactory,
  te as themeTimerCtx
};
//# sourceMappingURL=index.es.js.map
