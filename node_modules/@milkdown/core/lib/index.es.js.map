{"version":3,"file":"index.es.js","sources":["../src/internal-plugin/config.ts","../src/internal-plugin/theme.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/internal-plugin/commands.ts","../src/editor/editor.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport type { CtxHandler, MilkdownPlugin } from '@milkdown/ctx'\nimport { createTimer } from '@milkdown/ctx'\n\nexport const ConfigReady = createTimer('ConfigReady')\n\nexport const config\n    = (configure: CtxHandler): MilkdownPlugin =>\n      (pre) => {\n        pre.record(ConfigReady)\n\n        return async (ctx) => {\n          await configure(ctx)\n          ctx.done(ConfigReady)\n\n          return (post) => {\n            post.clearTimer(ConfigReady)\n          }\n        }\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type {\n  Emotion,\n  ThemeManager,\n  ThemeSliceKey,\n} from '@milkdown/design-system'\nimport {\n  ThemeGlobal,\n  createThemeManager,\n  emotionConfigCtx,\n  emotionCtx,\n  initEmotion,\n  internalThemeKeys,\n  themeManagerCtx,\n} from '@milkdown/design-system'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport { ConfigReady } from './config'\nimport { InitReady, prosePluginsCtx } from './init'\n\nexport const themeTimerCtx = createSlice([] as Timer[], 'themeTimer')\nexport const ThemeEnvironmentReady = createTimer('ThemeEnvironmentReady')\nexport const ThemeReady = createTimer('ThemeReady')\n\nconst key = new PluginKey('MILKDOWN_THEME_RESET')\n\nexport const themeEnvironment: MilkdownPlugin = (pre) => {\n  const themeManager = createThemeManager()\n\n  pre.inject(emotionConfigCtx)\n    .inject(emotionCtx)\n    .inject(themeManagerCtx, themeManager)\n    .inject(themeTimerCtx, [ConfigReady])\n    .record(ThemeReady)\n    .record(ThemeEnvironmentReady)\n\n  return async (ctx) => {\n    await ctx.waitTimers(themeTimerCtx)\n    const emotion = initEmotion(ctx.get(emotionConfigCtx))\n\n    internalThemeKeys.forEach((key) => {\n      themeManager.inject(key as ThemeSliceKey)\n    })\n\n    ctx.set(emotionCtx, emotion)\n\n    ctx.done(ThemeEnvironmentReady)\n    ctx.done(ThemeReady)\n\n    await ctx.wait(InitReady)\n    ctx.update(prosePluginsCtx, xs =>\n      xs.concat(\n        new Plugin({\n          key,\n          view: () => {\n            themeManager.runExecutor()\n            return {\n              destroy: () => {\n                emotion.flush()\n              },\n            }\n          },\n        }),\n      ),\n    )\n\n    return (post) => {\n      post.remove(emotionConfigCtx)\n        .remove(emotionCtx)\n        .remove(themeManagerCtx)\n        .remove(themeTimerCtx)\n        .clearTimer(ThemeReady)\n        .clearTimer(ThemeEnvironmentReady)\n    }\n  }\n}\n\nexport type CreateThemePack = (emotion: Emotion, manager: ThemeManager) => void\nexport type ThemePlugin = MilkdownPlugin & {\n  override: (overrideFn: CreateThemePack) => ThemePlugin\n}\n\nexport const themeFactory = (createThemePack?: CreateThemePack): ThemePlugin => {\n  let overrideFn: CreateThemePack | null = null\n  const theme: ThemePlugin = () => async (ctx) => {\n    await ctx.wait(ThemeEnvironmentReady)\n    const emotion = ctx.get(emotionCtx)\n    const themeManager = ctx.get(themeManagerCtx)\n\n    themeManager.setExecutor(() => {\n      createThemePack?.(emotion, themeManager)\n      overrideFn?.(emotion, themeManager)\n\n      internalThemeKeys.forEach((key) => {\n        if (!themeManager.has(key as ThemeSliceKey))\n          console.warn('Theme key not found: ', key.sliceName)\n      })\n\n      themeManager.get(ThemeGlobal, undefined)\n    })\n  }\n  theme.override = (fn) => {\n    overrideFn = fn\n    return theme\n  }\n  return theme\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Slice, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport type { Plugin } from '@milkdown/prose/state'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\nimport type { RemarkParser, RemarkPlugin } from '@milkdown/transformer'\nimport remarkParse from 'remark-parse'\nimport type { Options } from 'remark-stringify'\nimport remarkStringify from 'remark-stringify'\nimport { unified } from 'unified'\n\nimport type { Editor } from '../editor'\nimport { ThemeReady } from './theme'\n\nexport const InitReady = createTimer('InitReady')\n\nexport const initTimerCtx = createSlice([] as Timer[], 'initTimer')\nexport const editorCtx = createSlice({} as Editor, 'editor')\n\nexport const inputRulesCtx = createSlice([] as InputRule[], 'inputRules')\nexport const prosePluginsCtx = createSlice([] as Plugin[], 'prosePlugins')\nexport const remarkPluginsCtx = createSlice([] as RemarkPlugin[], 'remarkPlugins')\n\ntype NodeView = [nodeId: string, view: NodeViewConstructor]\nexport const nodeViewCtx = createSlice([] as NodeView[], 'nodeView')\ntype MarkView = [nodeId: string, view: MarkViewConstructor]\nexport const markViewCtx = createSlice([] as MarkView[], 'markView')\n\nexport const remarkCtx: Slice<RemarkParser> = createSlice(unified().use(remarkParse).use(remarkStringify), 'remark')\nexport const remarkStringifyDefaultOptions: Options = {}\nexport const remarkStringifyOptionsCtx = createSlice(remarkStringifyDefaultOptions, 'remarkStringifyOptions')\n\nexport const init\n    = (editor: Editor): MilkdownPlugin =>\n      (pre) => {\n        pre.inject(editorCtx, editor)\n          .inject(prosePluginsCtx)\n          .inject(remarkPluginsCtx)\n          .inject(inputRulesCtx)\n          .inject(nodeViewCtx)\n          .inject(markViewCtx)\n          .inject(remarkStringifyOptionsCtx)\n          .inject(remarkCtx, unified().use(remarkParse).use(remarkStringify))\n          .inject(initTimerCtx, [ThemeReady])\n          .record(InitReady)\n\n        return async (ctx) => {\n          await ctx.waitTimers(initTimerCtx)\n          const options = ctx.get(remarkStringifyOptionsCtx)\n          ctx.set(remarkCtx, unified().use(remarkParse).use(remarkStringify, options))\n\n          ctx.done(InitReady)\n\n          return (post) => {\n            post.remove(editorCtx)\n              .remove(prosePluginsCtx)\n              .remove(remarkPluginsCtx)\n              .remove(inputRulesCtx)\n              .remove(nodeViewCtx)\n              .remove(markViewCtx)\n              .remove(remarkStringifyOptionsCtx)\n              .remove(remarkCtx)\n              .remove(initTimerCtx)\n              .clearTimer(InitReady)\n          }\n        }\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { MarkSpec, NodeSpec } from '@milkdown/prose/model'\nimport { Schema } from '@milkdown/prose/model'\nimport type {\n  MarkParserSpec,\n  MarkSerializerSpec,\n  NodeParserSpec,\n  NodeSerializerSpec,\n  RemarkParser,\n} from '@milkdown/transformer'\n\nimport { InitReady, remarkCtx, remarkPluginsCtx } from '.'\n\nexport const SchemaReady = createTimer('schemaReady')\n\nexport const schemaCtx = createSlice({} as Schema, 'schema')\nexport const schemaTimerCtx = createSlice([] as Timer[], 'schemaTimer')\n\nexport type NodeSchema = {\n  readonly toMarkdown: NodeSerializerSpec\n  readonly parseMarkdown: NodeParserSpec\n  readonly priority?: number\n} & Readonly<NodeSpec>\n\nexport const nodesCtx = createSlice([] as Array<[string, NodeSchema]>, 'nodes')\n\nexport type MarkSchema = {\n  readonly toMarkdown: MarkSerializerSpec\n  readonly parseMarkdown: MarkParserSpec\n} & Readonly<MarkSpec>\nexport const marksCtx = createSlice([] as Array<[string, MarkSchema]>, 'marks')\n\nconst extendPriority = <T extends NodeSchema | MarkSchema>(x: T): T => {\n  return {\n    ...x,\n    parseDOM: x.parseDOM?.map(rule => ({ priority: x.priority, ...rule })),\n  }\n}\n\nexport const schema: MilkdownPlugin = (pre) => {\n  pre.inject(schemaCtx).inject(nodesCtx).inject(marksCtx).inject(schemaTimerCtx, [InitReady]).record(SchemaReady)\n\n  return async (ctx) => {\n    await ctx.waitTimers(schemaTimerCtx)\n\n    const remark = ctx.get(remarkCtx)\n    const remarkPlugins = ctx.get(remarkPluginsCtx)\n\n    const processor = remarkPlugins.reduce((acc: RemarkParser, plug) => acc.use(plug), remark)\n    ctx.set(remarkCtx, processor)\n\n    const nodes = Object.fromEntries(ctx.get(nodesCtx).map(([key, x]) => [key, extendPriority(x)]))\n    const marks = Object.fromEntries(ctx.get(marksCtx).map(([key, x]) => [key, extendPriority(x)]))\n\n    ctx.set(\n      schemaCtx,\n      new Schema({\n        nodes,\n        marks,\n      }),\n    )\n\n    ctx.done(SchemaReady)\n\n    return (post) => {\n      post.remove(schemaCtx).remove(nodesCtx).remove(marksCtx).remove(schemaTimerCtx).clearTimer(SchemaReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { Node as ProsemirrorNode } from '@milkdown/prose/model'\nimport type { InnerParserSpecMap, ParserSpecWithType } from '@milkdown/transformer'\nimport { createParser } from '@milkdown/transformer'\n\nimport { remarkCtx } from './init'\nimport { SchemaReady, schemaCtx } from './schema'\nimport { marksCtx, nodesCtx } from '.'\n\nexport type Parser = (text: string) => ProsemirrorNode | undefined\n\nexport const parserCtx = createSlice((() => undefined) as Parser, 'parser')\nexport const parserTimerCtx = createSlice([] as Timer[], 'parserTimer')\n\nexport const ParserReady = createTimer('ParserReady')\n\nexport const parser: MilkdownPlugin = (pre) => {\n  pre.inject(parserCtx).inject(parserTimerCtx, [SchemaReady]).record(ParserReady)\n\n  return async (ctx) => {\n    await ctx.waitTimers(parserTimerCtx)\n    const nodes = ctx.get(nodesCtx)\n    const marks = ctx.get(marksCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    const children = [\n      ...nodes.map(([id, v]) => ({ id, ...v })).map(node => ({ ...node, is: 'node' as const })),\n      ...marks.map(([id, v]) => ({ id, ...v })).map(mark => ({ ...mark, is: 'mark' as const })),\n    ]\n    const spec: InnerParserSpecMap = Object.fromEntries(\n      children.map(({ id, parseMarkdown, is }) => [id, { ...parseMarkdown, is, key: id } as ParserSpecWithType]),\n    )\n\n    ctx.set(parserCtx, createParser(schema, spec, remark))\n    ctx.done(ParserReady)\n    return (post) => {\n      post.remove(parserCtx).remove(parserTimerCtx).clearTimer(ParserReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport type { Node as ProsemirrorNode } from '@milkdown/prose/model'\nimport { createSerializer } from '@milkdown/transformer'\n\nimport { remarkCtx } from './init'\nimport { SchemaReady, marksCtx, nodesCtx, schemaCtx } from './schema'\n\nexport const serializerCtx = createSlice<(node: ProsemirrorNode) => string, 'serializer'>(() => '', 'serializer')\nexport const serializerTimerCtx = createSlice([] as Timer[], 'serializerTimer')\n\nexport const SerializerReady = createTimer('SerializerReady')\n\nexport const serializer: MilkdownPlugin = (pre) => {\n  pre.inject(serializerCtx).inject(serializerTimerCtx, [SchemaReady]).record(SerializerReady)\n\n  return async (ctx) => {\n    await ctx.waitTimers(serializerTimerCtx)\n    const nodes = ctx.get(nodesCtx)\n    const marks = ctx.get(marksCtx)\n    const remark = ctx.get(remarkCtx)\n    const schema = ctx.get(schemaCtx)\n\n    const children = [...nodes, ...marks]\n    const spec = Object.fromEntries(children.map(([id, child]) => [id, child.toMarkdown]))\n\n    ctx.set(serializerCtx, createSerializer(schema, spec, remark))\n    ctx.done(SerializerReady)\n\n    return (post) => {\n      post.remove(serializerCtx).remove(serializerTimerCtx).clearTimer(SerializerReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { docTypeError } from '@milkdown/exception'\nimport { customInputRules as createInputRules } from '@milkdown/prose'\nimport { baseKeymap } from '@milkdown/prose/commands'\nimport { keymap as createKeymap } from '@milkdown/prose/keymap'\nimport type { Schema } from '@milkdown/prose/model'\nimport { DOMParser, Node } from '@milkdown/prose/model'\nimport { EditorState, Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { JSONRecord } from '@milkdown/transformer'\n\nimport { inputRulesCtx, prosePluginsCtx } from './init'\nimport type { Parser } from './parser'\nimport { ParserReady, parserCtx } from './parser'\nimport { schemaCtx } from './schema'\nimport { SerializerReady } from './serializer'\nimport { CommandsReady } from '.'\n\nexport type DefaultValue = string | { type: 'html'; dom: HTMLElement } | { type: 'json'; value: JSONRecord }\ntype StateOptions = Parameters<typeof EditorState.create>[0]\ntype StateOptionsOverride = (prev: StateOptions) => StateOptions\n\nexport const defaultValueCtx = createSlice('' as DefaultValue, 'defaultValue')\nexport const editorStateCtx = createSlice({} as EditorState, 'editorState')\nexport const editorStateOptionsCtx = createSlice<StateOptionsOverride>(x => x, 'stateOptions')\nexport const editorStateTimerCtx = createSlice([] as Timer[], 'editorStateTimer')\n\nexport const EditorStateReady = createTimer('EditorStateReady')\n\nconst key = new PluginKey('MILKDOWN_STATE_TRACKER')\n\nexport const getDoc = (defaultValue: DefaultValue, parser: Parser, schema: Schema) => {\n  if (typeof defaultValue === 'string')\n    return parser(defaultValue)\n\n  if (defaultValue.type === 'html')\n    return DOMParser.fromSchema(schema).parse(defaultValue.dom)\n\n  if (defaultValue.type === 'json')\n    return Node.fromJSON(schema, defaultValue.value)\n\n  throw docTypeError(defaultValue)\n}\n\nexport const editorState: MilkdownPlugin = (pre) => {\n  pre.inject(defaultValueCtx)\n    .inject(editorStateCtx)\n    .inject(editorStateOptionsCtx)\n    .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n    .record(EditorStateReady)\n\n  return async (ctx) => {\n    await ctx.waitTimers(editorStateTimerCtx)\n\n    const schema = ctx.get(schemaCtx)\n    const parser = ctx.get(parserCtx)\n    const rules = ctx.get(inputRulesCtx)\n    const optionsOverride = ctx.get(editorStateOptionsCtx)\n    const prosePlugins = ctx.get(prosePluginsCtx)\n    const defaultValue = ctx.get(defaultValueCtx)\n    const doc = getDoc(defaultValue, parser, schema)\n\n    const plugins = [\n      ...prosePlugins,\n      new Plugin({\n        key,\n        state: {\n          init: () => {\n            // do nothing\n          },\n          apply: (_tr, _value, _oldState, newState) => {\n            ctx.set(editorStateCtx, newState)\n          },\n        },\n      }),\n      createInputRules({ rules }),\n      createKeymap(baseKeymap),\n    ]\n\n    ctx.set(prosePluginsCtx, plugins)\n\n    const options = optionsOverride({\n      schema,\n      doc,\n      plugins,\n    })\n\n    const state = EditorState.create(options)\n    ctx.set(editorStateCtx, state)\n    ctx.done(EditorStateReady)\n\n    return (post) => {\n      post.remove(defaultValueCtx)\n        .remove(editorStateCtx)\n        .remove(editorStateOptionsCtx)\n        .remove(editorStateTimerCtx)\n        .clearTimer(EditorStateReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin, Timer } from '@milkdown/ctx'\nimport { createSlice, createTimer } from '@milkdown/ctx'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { DirectEditorProps } from '@milkdown/prose/view'\nimport { EditorView } from '@milkdown/prose/view'\n\nimport { EditorStateReady, editorStateCtx } from './editor-state'\nimport { InitReady, markViewCtx, nodeViewCtx, prosePluginsCtx } from './init'\n\ntype EditorOptions = Omit<DirectEditorProps, 'state'>\n\ntype RootType = Node | undefined | null | string\n\nexport const editorViewCtx = createSlice({} as EditorView, 'editorView')\nexport const editorViewOptionsCtx = createSlice({} as Partial<EditorOptions>, 'editorViewOptions')\nexport const rootCtx = createSlice(null as RootType, 'root')\nexport const editorViewTimerCtx = createSlice([] as Timer[], 'editorViewTimer')\nexport const rootDOMCtx = createSlice(null as unknown as HTMLElement, 'rootDOM')\n\nexport const EditorViewReady = createTimer('EditorViewReady')\n\nconst createViewContainer = (root: Node, ctx: Ctx) => {\n  const container = document.createElement('div')\n  container.className = 'milkdown'\n  root.appendChild(container)\n  ctx.set(rootDOMCtx, container)\n\n  return container\n}\n\nconst prepareViewDom = (dom: Element) => {\n  dom.classList.add('editor')\n  dom.setAttribute('role', 'textbox')\n}\n\nconst key = new PluginKey('MILKDOWN_VIEW_CLEAR')\n\nexport const editorView: MilkdownPlugin = (pre) => {\n  pre.inject(rootCtx, document.body)\n    .inject(editorViewCtx)\n    .inject(editorViewOptionsCtx)\n    .inject(rootDOMCtx)\n    .inject(editorViewTimerCtx, [EditorStateReady])\n    .record(EditorViewReady)\n\n  return async (ctx) => {\n    await ctx.wait(InitReady)\n\n    const root = ctx.get(rootCtx) || document.body\n    const el = typeof root === 'string' ? document.querySelector(root) : root\n\n    ctx.update(prosePluginsCtx, xs => [\n      new Plugin({\n        key,\n        view: (editorView) => {\n          const container = el ? createViewContainer(el, ctx) : undefined\n\n          const handleDOM = () => {\n            if (container && el) {\n              const editor = editorView.dom\n              el.replaceChild(container, editor)\n              container.appendChild(editor)\n            }\n          }\n          handleDOM()\n          return {\n            destroy: () => {\n              if (container?.parentNode)\n                container?.parentNode.replaceChild(editorView.dom, container)\n\n              container?.remove()\n            },\n          }\n        },\n      }),\n      ...xs,\n    ])\n\n    await ctx.waitTimers(editorViewTimerCtx)\n\n    const state = ctx.get(editorStateCtx)\n    const options = ctx.get(editorViewOptionsCtx)\n    const nodeViews = Object.fromEntries(ctx.get(nodeViewCtx))\n    const markViews = Object.fromEntries(ctx.get(markViewCtx))\n    const view = new EditorView(el as Node, {\n      state,\n      nodeViews,\n      markViews,\n      ...options,\n    })\n    prepareViewDom(view.dom)\n    ctx.set(editorViewCtx, view)\n    ctx.done(EditorViewReady)\n\n    return (post) => {\n      view?.destroy()\n      post.remove(rootCtx)\n        .remove(editorViewCtx)\n        .remove(editorViewOptionsCtx)\n        .remove(rootDOMCtx)\n        .remove(editorViewTimerCtx)\n        .clearTimer(EditorViewReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin, Slice, Timer } from '@milkdown/ctx'\nimport { createContainer, createSlice, createTimer } from '@milkdown/ctx'\nimport { callCommandBeforeEditorView } from '@milkdown/exception'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { EditorViewReady, editorViewCtx } from './editor-view'\nimport { SchemaReady } from './schema'\n\nexport type Cmd<T = undefined> = (payload?: T) => Command\nexport type CmdKey<T = undefined> = Slice<Cmd<T>>\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\nexport class CommandManager {\n  #container = createContainer()\n  #ctx: Ctx | null = null\n\n  setCtx = (ctx: Ctx) => {\n    this.#ctx = ctx\n  }\n\n  /**\n     * Create a command with provided key and command function.\n     *\n     * @param meta - The key of the command that needs to be created.\n     * @param value - The implementation of the command function.\n     */\n  create<T>(meta: CmdKey<T>, value: Cmd<T>) {\n    return meta(this.#container.sliceMap, value)\n  }\n\n  get<T extends CmdKey<any>>(slice: string): Cmd<InferParams<T>>\n  get<T>(slice: CmdKey<T>): Cmd<T>\n\n  get(slice: string | CmdKey<any>): Cmd<any>\n\n  get(slice: string | CmdKey<any>): Cmd<any> {\n    return this.#container.getSlice(slice).get()\n  }\n\n  call<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): boolean\n  call<T>(slice: CmdKey<T>, payload?: T): boolean\n\n  call(slice: string | CmdKey<any>, payload?: any): boolean\n\n  call(slice: string | CmdKey<any>, payload?: any): boolean {\n    if (this.#ctx == null)\n      throw callCommandBeforeEditorView()\n\n    const cmd = this.get(slice)\n    const command = cmd(payload)\n    const view = this.#ctx.get(editorViewCtx)\n    return command(view.state, view.dispatch, view)\n  }\n\n  remove<T extends CmdKey<any>>(slice: string): void\n  remove<T>(slice: CmdKey<T>): void\n\n  remove(slice: string | CmdKey<any>): void\n\n  remove(slice: string | CmdKey<any>): void {\n    return this.#container.removeSlice(slice)\n  }\n}\n\nexport type CmdTuple<T = unknown> = [key: CmdKey<T>, value: Cmd<T>]\n\nexport const createCmd = <T>(key: CmdKey<T>, value: Cmd<T>): CmdTuple => [key, value] as CmdTuple\nexport const createCmdKey = <T = undefined>(key = 'cmdKey'): CmdKey<T> =>\n  createSlice((() => () => false) as Cmd<T>, key)\n\nexport const commandsCtx = createSlice({} as CommandManager, 'commands')\n\nexport const commandsTimerCtx = createSlice([] as Timer[], 'commandsTimer')\nexport const CommandsReady = createTimer('CommandsReady')\n\nexport const commands: MilkdownPlugin = (pre) => {\n  const commandManager = new CommandManager()\n  pre.inject(commandsCtx, commandManager).inject(commandsTimerCtx, [SchemaReady]).record(CommandsReady)\n  return async (ctx) => {\n    await ctx.waitTimers(commandsTimerCtx)\n\n    ctx.done(CommandsReady)\n    await ctx.wait(EditorViewReady)\n    commandManager.setCtx(ctx)\n\n    return (post) => {\n      post.remove(commandsCtx).remove(commandsTimerCtx).clearTimer(CommandsReady)\n    }\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { CtxHandler, MilkdownPlugin } from '@milkdown/ctx'\nimport { Ctx, Post, Pre, createClock, createContainer } from '@milkdown/ctx'\n\nimport {\n  commands,\n  config,\n  editorState,\n  editorView,\n  init,\n  parser,\n  schema,\n  serializer,\n  themeEnvironment,\n} from '../internal-plugin'\n\nexport enum EditorStatus {\n  Idle = 'Idle',\n  OnCreate = 'OnCreate',\n  Created = 'Created',\n  OnDestroy = 'OnDestroy',\n  Destroyed = 'Destroyed',\n}\n\nexport type OnStatusChange = (status: EditorStatus) => void\n\n/**\n * Get the milkdown editor constructor\n */\nexport class Editor {\n  /**\n   * Create a new editor instance.\n   *\n   * @returns The new editor instance been created.\n   */\n  static make() {\n    return new Editor()\n  }\n\n  #status = EditorStatus.Idle\n  #configureList: CtxHandler[] = []\n  #onStatusChange: OnStatusChange = () => undefined\n\n  readonly #container = createContainer()\n  readonly #clock = createClock()\n\n  readonly #plugins: Map<\n    MilkdownPlugin,\n    { handler: CtxHandler | undefined; cleanup: ReturnType<CtxHandler> }\n  > = new Map()\n\n  readonly #ctx = new Ctx(this.#container, this.#clock)\n  readonly #pre = new Pre(this.#container, this.#clock)\n  readonly #post = new Post(this.#container, this.#clock)\n\n  readonly #loadInternal = () => {\n    const internalPlugins = [\n      themeEnvironment,\n      schema,\n      parser,\n      serializer,\n      commands,\n      editorState,\n      editorView,\n      init(this),\n    ]\n    const configPlugin = config(async (x: Ctx) => {\n      await Promise.all(this.#configureList.map(fn => fn(x)))\n    })\n    this.use(internalPlugins.concat(configPlugin))\n  }\n\n  readonly #prepare = () => {\n    [...this.#plugins.entries()].map(async ([key, loader]) => {\n      const handler = loader.handler ?? key(this.#pre)\n      this.#plugins.set(key, { ...loader, handler })\n    })\n  }\n\n  readonly #cleanup = (plugins: MilkdownPlugin[], remove = false) => {\n    return Promise.all(\n      [plugins].flat().map((plugin) => {\n        const loader = this.#plugins.get(plugin)\n        const cleanup = loader?.cleanup\n        if (remove)\n          this.#plugins.delete(plugin)\n\n        if (typeof cleanup === 'function')\n          return cleanup(this.#post)\n\n        return undefined\n      }),\n    )\n  }\n\n  readonly #setStatus = (status: EditorStatus) => {\n    this.#status = status\n    this.#onStatusChange(status)\n  }\n\n  /**\n   * Get the ctx of the editor.\n   */\n  get ctx() {\n    return this.#ctx\n  }\n\n  /**\n   * Get the status of the editor.\n   */\n  get status() {\n    return this.#status\n  }\n\n  /**\n   * Use one plugin or a list of plugins for current editor.\n   *\n   * @example\n   * ```typescript\n   * Editor.make()\n   *   .use(plugin)\n   *   .use([pluginA, pluginB])\n   * ```\n   *\n   * @param plugins - A list of plugins, or one plugin.\n   * @returns Editor instance.\n   */\n  readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n    [plugins].flat().forEach((plugin) => {\n      const handler\n        = this.#status === EditorStatus.Created ? plugin(this.#pre) : undefined\n      this.#plugins.set(plugin, {\n        handler,\n        cleanup: undefined,\n      })\n    })\n    return this\n  }\n\n  /**\n   * Config the context for current editor.\n   *\n   * @param configure - The function that configure current editor, can be async, with context as parameter.\n   * @returns Editor instance.\n   */\n  readonly config = (configure: CtxHandler) => {\n    this.#configureList.push(configure)\n    return this\n  }\n\n  /**\n   * Call when editor status changed.\n   *\n   * @param onChange - The function that will be called when the status of the editor changed.\n   * @returns Editor instance.\n   */\n  readonly onStatusChange = (onChange: OnStatusChange) => {\n    this.#onStatusChange = onChange\n    return this\n  }\n\n  /**\n   * Create the editor UI.\n   *\n   * @example\n   * ```typescript\n   * Editor.make().use(nord).use(commonmark).create()\n   * ```\n   *\n   * @returns A promise object, will be resolved as editor instance after create finish.\n   */\n  readonly create = async (): Promise<Editor> => {\n    if (this.#status === EditorStatus.OnCreate)\n      return this\n\n    if (this.#status === EditorStatus.Created)\n      await this.destroy()\n\n    this.#setStatus(EditorStatus.OnCreate)\n    this.#loadInternal()\n\n    this.#prepare()\n\n    await Promise.all(\n      [...this.#plugins.entries()].map(async ([key, loader]) => {\n        const handler = loader.handler\n        if (!handler)\n          return\n\n        const cleanup = await handler(this.#ctx)\n        this.#plugins.set(key, { handler, cleanup })\n\n        return cleanup\n      }),\n    )\n\n    this.#setStatus(EditorStatus.Created)\n    return this\n  }\n\n  /**\n   * Remove one plugin or a list of plugins from current editor.\n   *\n   * @param plugins - A list of plugins, or one plugin.\n   * @returns Editor instance.\n   */\n  readonly remove = async (\n    plugins: MilkdownPlugin | MilkdownPlugin[],\n  ): Promise<Editor> => {\n    await this.#cleanup([plugins].flat(), true)\n    return this\n  }\n\n  /**\n   * Destroy the editor.\n   *\n   * @example\n   * ```typescript\n   * const editor = await Editor.make().use(commonmark).create();\n   * await editor.destroy();\n   * ```\n   *\n   * @returns A promise object, will be resolved as editor instance after destroy finish.\n   */\n  readonly destroy = async (clearPlugins = false): Promise<Editor> => {\n    if (\n      this.#status === EditorStatus.Destroyed\n      || this.#status === EditorStatus.OnDestroy\n    )\n      return this\n\n    if (clearPlugins)\n      this.#configureList = []\n\n    this.#setStatus(EditorStatus.OnDestroy)\n    await this.#cleanup([...this.#plugins.keys()], clearPlugins)\n    this.#setStatus(EditorStatus.Destroyed)\n    return this\n  }\n\n  /**\n   * Get the context value in a running editor on demand and return the action result.\n   *\n   * @example\n   * ```typescript\n   * import { Editor, editorViewCtx, serializerCtx } from '@milkdown/core';\n   * async function playWithEditor() {\n   *     const editor = await Editor.make().use(commonmark).create();\n   *\n   *     const getMarkdown = () =>\n   *         editor.action((ctx) => {\n   *             const editorView = ctx.get(editorViewCtx);\n   *             const serializer = ctx.get(serializerCtx);\n   *             return serializer(editorView.state.doc);\n   *         });\n   *\n   *     // get markdown string:\n   *     getMarkdown();\n   * }\n   * ```\n   *\n   * @param action - The function that get editor context and return the action result.\n   * @returns The action result.\n   */\n  readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx)\n}\n"],"names":["ConfigReady","createTimer","config","configure","pre","ctx","post","themeTimerCtx","createSlice","ThemeEnvironmentReady","ThemeReady","key","PluginKey","themeEnvironment","themeManager","createThemeManager","emotionConfigCtx","emotionCtx","themeManagerCtx","emotion","initEmotion","internalThemeKeys","InitReady","prosePluginsCtx","xs","Plugin","themeFactory","createThemePack","overrideFn","theme","ThemeGlobal","fn","initTimerCtx","editorCtx","inputRulesCtx","remarkPluginsCtx","nodeViewCtx","markViewCtx","remarkCtx","unified","remarkParse","remarkStringify","remarkStringifyDefaultOptions","remarkStringifyOptionsCtx","init","editor","options","SchemaReady","schemaCtx","schemaTimerCtx","nodesCtx","marksCtx","extendPriority","x","_a","rule","schema","remark","processor","acc","plug","nodes","marks","Schema","parserCtx","parserTimerCtx","ParserReady","parser","children","id","v","node","mark","spec","parseMarkdown","is","createParser","serializerCtx","serializerTimerCtx","SerializerReady","serializer","child","createSerializer","defaultValueCtx","editorStateCtx","editorStateOptionsCtx","editorStateTimerCtx","EditorStateReady","getDoc","defaultValue","DOMParser","Node","docTypeError","editorState","CommandsReady","rules","optionsOverride","prosePlugins","doc","plugins","_tr","_value","_oldState","newState","createInputRules","createKeymap","baseKeymap","state","EditorState","editorViewCtx","editorViewOptionsCtx","rootCtx","editorViewTimerCtx","rootDOMCtx","EditorViewReady","createViewContainer","root","container","prepareViewDom","dom","editorView","el","nodeViews","markViews","view","EditorView","CommandManager","__privateAdd","_container","createContainer","_ctx","__publicField","__privateSet","meta","value","__privateGet","slice","payload","callCommandBeforeEditorView","command","createCmd","createCmdKey","commandsCtx","commandsTimerCtx","commands","commandManager","EditorStatus","_Editor","_status","_configureList","_onStatusChange","_clock","createClock","_plugins","Ctx","_pre","Pre","_post","Post","_loadInternal","internalPlugins","configPlugin","_prepare","loader","handler","_cleanup","remove","plugin","cleanup","_setStatus","status","onChange","clearPlugins","action","Editor"],"mappings":"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"}