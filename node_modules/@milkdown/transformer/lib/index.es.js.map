{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/stack.ts","../src/parser/state.ts","../src/parser/index.ts","../src/serializer/stack-element.ts","../src/serializer/stack.ts","../src/serializer/state.ts","../src/serializer/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { stackOverFlow } from '@milkdown/exception'\n\ninterface ElInstance<U> {\n  push: (node: U, ...rest: U[]) => void\n}\n\ninterface StackCtx<T extends ElInstance<U>, U> {\n  readonly elements: T[]\n}\n\nexport const getStackUtil = <Node, El extends ElInstance<Node>, Ctx extends StackCtx<El, Node>>() => {\n  const size = (ctx: Ctx): number => ctx.elements.length\n\n  const top = (ctx: Ctx): El | undefined => ctx.elements[size(ctx) - 1]\n\n  const push\n        = (ctx: Ctx) =>\n          (node: Node): void => {\n            top(ctx)?.push(node)\n          }\n\n  const open\n        = (ctx: Ctx) =>\n          (node: El): void => {\n            ctx.elements.push(node)\n          }\n\n  const close = (ctx: Ctx): El => {\n    const el = ctx.elements.pop()\n    if (!el)\n      throw stackOverFlow()\n\n    return el\n  }\n\n  return {\n    size,\n    top,\n    push,\n    open,\n    close,\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, NodeType } from '@milkdown/prose/model'\n\nimport type { Attrs } from './types'\n\nexport interface StackElement {\n  type: NodeType\n  content: Node[]\n  attrs?: Attrs\n  push: (node: Node, ...rest: Node[]) => void\n  pop: () => Node | undefined\n}\n\nconst pushElement = (element: StackElement, node: Node, ...rest: Node[]) => {\n  element.content.push(node, ...rest)\n}\n\nconst popElement = (element: StackElement): Node | undefined => element.content.pop()\n\nexport const createElement = (type: NodeType, content: Node[], attrs?: Attrs): StackElement => {\n  const element: StackElement = {\n    type,\n    content,\n    attrs,\n    push: (...args) => pushElement(element, ...args),\n    pop: () => popElement(element),\n  }\n  return element\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNodeInParserFail, stackOverFlow } from '@milkdown/exception'\nimport type { MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\nimport { Mark } from '@milkdown/prose/model'\n\nimport { getStackUtil } from '../utility'\nimport type { StackElement } from './stack-element'\nimport { createElement } from './stack-element'\nimport type { Attrs } from './types'\n\ninterface Ctx {\n  marks: readonly Mark[]\n  readonly schema: Schema\n  readonly elements: StackElement[]\n}\n\nconst { size, push, top, open, close } = getStackUtil<Node, StackElement, Ctx>()\n\nconst hasText = (node: Node): node is Node & { text: string } => node.isText\n\nconst maybeMerge = (schema: Schema, a: Node, b: Node): Node | undefined => {\n  if (hasText(a) && hasText(b) && Mark.sameSet(a.marks, b.marks))\n    return schema.text(a.text + b.text, a.marks)\n\n  return undefined\n}\n\nconst openNode = (ctx: Ctx) => (nodeType: NodeType, attrs?: Attrs) => open(ctx)(createElement(nodeType, [], attrs))\n\nconst addNode\n    = (ctx: Ctx) =>\n      (nodeType: NodeType, attrs?: Attrs, content?: Node[]): Node => {\n        const node = nodeType.createAndFill(attrs, content, ctx.marks)\n\n        if (!node)\n          throw createNodeInParserFail(nodeType, attrs, content)\n\n        push(ctx)(node)\n\n        return node\n      }\n\nconst closeNode = (ctx: Ctx) => (): Node => {\n  ctx.marks = Mark.none\n  const element = close(ctx)\n\n  return addNode(ctx)(element.type, element.attrs, element.content)\n}\n\nconst openMark\n    = (ctx: Ctx) =>\n      (markType: MarkType, attrs?: Attrs): void => {\n        const mark = markType.create(attrs)\n\n        ctx.marks = mark.addToSet(ctx.marks)\n      }\n\nconst closeMark\n    = (ctx: Ctx) =>\n      (markType: MarkType): void => {\n        ctx.marks = markType.removeFromSet(ctx.marks)\n      }\n\nconst addText\n    = (ctx: Ctx) =>\n      (text: string): void => {\n        const topElement = top(ctx)\n        if (!topElement)\n          throw stackOverFlow()\n\n        const prevNode = topElement.pop()\n        const currNode = ctx.schema.text(text, ctx.marks)\n\n        if (!prevNode) {\n          topElement.push(currNode)\n          return\n        }\n\n        const merged = maybeMerge(ctx.schema, prevNode, currNode)\n        if (merged) {\n          topElement.push(merged)\n          return\n        }\n        topElement.push(prevNode, currNode)\n      }\n\nconst build = (ctx: Ctx) => () => {\n  let doc: Node | undefined\n  do\n    doc = closeNode(ctx)()\n  while (size(ctx))\n\n  return doc\n}\n\nexport const createStack = (schema: Schema) => {\n  const ctx: Ctx = {\n    marks: [],\n    elements: [],\n    schema,\n  }\n\n  return {\n    build: build(ctx),\n    openMark: openMark(ctx),\n    closeMark: closeMark(ctx),\n    addText: addText(ctx),\n    openNode: openNode(ctx),\n    addNode: addNode(ctx),\n    closeNode: closeNode(ctx),\n  }\n}\n\nexport type Stack = ReturnType<typeof createStack>\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { parserMatchError } from '@milkdown/exception'\nimport type { MarkType, Node, NodeType, Schema } from '@milkdown/prose/model'\n\nimport type { RemarkParser } from '../utility'\nimport type { Stack } from './stack'\nimport type { Attrs, InnerParserSpecMap, MarkdownNode, ParserSpecWithType } from './types'\n\ntype PS<T extends keyof Stack> = Parameters<Stack[T]>\n\n/**\n * State for parser.\n * Transform remark AST into prosemirror state.\n */\nexport class State {\n  constructor(\n    private readonly stack: Stack,\n    public readonly schema: Schema,\n    private readonly specMap: InnerParserSpecMap,\n  ) {}\n\n  #matchTarget(node: MarkdownNode): ParserSpecWithType {\n    const result = Object.values(this.specMap).find(x => x.match(node))\n\n    if (!result)\n      throw parserMatchError(node)\n\n    return result\n  }\n\n  #runNode(node: MarkdownNode) {\n    const { key, runner, is } = this.#matchTarget(node)\n\n    const proseType: NodeType | MarkType = this.schema[is === 'node' ? 'nodes' : 'marks'][key] as\n            | NodeType\n            | MarkType\n\n    runner(this, node, proseType as NodeType & MarkType)\n  }\n\n  /**\n     * Transform a markdown string into prosemirror state.\n     *\n     * @param remark - The remark parser used.\n     * @param markdown - The markdown string needs to be parsed.\n     * @returns The state instance.\n     */\n  run = (remark: RemarkParser, markdown: string) => {\n    const tree = remark.runSync(remark.parse(markdown), markdown) as MarkdownNode\n    this.next(tree)\n\n    return this\n  }\n\n  /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n  next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n    [nodes].flat().forEach(node => this.#runNode(node))\n    return this\n  }\n\n  /**\n     * Parse current remark AST into prosemirror state.\n     *\n     * @returns Result prosemirror doc.\n     */\n  toDoc = (): Node => this.stack.build()\n\n  /**\n     * Inject root node for prosemirror state.\n     *\n     * @param node - The target markdown node.\n     * @param nodeType - The root prosemirror nodeType .\n     * @param attrs - The attribute of root type.\n     * @returns The state instance.\n     */\n  injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n    this.stack.openNode(nodeType, attrs)\n    this.next(node.children)\n\n    return this\n  }\n\n  /**\n     * Add a text type prosemirror node.\n     *\n     * @param text - Text string.\n     * @returns The state instance.\n     */\n  addText = (text = '') => {\n    this.stack.addText(text)\n    return this\n  }\n\n  /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     * @param content - Content of this node.\n     *\n     * @returns The added node.\n     */\n  addNode = (...args: PS<'addNode'>) => {\n    this.stack.addNode(...args)\n    return this\n  }\n\n  /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     *\n     * @returns\n     */\n  openNode = (...args: PS<'openNode'>) => {\n    this.stack.openNode(...args)\n    return this\n  }\n\n  /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n  closeNode = (...args: PS<'closeNode'>) => {\n    this.stack.closeNode(...args)\n    return this\n  }\n\n  /**\n     * Open a mark, and all marks created after this method will be set as the children of the mark until a `closeMark` been called.\n     *\n     * @remarks\n     * You can imagine `openMark` as the left half of parenthesis and `closeMark` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param markType - Mark type of this mark.\n     * @param attrs - Attributes of this mark.\n     *\n     * @returns\n     */\n  openMark = (...args: PS<'openMark'>) => {\n    this.stack.openMark(...args)\n    return this\n  }\n\n  /**\n     * Close target mark.\n     *\n     * @param markType - Mark type of this mark.\n     *\n     * @returns The mark closed.\n     */\n  closeMark = (...args: PS<'closeMark'>) => {\n    this.stack.closeMark(...args)\n    return this\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, Schema } from '@milkdown/prose/model'\n\nimport type { RemarkParser } from '../utility'\nimport { createStack } from './stack'\nimport { State } from './state'\nimport type { InnerParserSpecMap } from './types'\n\nexport const createParser = (schema: Schema, specMap: InnerParserSpecMap, remark: RemarkParser) => {\n  const state = new State(createStack(schema), schema, specMap)\n  return (text: string): Node => {\n    state.run(remark, text)\n    return state.toDoc()\n  }\n}\n\nexport * from './types'\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\n\nexport interface StackElement {\n  type: string\n  value?: string\n  props: JSONRecord\n  children?: MarkdownNode[]\n  push: (node: MarkdownNode, ...rest: MarkdownNode[]) => void\n  pop: () => MarkdownNode | undefined\n}\n\nconst pushElement = (element: StackElement, node: MarkdownNode, ...rest: MarkdownNode[]) => {\n  if (!element.children)\n    element.children = []\n\n  element.children.push(node, ...rest)\n}\n\nconst popElement = (element: StackElement): MarkdownNode | undefined => element.children?.pop()\n\nexport const createElement = (\n  type: string,\n  children?: MarkdownNode[],\n  value?: string,\n  props: JSONRecord = {},\n): StackElement => {\n  const element: StackElement = {\n    type,\n    children,\n    props,\n    value,\n    push: (...args) => pushElement(element, ...args),\n    pop: () => popElement(element),\n  }\n  return element\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Mark } from '@milkdown/prose/model'\nimport type { Root } from 'mdast'\n\nimport type { MarkdownNode } from '..'\nimport type { JSONRecord } from '../utility'\nimport { getStackUtil } from '../utility'\nimport type { StackElement } from './stack-element'\nimport { createElement } from './stack-element'\n\ninterface Ctx {\n  marks: readonly Mark[]\n  readonly elements: StackElement[]\n}\n\nconst { size, push, open, close } = getStackUtil<MarkdownNode, StackElement, Ctx>()\n\nconst searchType = (child: MarkdownNode, type: string): MarkdownNode => {\n  if (child.type === type)\n    return child\n\n  if (child.children?.length !== 1)\n    return child\n\n  const searchNode = (node: MarkdownNode): MarkdownNode | null => {\n    if (node.type === type)\n      return node\n\n    if (node.children?.length !== 1)\n      return null\n\n    const [firstChild] = node.children\n    if (!firstChild)\n      return null\n\n    return searchNode(firstChild)\n  }\n\n  const target = searchNode(child)\n\n  if (!target)\n    return child\n\n  const tmp = target.children ? [...target.children] : undefined\n  const node = { ...child, children: tmp }\n  node.children = tmp\n  target.children = [node]\n\n  return target\n}\n\nconst maybeMergeChildren = (element: MarkdownNode) => {\n  const { children } = element\n  if (!children)\n    return element\n\n  element.children = children.reduce((nextChildren, child, index) => {\n    if (index === 0)\n      return [child]\n\n    const last = nextChildren[nextChildren.length - 1]\n    if (last && last.isMark && child.isMark) {\n      child = searchType(child, last.type)\n      const { children: currChildren, ...currRest } = child\n      const { children: prevChildren, ...prevRest } = last\n      if (\n        child.type === last.type\n                && currChildren\n                && prevChildren\n                && JSON.stringify(currRest) === JSON.stringify(prevRest)\n      ) {\n        const next = {\n          ...prevRest,\n          children: [...prevChildren, ...currChildren],\n        }\n        return nextChildren.slice(0, -1).concat(maybeMergeChildren(next))\n      }\n    }\n    return nextChildren.concat(child)\n  }, [] as MarkdownNode[])\n\n  return element\n}\n\nconst createMarkdownNode = (element: StackElement) => {\n  const node: MarkdownNode = {\n    ...element.props,\n    type: element.type,\n  }\n\n  if (element.children)\n    node.children = element.children\n\n  if (element.value)\n    node.value = element.value\n\n  return node\n}\n\nconst openNode\n    = (ctx: Ctx) =>\n      (type: string, value?: string, props?: JSONRecord): void =>\n        open(ctx)(createElement(type, [], value, props))\n\nconst addNode\n    = (ctx: Ctx) =>\n      (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord): MarkdownNode => {\n        const element = createElement(type, children, value, props)\n        const node: MarkdownNode = maybeMergeChildren(createMarkdownNode(element))\n\n        push(ctx)(node)\n\n        return node\n      }\n\nconst closeNode = (ctx: Ctx) => (): MarkdownNode => {\n  const element = close(ctx)\n\n  return addNode(ctx)(element.type, element.children, element.value, element.props)\n}\n\nconst openMark\n    = (ctx: Ctx) =>\n      (mark: Mark, type: string, value?: string, props?: JSONRecord): void => {\n        const isIn = mark.isInSet(ctx.marks)\n\n        if (isIn)\n          return\n\n        ctx.marks = mark.addToSet(ctx.marks)\n        openNode(ctx)(type, value, { ...props, isMark: true })\n      }\n\nconst closeMark\n    = (ctx: Ctx) =>\n      (mark: Mark): MarkdownNode | null => {\n        if (!mark.isInSet(ctx.marks))\n          return null\n        ctx.marks = mark.type.removeFromSet(ctx.marks)\n        return closeNode(ctx)()\n      }\n\nconst build = (ctx: Ctx) => () => {\n  let doc: Root | null = null\n  do\n    doc = closeNode(ctx)() as Root\n  while (size(ctx))\n\n  return doc\n}\n\nexport interface Stack {\n  /**\n     * Build the remark AST tree with current stack.\n     *\n     * @returns A remark AST tree.\n     */\n  build: () => Root\n\n  /**\n     * Open a mark.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns\n     */\n  openMark: (mark: Mark, type: string, value?: string, props?: JSONRecord) => void\n\n  /**\n     * Close current mark.\n     * @param mark - The prosemirror mark of target mark to be closed.\n     *\n     * @returns The mark closed, will be null if not exists.\n     */\n  closeMark: (mark: Mark) => MarkdownNode | null\n\n  /**\n     * Open a node.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns\n     */\n  openNode: (type: string, value?: string, props?: JSONRecord) => void\n\n  /**\n     * Add a node in current position.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n  addNode: (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord) => MarkdownNode\n\n  /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n  closeNode: () => MarkdownNode\n}\n\nexport const createStack = (): Stack => {\n  const ctx: Ctx = {\n    marks: [],\n    elements: [],\n  }\n\n  return {\n    build: build(ctx),\n    openMark: openMark(ctx),\n    closeMark: closeMark(ctx),\n    openNode: openNode(ctx),\n    addNode: addNode(ctx),\n    closeNode: closeNode(ctx),\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { serializerMatchError } from '@milkdown/exception'\nimport type { Fragment, Mark as ProseMark, Node as ProseNode, Schema } from '@milkdown/prose/model'\n\nimport type { RemarkParser } from '../utility'\nimport type { Stack } from './stack'\nimport type { InnerSerializerSpecMap, MarkSerializerSpec, NodeSerializerSpec } from './types'\n\nconst isFragment = (x: ProseNode | Fragment): x is Fragment => Object.prototype.hasOwnProperty.call(x, 'size')\n\ntype StateMethod<T extends keyof Stack> = (...args: Parameters<Stack[T]>) => State\n\n/**\n * State for serializer.\n * Transform prosemirror state into remark AST.\n */\nexport class State {\n  constructor(\n    private readonly stack: Stack,\n    public readonly schema: Schema,\n    private readonly specMap: InnerSerializerSpecMap,\n  ) {}\n\n  #matchTarget<T extends ProseMark | ProseNode>(\n    node: T,\n  ): (T extends ProseNode ? NodeSerializerSpec : MarkSerializerSpec) & { key: string } {\n    const result = Object.entries(this.specMap)\n      .map(([key, spec]) => ({\n        key,\n        ...spec,\n      }))\n      .find(x => x.match(node as ProseMark & ProseNode))\n\n    if (!result)\n      throw serializerMatchError(node.type)\n\n    return result as never\n  }\n\n  #runProseNode(node: ProseNode) {\n    const { runner } = this.#matchTarget(node)\n    runner(this, node)\n  }\n\n  #runProseMark(mark: ProseMark, node: ProseNode) {\n    const { runner } = this.#matchTarget(mark)\n    return runner(this, mark, node)\n  }\n\n  #runNode(node: ProseNode) {\n    const { marks } = node\n    const getPriority = (x: ProseMark) => x.type.spec.priority ?? 50\n    const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b))\n    const unPreventNext = tmp.every(mark => !this.#runProseMark(mark, node))\n    if (unPreventNext)\n      this.#runProseNode(node)\n\n    marks.forEach(mark => this.stack.closeMark(mark))\n  }\n\n  /**\n     * Transform a prosemirror node tree into remark AST.\n     *\n     * @param tree - The prosemirror node tree needs to be transformed.\n     *\n     * @returns The state instance.\n     */\n  run(tree: ProseNode) {\n    this.next(tree)\n\n    return this\n  }\n\n  /**\n     * Use a remark parser to serialize current AST stored.\n     *\n     * @param remark - The remark parser needs to used.\n     * @returns Result markdown string.\n     */\n  toString = (remark: RemarkParser): string => remark.stringify(this.stack.build()) as string\n\n  /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n  next = (nodes: ProseNode | Fragment) => {\n    if (isFragment(nodes)) {\n      nodes.forEach((node) => {\n        this.#runNode(node)\n      })\n      return this\n    }\n    this.#runNode(nodes)\n    return this\n  }\n\n  /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n  addNode: StateMethod<'addNode'> = (...args) => {\n    this.stack.addNode(...args)\n    return this\n  }\n\n  /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The state instance.\n     */\n  openNode: StateMethod<'openNode'> = (...args) => {\n    this.stack.openNode(...args)\n    return this\n  }\n\n  /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n  closeNode: StateMethod<'closeNode'> = (...args) => {\n    this.stack.closeNode(...args)\n    return this\n  }\n\n  /**\n     * Used when current node has marks, the serializer will auto combine marks nearby.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns The state instance.\n     */\n  withMark: StateMethod<'openMark'> = (...args) => {\n    this.stack.openMark(...args)\n    return this\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, Schema } from '@milkdown/prose/model'\n\nimport type { RemarkParser } from '../utility'\nimport { createStack } from './stack'\nimport { State } from './state'\nimport type { InnerSerializerSpecMap } from './types'\n\nexport const createSerializer\n    = (schema: Schema, specMap: InnerSerializerSpecMap, remark: RemarkParser) => (content: Node) => {\n      const state = new State(createStack(), schema, specMap)\n      state.run(content)\n      return state.toString(remark)\n    }\n\nexport * from './types'\n"],"names":["getStackUtil","size","ctx","top","node","_a","el","stackOverFlow","pushElement","element","rest","popElement","createElement","type","content","attrs","args","push","open","close","hasText","maybeMerge","schema","a","b","Mark","openNode","nodeType","addNode","createNodeInParserFail","closeNode","openMark","markType","mark","closeMark","addText","text","topElement","prevNode","currNode","merged","build","doc","createStack","State","stack","specMap","__privateAdd","_matchTarget","_runNode","__publicField","remark","markdown","tree","nodes","__privateMethod","runNode_fn","matchTarget_fn","result","x","parserMatchError","key","runner","is","proseType","createParser","state","children","value","props","searchType","child","searchNode","firstChild","target","tmp","maybeMergeChildren","nextChildren","index","last","currChildren","currRest","prevChildren","prevRest","next","createMarkdownNode","isFragment","_runProseNode","_runProseMark","spec","serializerMatchError","runProseNode_fn","runProseMark_fn","marks","getPriority","createSerializer"],"mappings":"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"}