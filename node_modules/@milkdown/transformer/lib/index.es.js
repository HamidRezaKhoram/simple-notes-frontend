var A = Object.defineProperty;
var C = (e, t, r) => t in e ? A(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var i = (e, t, r) => (C(e, typeof t != "symbol" ? t + "" : t, r), r), U = (e, t, r) => {
  if (!t.has(e))
    throw TypeError("Cannot " + r);
};
var u = (e, t, r) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, r);
};
var h = (e, t, r) => (U(e, t, "access private method"), r);
import { stackOverFlow as $, createNodeInParserFail as q, parserMatchError as x, serializerMatchError as B } from "@milkdown/exception";
import { Mark as w } from "@milkdown/prose/model";
const E = () => {
  const e = (o) => o.elements.length, t = (o) => o.elements[e(o) - 1];
  return {
    size: e,
    top: t,
    push: (o) => (c) => {
      var a;
      (a = t(o)) == null || a.push(c);
    },
    open: (o) => (c) => {
      o.elements.push(c);
    },
    close: (o) => {
      const c = o.elements.pop();
      if (!c)
        throw $();
      return c;
    }
  };
}, G = (e, t, ...r) => {
  e.content.push(t, ...r);
}, H = (e) => e.content.pop(), K = (e, t, r) => {
  const s = {
    type: e,
    content: t,
    attrs: r,
    push: (...n) => G(s, ...n),
    pop: () => H(s)
  };
  return s;
}, { size: L, push: Q, top: V, open: W, close: X } = E(), v = (e) => e.isText, Y = (e, t, r) => {
  if (v(t) && v(r) && w.sameSet(t.marks, r.marks))
    return e.text(t.text + r.text, t.marks);
}, Z = (e) => (t, r) => W(e)(K(t, [], r)), T = (e) => (t, r, s) => {
  const n = t.createAndFill(r, s, e.marks);
  if (!n)
    throw q(t, r, s);
  return Q(e)(n), n;
}, b = (e) => () => {
  e.marks = w.none;
  const t = X(e);
  return T(e)(t.type, t.attrs, t.content);
}, _ = (e) => (t, r) => {
  const s = t.create(r);
  e.marks = s.addToSet(e.marks);
}, tt = (e) => (t) => {
  e.marks = t.removeFromSet(e.marks);
}, et = (e) => (t) => {
  const r = V(e);
  if (!r)
    throw $();
  const s = r.pop(), n = e.schema.text(t, e.marks);
  if (!s) {
    r.push(n);
    return;
  }
  const o = Y(e.schema, s, n);
  if (o) {
    r.push(o);
    return;
  }
  r.push(s, n);
}, rt = (e) => () => {
  let t;
  do
    t = b(e)();
  while (L(e));
  return t;
}, st = (e) => {
  const t = {
    marks: [],
    elements: [],
    schema: e
  };
  return {
    build: rt(t),
    openMark: _(t),
    closeMark: tt(t),
    addText: et(t),
    openNode: Z(t),
    addNode: T(t),
    closeNode: b(t)
  };
};
var m, P, f, z;
class nt {
  constructor(t, r, s) {
    u(this, m);
    u(this, f);
    i(this, "run", (t, r) => {
      const s = t.runSync(t.parse(r), r);
      return this.next(s), this;
    });
    i(this, "next", (t = []) => ([t].flat().forEach((r) => h(this, f, z).call(this, r)), this));
    i(this, "toDoc", () => this.stack.build());
    i(this, "injectRoot", (t, r, s) => (this.stack.openNode(r, s), this.next(t.children), this));
    i(this, "addText", (t = "") => (this.stack.addText(t), this));
    i(this, "addNode", (...t) => (this.stack.addNode(...t), this));
    i(this, "openNode", (...t) => (this.stack.openNode(...t), this));
    i(this, "closeNode", (...t) => (this.stack.closeNode(...t), this));
    i(this, "openMark", (...t) => (this.stack.openMark(...t), this));
    i(this, "closeMark", (...t) => (this.stack.closeMark(...t), this));
    this.stack = t, this.schema = r, this.specMap = s;
  }
}
m = new WeakSet(), P = function(t) {
  const r = Object.values(this.specMap).find((s) => s.match(t));
  if (!r)
    throw x(t);
  return r;
}, f = new WeakSet(), z = function(t) {
  const { key: r, runner: s, is: n } = h(this, m, P).call(this, t), o = this.schema[n === "node" ? "nodes" : "marks"][r];
  s(this, t, o);
};
const vt = (e, t, r) => {
  const s = new nt(st(e), e, t);
  return (n) => (s.run(r, n), s.toDoc());
}, ot = (e, t, ...r) => {
  e.children || (e.children = []), e.children.push(t, ...r);
}, ct = (e) => {
  var t;
  return (t = e.children) == null ? void 0 : t.pop();
}, O = (e, t, r, s = {}) => {
  const n = {
    type: e,
    children: t,
    props: s,
    value: r,
    push: (...o) => ot(n, ...o),
    pop: () => ct(n)
  };
  return n;
}, { size: it, push: at, open: ht, close: ut } = E(), pt = (e, t) => {
  var c;
  if (e.type === t || ((c = e.children) == null ? void 0 : c.length) !== 1)
    return e;
  const r = (a) => {
    var d;
    if (a.type === t)
      return a;
    if (((d = a.children) == null ? void 0 : d.length) !== 1)
      return null;
    const [p] = a.children;
    return p ? r(p) : null;
  }, s = r(e);
  if (!s)
    return e;
  const n = s.children ? [...s.children] : void 0, o = { ...e, children: n };
  return o.children = n, s.children = [o], s;
}, F = (e) => {
  const { children: t } = e;
  return t && (e.children = t.reduce((r, s, n) => {
    if (n === 0)
      return [s];
    const o = r[r.length - 1];
    if (o && o.isMark && s.isMark) {
      s = pt(s, o.type);
      const { children: c, ...a } = s, { children: p, ...d } = o;
      if (s.type === o.type && c && p && JSON.stringify(a) === JSON.stringify(d)) {
        const J = {
          ...d,
          children: [...p, ...c]
        };
        return r.slice(0, -1).concat(F(J));
      }
    }
    return r.concat(s);
  }, [])), e;
}, dt = (e) => {
  const t = {
    ...e.props,
    type: e.type
  };
  return e.children && (t.children = e.children), e.value && (t.value = e.value), t;
}, I = (e) => (t, r, s) => ht(e)(O(t, [], r, s)), j = (e) => (t, r, s, n) => {
  const o = O(t, r, s, n), c = F(dt(o));
  return at(e)(c), c;
}, S = (e) => () => {
  const t = ut(e);
  return j(e)(t.type, t.children, t.value, t.props);
}, lt = (e) => (t, r, s, n) => {
  t.isInSet(e.marks) || (e.marks = t.addToSet(e.marks), I(e)(r, s, { ...n, isMark: !0 }));
}, kt = (e) => (t) => t.isInSet(e.marks) ? (e.marks = t.type.removeFromSet(e.marks), S(e)()) : null, mt = (e) => () => {
  let t = null;
  do
    t = S(e)();
  while (it(e));
  return t;
}, ft = () => {
  const e = {
    marks: [],
    elements: []
  };
  return {
    build: mt(e),
    openMark: lt(e),
    closeMark: kt(e),
    openNode: I(e),
    addNode: j(e),
    closeNode: S(e)
  };
}, Nt = (e) => Object.prototype.hasOwnProperty.call(e, "size");
var l, y, N, R, M, D, k, g;
class Mt {
  constructor(t, r, s) {
    u(this, l);
    u(this, N);
    u(this, M);
    u(this, k);
    i(this, "toString", (t) => t.stringify(this.stack.build()));
    i(this, "next", (t) => Nt(t) ? (t.forEach((r) => {
      h(this, k, g).call(this, r);
    }), this) : (h(this, k, g).call(this, t), this));
    i(this, "addNode", (...t) => (this.stack.addNode(...t), this));
    i(this, "openNode", (...t) => (this.stack.openNode(...t), this));
    i(this, "closeNode", (...t) => (this.stack.closeNode(...t), this));
    i(this, "withMark", (...t) => (this.stack.openMark(...t), this));
    this.stack = t, this.schema = r, this.specMap = s;
  }
  run(t) {
    return this.next(t), this;
  }
}
l = new WeakSet(), y = function(t) {
  const r = Object.entries(this.specMap).map(([s, n]) => ({
    key: s,
    ...n
  })).find((s) => s.match(t));
  if (!r)
    throw B(t.type);
  return r;
}, N = new WeakSet(), R = function(t) {
  const { runner: r } = h(this, l, y).call(this, t);
  r(this, t);
}, M = new WeakSet(), D = function(t, r) {
  const { runner: s } = h(this, l, y).call(this, t);
  return s(this, t, r);
}, k = new WeakSet(), g = function(t) {
  const { marks: r } = t, s = (c) => {
    var a;
    return (a = c.type.spec.priority) != null ? a : 50;
  };
  [...r].sort((c, a) => s(c) - s(a)).every((c) => !h(this, M, D).call(this, c, t)) && h(this, N, R).call(this, t), r.forEach((c) => this.stack.closeMark(c));
};
const $t = (e, t, r) => (s) => {
  const n = new Mt(ft(), e, t);
  return n.run(s), n.toString(r);
};
export {
  vt as createParser,
  $t as createSerializer,
  E as getStackUtil
};
//# sourceMappingURL=index.es.js.map
