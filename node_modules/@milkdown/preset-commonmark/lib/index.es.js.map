{"version":3,"file":"index.es.js","sources":["../src/supported-keys.ts","../src/mark/code-inline.ts","../src/mark/em.ts","../src/mark/link.ts","../src/mark/strong.ts","../src/mark/index.ts","../src/node/blockquote.ts","../src/node/bullet-list.ts","../src/node/code-fence.ts","../src/node/doc.ts","../src/node/hardbreak.ts","../src/node/heading.ts","../src/node/hr.ts","../src/node/image.ts","../src/node/list-item.ts","../src/node/ordered-list.ts","../src/node/paragraph.ts","../src/node/text.ts","../src/node/index.ts","../src/plugin/add-order-in-list.ts","../src/plugin/filter-html.ts","../src/plugin/inline-nodes-cursor.ts","../src/plugin/inline-sync/regexp.ts","../src/plugin/inline-sync/utils.ts","../src/plugin/inline-sync/config.ts","../src/plugin/inline-sync/context.ts","../src/plugin/inline-sync/replacer.ts","../src/plugin/inline-sync/index.ts","../src/plugin/index.ts","../src/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nexport const SupportedKeys = {\n  HardBreak: 'HardBreak',\n  Blockquote: 'Blockquote',\n  BulletList: 'BulletList',\n  OrderedList: 'OrderedList',\n  CodeFence: 'CodeFence',\n  H1: 'H1',\n  H2: 'H2',\n  H3: 'H3',\n  H4: 'H4',\n  H5: 'H5',\n  H6: 'H6',\n  DowngradeHeading: 'DowngradeHeading',\n  Text: 'Text',\n  CodeInline: 'CodeInline',\n  Em: 'Em',\n  Bold: 'Bold',\n  NextListItem: 'NextListItem',\n  SinkListItem: 'SinkListItem',\n  LiftListItem: 'LiftListItem',\n} as const\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type SupportedKeys = typeof SupportedKeys\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport type { MarkType } from '@milkdown/prose/model'\nimport { createMark, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['CodeInline']\nconst id = 'code_inline'\n\nexport const ToggleInlineCode = createCmdKey('ToggleInlineCode')\n\nexport const codeInline = createMark<Keys>((utils) => {\n  return {\n    id,\n    schema: () => ({\n      priority: 100,\n      code: true,\n      inclusive: false,\n      parseDOM: [{ tag: 'code' }],\n      toDOM: mark => ['code', { class: utils.getClassName(mark.attrs, 'code-inline') }],\n      parseMarkdown: {\n        match: node => node.type === 'inlineCode',\n        runner: (state, node, markType) => {\n          state.openMark(markType)\n          state.addText(node.value as string)\n          state.closeMark(markType)\n        },\n      },\n      toMarkdown: {\n        match: mark => mark.type.name === id,\n        runner: (state, mark, node) => {\n          state.withMark(mark, 'inlineCode', node.text || '')\n        },\n      },\n    }),\n    commands: markType => [\n      createCmd(ToggleInlineCode, () => (state, dispatch) => {\n        const { selection, tr } = state\n        if (selection.empty)\n          return false\n        const { from, to } = selection\n\n        const has = state.doc.rangeHasMark(from, to, markType)\n        if (has) {\n          dispatch?.(tr.removeMark(from, to, markType))\n          return true\n        }\n\n        const restMarksName = Object.keys(state.schema.marks).filter(x => x !== markType.name)\n\n        restMarksName\n          .map(name => state.schema.marks[name] as MarkType)\n          .forEach((t) => {\n            tr.removeMark(from, to, t)\n          })\n\n        dispatch?.(tr.addMark(from, to, markType.create()))\n        return true\n      }),\n    ],\n    shortcuts: {\n      [SupportedKeys.CodeInline]: createShortcut(ToggleInlineCode, 'Mod-e'),\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { createMark, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['Em']\n\nconst id = 'em'\n\nexport const ToggleItalic = createCmdKey('ToggleItalic')\nexport const em = createMark<Keys>(utils => ({\n  id,\n  schema: () => ({\n    inclusive: false,\n    parseDOM: [\n      { tag: 'i' },\n      { tag: 'em' },\n      { style: 'font-style', getAttrs: value => (value === 'italic') as false },\n    ],\n    toDOM: mark => ['em', { class: utils.getClassName(mark.attrs, id) }],\n    parseMarkdown: {\n      match: node => node.type === 'emphasis',\n      runner: (state, node, markType) => {\n        state.openMark(markType)\n        state.next(node.children)\n        state.closeMark(markType)\n      },\n    },\n    toMarkdown: {\n      match: mark => mark.type.name === id,\n      runner: (state, mark) => {\n        state.withMark(mark, 'emphasis')\n      },\n    },\n  }),\n  commands: markType => [createCmd(ToggleItalic, () => toggleMark(markType))],\n  shortcuts: {\n    [SupportedKeys.Em]: createShortcut(ToggleItalic, 'Mod-i'),\n  },\n}))\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { ThemeInputChipType } from '@milkdown/core'\nimport { commandsCtx, createCmd, createCmdKey } from '@milkdown/core'\nimport { expectDomTypeError, missingRootElement } from '@milkdown/exception'\nimport { calculateTextPosition } from '@milkdown/prose'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport type { Node as ProseNode } from '@milkdown/prose/model'\nimport { NodeSelection, Plugin, PluginKey, TextSelection } from '@milkdown/prose/state'\nimport type { EditorView } from '@milkdown/prose/view'\nimport { createMark } from '@milkdown/utils'\n\nconst key = new PluginKey('MILKDOWN_LINK_INPUT')\n\nexport const ToggleLink = createCmdKey<string>('ToggleLink')\nexport const ModifyLink = createCmdKey<string>('ModifyLink')\nconst id = 'link'\nexport interface LinkOptions {\n  input: {\n    placeholder?: string\n    buttonText?: string\n    displayWhenSelected?: boolean\n  }\n}\nexport const link = createMark<string, LinkOptions>((utils, options) => {\n  return {\n    id,\n    schema: () => ({\n      attrs: {\n        href: {},\n        title: { default: null },\n      },\n      parseDOM: [\n        {\n          tag: 'a[href]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return { href: dom.getAttribute('href'), title: dom.getAttribute('title') }\n          },\n        },\n      ],\n      toDOM: mark => ['a', { ...mark.attrs, class: utils.getClassName(mark.attrs, id) }],\n      parseMarkdown: {\n        match: node => node.type === 'link',\n        runner: (state, node, markType) => {\n          const url = node.url as string\n          const title = node.title as string\n          state.openMark(markType, { href: url, title })\n          state.next(node.children)\n          state.closeMark(markType)\n        },\n      },\n      toMarkdown: {\n        match: mark => mark.type.name === id,\n        runner: (state, mark) => {\n          state.withMark(mark, 'link', undefined, {\n            title: mark.attrs.title,\n            url: mark.attrs.href,\n          })\n        },\n      },\n    }),\n    commands: markType => [\n      createCmd(ToggleLink, (href = '') => toggleMark(markType, { href })),\n      createCmd(ModifyLink, (href = '') => (state, dispatch) => {\n        if (!dispatch)\n          return false\n\n        const { marks } = state.schema\n\n        let node: ProseNode | undefined\n        let pos = -1\n        const { selection } = state\n        const { from, to } = selection\n        state.doc.nodesBetween(from, from === to ? to + 1 : to, (n, p) => {\n          if (marks.link?.isInSet(n.marks)) {\n            node = n\n            pos = p\n            return false\n          }\n\n          return undefined\n        })\n        if (!node)\n          return false\n\n        const mark = node.marks.find(({ type }) => type === markType)\n        if (!mark)\n          return false\n\n        const start = pos\n        const end = pos + node.nodeSize\n        const { tr } = state\n        const linkMark = marks.link?.create({ ...mark.attrs, href })\n        if (!linkMark)\n          return false\n        dispatch(\n          tr\n            .removeMark(start, end, mark)\n            .addMark(start, end, linkMark)\n            .setSelection(new TextSelection(tr.selection.$anchor))\n            .scrollIntoView(),\n        )\n\n        return true\n      }),\n    ],\n    prosePlugins: (type, ctx) => {\n      let renderOnTop = false\n      return [\n        new Plugin({\n          key,\n          view: (editorView) => {\n            const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n              placeholder: options?.input?.placeholder ?? 'Input Web Link',\n              buttonText: options?.input?.buttonText,\n              onUpdate: (value) => {\n                ctx.get(commandsCtx).call(ModifyLink, value)\n              },\n              calculatePosition: (view, input) => {\n                calculateTextPosition(view, input, (start, end, target, parent) => {\n                  const $editor = view.dom.parentElement\n                  if (!$editor)\n                    throw missingRootElement()\n\n                  const selectionWidth = end.left - start.left\n                  let left = start.left - parent.left - (target.width - selectionWidth) / 2\n                  let top = start.bottom - parent.top + 14 + $editor.scrollTop\n\n                  if (renderOnTop)\n                    top = start.top - parent.top - target.height - 14 + $editor.scrollTop\n\n                  if (left < 0)\n                    left = 0\n\n                  const maxLeft = $editor.clientWidth - (target.width + 4)\n                  if (left > maxLeft)\n                    left = maxLeft\n\n                  return [top, left]\n                })\n              },\n            })\n            if (!inputChipRenderer)\n              return {}\n            const shouldDisplay = (view: EditorView) => {\n              const { selection, doc } = view.state\n              const { from, to } = selection\n\n              if (!view.hasFocus())\n                return false\n\n              if (\n                selection instanceof TextSelection\n                                && to < doc.content.size\n                                && from < doc.content.size\n                                && doc.rangeHasMark(from, from === to ? to + 1 : to, type)\n              ) {\n                let shouldDisplay = selection.empty\n                if (options?.input?.displayWhenSelected && !shouldDisplay) {\n                  doc.nodesBetween(from, from === to ? to + 1 : to, (node, pos) => {\n                    if (\n                      node.marks.some(\n                        mark =>\n                          mark.type === type && from >= pos && to <= pos + node.nodeSize,\n                      )\n                    ) {\n                      shouldDisplay = true\n                      return false\n                    }\n\n                    return undefined\n                  })\n                }\n                if (shouldDisplay) {\n                  renderOnTop = false\n                  return true\n                }\n              }\n\n              if (selection instanceof NodeSelection) {\n                const { node } = selection\n                if (\n                  node.type.name === 'image'\n                                    && node.marks.findIndex(mark => mark.type.name === id) > -1\n                ) {\n                  renderOnTop = true\n                  return true\n                }\n              }\n\n              return false\n            }\n            const getCurrentLink = (view: EditorView) => {\n              const { selection } = view.state\n              let node: ProseNode | undefined\n              const { from, to } = selection\n              view.state.doc.nodesBetween(from, from === to ? to + 1 : to, (n) => {\n                if (type.isInSet(n.marks)) {\n                  node = n\n                  return false\n                }\n\n                return undefined\n              })\n              if (!node)\n                return\n\n              const mark = node.marks.find(m => m.type === type)\n              if (!mark)\n                return\n\n              const value = mark.attrs.href\n              return value\n            }\n            const renderByView = (view: EditorView) => {\n              if (!view.editable)\n                return\n\n              const display = shouldDisplay(view)\n              if (display) {\n                inputChipRenderer.show(view)\n                inputChipRenderer.update(getCurrentLink(view))\n              }\n              else {\n                inputChipRenderer.hide()\n              }\n            }\n            inputChipRenderer.init(editorView)\n            renderByView(editorView)\n\n            return {\n              update: (view, prevState) => {\n                const isEqualSelection\n                                    = prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection)\n                if (isEqualSelection)\n                  return\n\n                requestAnimationFrame(() => {\n                  renderByView(view)\n                })\n              },\n              destroy: () => {\n                inputChipRenderer.destroy()\n              },\n            }\n          },\n        }),\n      ]\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { toggleMark } from '@milkdown/prose/commands'\nimport { createMark, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['Bold']\nconst id = 'strong'\nexport const ToggleBold = createCmdKey('ToggleBold')\nexport const strong = createMark<Keys>((utils) => {\n  return {\n    id,\n    schema: () => ({\n      inclusive: false,\n      parseDOM: [\n        { tag: 'b' },\n        { tag: 'strong' },\n        { style: 'font-style', getAttrs: value => (value === 'bold') as false },\n      ],\n      toDOM: mark => ['strong', { class: utils.getClassName(mark.attrs, id) }],\n      parseMarkdown: {\n        match: node => node.type === 'strong',\n        runner: (state, node, markType) => {\n          state.openMark(markType)\n          state.next(node.children)\n          state.closeMark(markType)\n        },\n      },\n      toMarkdown: {\n        match: mark => mark.type.name === id,\n        runner: (state, mark) => {\n          state.withMark(mark, 'strong')\n        },\n      },\n    }),\n    commands: markType => [createCmd(ToggleBold, () => toggleMark(markType))],\n    shortcuts: {\n      [SupportedKeys.Bold]: createShortcut(ToggleBold, 'Mod-b'),\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { codeInline } from './code-inline'\nimport { em } from './em'\nimport { link } from './link'\nimport { strong } from './strong'\n\nexport const marks = [codeInline(), em(), strong(), link()]\n\nexport * from './code-inline'\nexport * from './em'\nexport * from './link'\nexport * from './strong'\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['Blockquote']\n\nconst id = 'blockquote'\n\nexport const WrapInBlockquote = createCmdKey('WrapInBlockquote')\n\nexport const blockquote = createNode<Keys>((utils) => {\n  return {\n    id,\n    schema: () => ({\n      content: 'block+',\n      group: 'block',\n      defining: true,\n      parseDOM: [{ tag: 'blockquote' }],\n      toDOM: node => ['blockquote', { class: utils.getClassName(node.attrs, id) }, 0],\n      parseMarkdown: {\n        match: ({ type }) => type === id,\n        runner: (state, node, type) => {\n          state.openNode(type).next(node.children).closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === id,\n        runner: (state, node) => {\n          state.openNode('blockquote').next(node.content).closeNode()\n        },\n      },\n    }),\n    inputRules: nodeType => [wrappingInputRule(/^\\s*>\\s$/, nodeType)],\n    commands: nodeType => [createCmd(WrapInBlockquote, () => wrapIn(nodeType))],\n    shortcuts: {\n      [SupportedKeys.Blockquote]: createShortcut(WrapInBlockquote, 'Mod-Shift-b'),\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['BulletList']\n\nexport const WrapInBulletList = createCmdKey('WrapInBulletList')\n\nexport const bulletList = createNode<Keys>((utils) => {\n  const id = 'bullet_list'\n  return {\n    id,\n    schema: () => ({\n      content: 'listItem+',\n      group: 'block',\n      attrs: {\n        spread: {\n          default: false,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'ul',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              spread: dom.dataset.spread,\n            }\n          },\n        },\n      ],\n      toDOM: (node) => {\n        return [\n          'ul',\n          {\n            'data-spread': node.attrs.spread,\n            'class': utils.getClassName(node.attrs, 'bullet-list'),\n          },\n          0,\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type, ordered }) => type === 'list' && !ordered,\n        runner: (state, node, type) => {\n          const spread = node.spread != null ? `${node.spread}` : 'false'\n          state.openNode(type, { spread }).next(node.children).closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === id,\n        runner: (state, node) => {\n          state\n            .openNode('list', undefined, { ordered: false, spread: node.attrs.spread === 'true' })\n            .next(node.content)\n            .closeNode()\n        },\n      },\n    }),\n    inputRules: nodeType => [wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)],\n    commands: nodeType => [createCmd(WrapInBulletList, () => wrapIn(nodeType))],\n    shortcuts: {\n      [SupportedKeys.BulletList]: createShortcut(WrapInBulletList, 'Mod-Alt-8'),\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { ThemeCodeFenceType } from '@milkdown/core'\nimport { createCmd, createCmdKey, editorViewCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport { Fragment } from '@milkdown/prose/model'\nimport type { NodeView } from '@milkdown/prose/view'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['CodeFence']\n\nconst languageOptions = [\n  '',\n  'javascript',\n  'typescript',\n  'bash',\n  'sql',\n  'json',\n  'html',\n  'css',\n  'c',\n  'cpp',\n  'java',\n  'ruby',\n  'python',\n  'go',\n  'rust',\n  'markdown',\n]\n\nexport const backtickInputRegex = /^```(?<language>[a-z]*)?[\\s\\n]$/\nexport const tildeInputRegex = /^~~~(?<language>[a-z]*)?[\\s\\n]$/\n\nexport const TurnIntoCodeFence = createCmdKey('TurnIntoCodeFence')\n\nconst id = 'fence'\nexport const codeFence = createNode<Keys, { languageList?: string[] }>((utils, options) => {\n  const languageList = options?.languageList || languageOptions\n\n  return {\n    id,\n    schema: ctx => ({\n      content: 'text*',\n      group: 'block',\n      marks: '',\n      defining: true,\n      code: true,\n      attrs: {\n        language: {\n          default: '',\n        },\n        fold: {\n          default: true,\n        },\n      },\n      parseDOM: [\n        {\n          tag: 'div.code-fence-container',\n          preserveWhitespace: 'full',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return { language: dom.querySelector('pre')?.dataset.language }\n          },\n          getContent: (dom, schema) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            const text = dom.querySelector('pre')?.textContent ?? ''\n            if (!text)\n              return Fragment.empty\n\n            const textNode = schema.text(text)\n            return Fragment.from(textNode)\n          },\n        },\n        {\n          tag: 'pre',\n          preserveWhitespace: 'full',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return { language: dom.dataset.language }\n          },\n        },\n      ],\n      toDOM: (node) => {\n        const select = document.createElement('select')\n        languageList.forEach((lang) => {\n          const option = document.createElement('option')\n          option.value = lang\n          option.innerText = !lang ? '--' : lang\n          if (lang === node.attrs.language)\n            option.selected = true\n\n          select.appendChild(option)\n        })\n        select.onchange = (e) => {\n          const target = e.target\n          if (!(target instanceof HTMLSelectElement))\n            return\n\n          const view = ctx.get(editorViewCtx)\n          if (!view.editable) {\n            target.value = node.attrs.language\n            return\n          }\n\n          const { top, left } = target.getBoundingClientRect()\n          const result = view.posAtCoords({ top, left })\n          if (!result)\n            return\n\n          const { tr } = view.state\n\n          view.dispatch(\n            tr.setNodeMarkup(result.inside, undefined, {\n              ...node.attrs,\n              language: target.value,\n            }),\n          )\n        }\n        return [\n          'div',\n          {\n            class: 'code-fence-container',\n          },\n          select,\n          [\n            'pre',\n            {\n              'data-language': node.attrs.language,\n              'class': utils.getClassName(node.attrs, 'code-fence'),\n            },\n            ['code', { spellCheck: 'false' }, 0],\n          ],\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === 'code',\n        runner: (state, node, type) => {\n          const language = node.lang as string\n          const value = node.value as string\n          state.openNode(type, { language })\n          if (value)\n            state.addText(value)\n\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === id,\n        runner: (state, node) => {\n          state.addNode('code', undefined, node.content.firstChild?.text || '', {\n            lang: node.attrs.language,\n          })\n        },\n      },\n    }),\n    inputRules: nodeType => [\n      textblockTypeInputRule(backtickInputRegex, nodeType, (match) => {\n        const [ok, language] = match\n        if (!ok)\n          return\n        return { language }\n      }),\n      textblockTypeInputRule(tildeInputRegex, nodeType, (match) => {\n        const [ok, language] = match\n        if (!ok)\n          return\n        return { language }\n      }),\n    ],\n    commands: nodeType => [createCmd(TurnIntoCodeFence, () => setBlockType(nodeType))],\n    shortcuts: {\n      [SupportedKeys.CodeFence]: createShortcut(TurnIntoCodeFence, 'Mod-Alt-c'),\n    },\n    view: () => (node, view, getPos) => {\n      let currNode = node\n\n      const onSelectLanguage = (language: string) => {\n        const { tr } = view.state\n        view.dispatch(\n          tr.setNodeMarkup(getPos(), undefined, {\n            fold: true,\n            language,\n          }),\n        )\n      }\n      const onBlur = () => {\n        const { tr } = view.state\n\n        view.dispatch(\n          tr.setNodeMarkup(getPos(), undefined, {\n            ...currNode.attrs,\n            fold: true,\n          }),\n        )\n      }\n      const onFocus = () => {\n        const { tr } = view.state\n\n        view.dispatch(\n          tr.setNodeMarkup(getPos(), undefined, {\n            ...currNode.attrs,\n            fold: false,\n          }),\n        )\n      }\n\n      const renderer = utils.themeManager.get<ThemeCodeFenceType>('code-fence', {\n        view,\n        onBlur,\n        onFocus,\n        onSelectLanguage,\n        editable: () => view.editable,\n        languageList,\n      })\n      if (!renderer)\n        return {} as NodeView\n\n      const { dom, contentDOM, onUpdate, onDestroy } = renderer\n      onUpdate(currNode)\n\n      return {\n        dom,\n        contentDOM,\n        update: (updatedNode) => {\n          if (updatedNode.type.name !== id)\n            return false\n          currNode = updatedNode\n          onUpdate(currNode)\n\n          return true\n        },\n        destroy: onDestroy,\n      }\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNode } from '@milkdown/utils'\n\nexport const doc = createNode(() => {\n  return {\n    id: 'doc',\n    schema: () => ({\n      content: 'block+',\n      parseMarkdown: {\n        match: ({ type }) => type === 'root',\n        runner: (state, node, type) => {\n          state.injectRoot(node, type)\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'doc',\n        runner: (state, node) => {\n          state.openNode('root')\n          state.next(node.content)\n        },\n      },\n    }),\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { Plugin, PluginKey, Selection } from '@milkdown/prose/state'\nimport { AddMarkStep, ReplaceStep } from '@milkdown/prose/transform'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['HardBreak']\n\nexport const InsertHardbreak = createCmdKey('InsertHardbreak')\n\nexport const HardbreakFilterPluginKey = new PluginKey('MILKDOWN_HARDBREAK_FILTER')\n\nexport const hardbreak = createNode<\n    Keys,\n    {\n      notIn: string[]\n    }\n>((utils, options) => {\n  const notIn = options?.notIn ?? ['table', 'fence']\n  return {\n    id: 'hardbreak',\n    schema: () => ({\n      inline: true,\n      group: 'inline',\n      selectable: false,\n      parseDOM: [{ tag: 'br' }],\n      toDOM: node => ['br', { class: utils.getClassName(node.attrs, 'hardbreak') }],\n      parseMarkdown: {\n        match: ({ type }) => type === 'break',\n        runner: (state, _, type) => {\n          state.addNode(type)\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'hardbreak',\n        runner: (state) => {\n          state.addNode('break')\n        },\n      },\n    }),\n    commands: type => [\n      createCmd(InsertHardbreak, () => (state, dispatch) => {\n        const { selection, tr } = state\n        if (selection.empty) {\n          // Transform two successive hardbreak into a new line\n          const node = selection.$from.node()\n          if (node.childCount > 0 && node.lastChild?.type.name === 'hardbreak') {\n            dispatch?.(\n              tr\n                .replaceRangeWith(selection.to - 1, selection.to, state.schema.node('paragraph'))\n                .setSelection(Selection.near(tr.doc.resolve(selection.to)))\n                .scrollIntoView(),\n            )\n            return true\n          }\n        }\n        dispatch?.(tr.setMeta('hardbreak', true).replaceSelectionWith(type.create()).scrollIntoView())\n        return true\n      }),\n    ],\n    shortcuts: {\n      [SupportedKeys.HardBreak]: createShortcut(InsertHardbreak, 'Shift-Enter'),\n    },\n    prosePlugins: type => [\n      new Plugin({\n        key: HardbreakFilterPluginKey,\n        filterTransaction: (tr, state) => {\n          const isInsertHr = tr.getMeta('hardbreak')\n          const [step] = tr.steps\n          if (isInsertHr && step) {\n            const { from } = step as unknown as { from: number }\n            const $from = state.doc.resolve(from)\n            let curDepth = $from.depth\n            let canApply = true\n            while (curDepth > 0) {\n              if (notIn.includes($from.node(curDepth).type.name))\n                canApply = false\n\n              curDepth--\n            }\n            return canApply\n          }\n          return true\n        },\n      }),\n      new Plugin({\n        key: new PluginKey('MILKDOWN_HARDBREAK_MARKS'),\n        appendTransaction: (trs, _oldState, newState) => {\n          if (!trs.length)\n            return\n          const [tr] = trs\n          if (!tr)\n            return\n\n          const [step] = tr.steps\n\n          const isInsertHr = tr.getMeta('hardbreak')\n          if (isInsertHr) {\n            if (!(step instanceof ReplaceStep))\n              return\n\n            const { from } = step as unknown as { from: number }\n            return newState.tr.setNodeMarkup(from, type, undefined, [])\n          }\n\n          const isAddMarkStep = step instanceof AddMarkStep\n          if (isAddMarkStep) {\n            let _tr = newState.tr\n            const { from, to } = step as unknown as { from: number; to: number }\n            newState.doc.nodesBetween(from, to, (node, pos) => {\n              if (node.type === type)\n                _tr = _tr.setNodeMarkup(pos, type, undefined, [])\n            })\n\n            return _tr\n          }\n\n          return undefined\n        },\n      }),\n    ],\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { createCmd, createCmdKey, editorViewCtx, getPalette, schemaCtx } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { cloneTr } from '@milkdown/prose'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport { textblockTypeInputRule } from '@milkdown/prose/inputrules'\nimport type { Node, NodeType } from '@milkdown/prose/model'\nimport { Fragment } from '@milkdown/prose/model'\nimport type { EditorState, Transaction } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { Decoration, DecorationSet } from '@milkdown/prose/view'\nimport type { ThemeUtils } from '@milkdown/utils'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\nconst headingIndex = Array(6)\n  .fill(0)\n  .map((_, i) => i + 1)\n\ntype Keys =\n    | SupportedKeys['H1']\n    | SupportedKeys['H2']\n    | SupportedKeys['H3']\n    | SupportedKeys['H4']\n    | SupportedKeys['H5']\n    | SupportedKeys['H6']\n    | SupportedKeys['DowngradeHeading']\n\nexport const TurnIntoHeading = createCmdKey<number>('TurnIntoHeading')\nexport const DowngradeHeading = createCmdKey('DowngradeHeading')\n\nexport const headingIdPluginKey = new PluginKey('MILKDOWN_HEADING_ID')\nexport const headingHashPluginKey = new PluginKey('MILKDOWN_HEADING_HASH')\n\nconst createId = (node: Node) =>\n  node.textContent\n    .replace(/[\\p{P}\\p{S}]/gu, '')\n    .replace(/\\s/g, '-')\n    .toLowerCase()\n    .trim()\n\nconst headingIdPlugin = (ctx: Ctx, type: NodeType, getId: (node: Node) => string): Plugin => {\n  let lock = false\n  const walkThrough = (state: EditorState, callback: (tr: Transaction) => void) => {\n    const tr = state.tr.setMeta('addToHistory', false)\n    let found = false\n    state.doc.descendants((node, pos) => {\n      if (node.type === type && !lock) {\n        if (node.textContent.trim().length === 0)\n          return\n\n        const attrs = node.attrs\n        const id = getId(node)\n\n        if (attrs.id !== id) {\n          found = true\n          tr.setMeta(headingIdPluginKey, true).setNodeMarkup(pos, undefined, {\n            ...attrs,\n            id,\n          })\n        }\n      }\n    })\n    if (found)\n      callback(tr)\n  }\n  return new Plugin({\n    key: headingIdPluginKey,\n    props: {\n      handleDOMEvents: {\n        compositionstart: () => {\n          lock = true\n          return false\n        },\n        compositionend: () => {\n          lock = false\n          const view = ctx.get(editorViewCtx)\n          setTimeout(() => {\n            walkThrough(view.state, tr => view.dispatch(tr))\n          }, 0)\n          return false\n        },\n      },\n    },\n    appendTransaction: (transactions, _, nextState) => {\n      let tr: Transaction | null = null\n\n      if (\n        transactions.every(transaction => !transaction.getMeta(headingIdPluginKey))\n                && transactions.some(transaction => transaction.docChanged)\n      ) {\n        walkThrough(nextState, (t) => {\n          tr = t\n        })\n      }\n\n      return tr\n    },\n    view: (view) => {\n      const doc = view.state.doc\n      let tr = view.state.tr.setMeta('addToHistory', false)\n      doc.descendants((node, pos) => {\n        if (node.type.name === 'heading' && node.attrs.level) {\n          if (!node.attrs.id) {\n            tr = tr.setNodeMarkup(pos, undefined, {\n              ...node.attrs,\n              id: getId(node),\n            })\n          }\n        }\n      })\n      view.dispatch(tr)\n      return {}\n    },\n  })\n}\n\nconst headingHashPlugin = (ctx: Ctx, type: NodeType, utils: ThemeUtils): Plugin => {\n  return new Plugin({\n    key: headingHashPluginKey,\n    state: {\n      init: () => {\n        return DecorationSet.empty\n      },\n      apply: (tr) => {\n        const view = ctx.get(editorViewCtx)\n        if (!view.hasFocus?.() || !view.editable)\n          return DecorationSet.empty\n\n        const { $from } = tr.selection\n        const node = $from.node()\n        if (node.type !== type)\n          return DecorationSet.empty\n\n        const level = node.attrs.level\n        const getHashes = (level: number) => {\n          return Array(level)\n            .fill(0)\n            .map(_ => '#')\n            .join('')\n        }\n        const widget = document.createElement('span')\n        widget.textContent = getHashes(level)\n        widget.contentEditable = 'false'\n        utils.themeManager.onFlush(() => {\n          const style = utils.getStyle(({ css }) => {\n            const palette = getPalette(utils.themeManager)\n            return css`\n                            margin-right: 4px;\n                            color: ${palette('primary')};\n                        `\n          })\n          if (style)\n            widget.className = style\n        })\n\n        const deco = Decoration.widget($from.before() + 1, widget, { side: -1 })\n        return DecorationSet.create(tr.doc, [deco])\n      },\n    },\n    props: {\n      handleDOMEvents: {\n        focus: (view) => {\n          const tr = cloneTr(view.state.tr)\n          view.dispatch(tr)\n          return false\n        },\n      },\n      decorations(this: Plugin, state) {\n        return this.getState(state)\n      },\n    },\n  })\n}\n\nexport const heading = createNode<Keys, { getId: (node: Node) => string; displayHashtag: boolean }>(\n  (utils, options) => {\n    const id = 'heading'\n\n    const getId = options?.getId ?? createId\n    const displayHashtag = options?.displayHashtag ?? true\n\n    return {\n      id,\n      schema: () => ({\n        content: 'inline*',\n        group: 'block',\n        defining: true,\n        attrs: {\n          id: {\n            default: '',\n          },\n          level: {\n            default: 1,\n          },\n        },\n        parseDOM: headingIndex.map(x => ({\n          tag: `h${x}`,\n          getAttrs: (node) => {\n            if (!(node instanceof HTMLElement))\n              throw expectDomTypeError(node)\n\n            return { level: x, id: node.id }\n          },\n        })),\n        toDOM: (node) => {\n          return [\n                        `h${node.attrs.level}`,\n                        {\n                          id: node.attrs.id || getId(node),\n                          class: utils.getClassName(node.attrs, `heading h${node.attrs.level}`),\n                        },\n                        0,\n          ]\n        },\n        parseMarkdown: {\n          match: ({ type }) => type === id,\n          runner: (state, node, type) => {\n            const depth = node.depth as number\n            state.openNode(type, { level: depth })\n            state.next(node.children)\n            state.closeNode()\n          },\n        },\n        toMarkdown: {\n          match: node => node.type.name === id,\n          runner: (state, node) => {\n            state.openNode('heading', undefined, { depth: node.attrs.level })\n            const lastIsHardbreak = node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak'\n            if (lastIsHardbreak) {\n              const contentArr: Node[] = []\n              node.content.forEach((n, _, i) => {\n                if (i === node.childCount - 1)\n                  return\n\n                contentArr.push(n)\n              })\n              state.next(Fragment.fromArray(contentArr))\n            }\n            else {\n              state.next(node.content)\n            }\n            state.closeNode()\n          },\n        },\n      }),\n      inputRules: (type, ctx) =>\n        headingIndex.map(x =>\n          textblockTypeInputRule(new RegExp(`^(#{1,${x}})\\\\s$`), type, () => {\n            const view = ctx.get(editorViewCtx)\n            const { $from } = view.state.selection\n            const node = $from.node()\n            if (node.type.name === 'heading') {\n              let level = Number(node.attrs.level) + Number(x)\n              if (level > 6)\n                level = 6\n\n              return {\n                level,\n              }\n            }\n            return {\n              level: x,\n            }\n          }),\n        ),\n      commands: (type, ctx) => [\n        createCmd(TurnIntoHeading, (level = 1) => {\n          if (level < 1)\n            return setBlockType(level === 0 ? ctx.get(schemaCtx).nodes.paragraph || type : type)\n\n          return setBlockType(level === 0 ? ctx.get(schemaCtx).nodes.paragraph || type : type, { level })\n        }),\n        createCmd(DowngradeHeading, () => {\n          return (state, dispatch, view) => {\n            const { $from } = state.selection\n            const node = $from.node()\n            if (node.type !== type || !state.selection.empty || $from.parentOffset !== 0)\n              return false\n\n            const level = node.attrs.level - 1\n            if (!level)\n              return setBlockType(ctx.get(schemaCtx).nodes.paragraph || type)(state, dispatch, view)\n\n            dispatch?.(\n              state.tr.setNodeMarkup(state.selection.$from.before(), undefined, {\n                ...node.attrs,\n                level,\n              }),\n            )\n            return true\n          }\n        }),\n      ],\n      shortcuts: {\n        [SupportedKeys.H1]: createShortcut(TurnIntoHeading, 'Mod-Alt-1', 1),\n        [SupportedKeys.H2]: createShortcut(TurnIntoHeading, 'Mod-Alt-2', 2),\n        [SupportedKeys.H3]: createShortcut(TurnIntoHeading, 'Mod-Alt-3', 3),\n        [SupportedKeys.H4]: createShortcut(TurnIntoHeading, 'Mod-Alt-4', 4),\n        [SupportedKeys.H5]: createShortcut(TurnIntoHeading, 'Mod-Alt-5', 5),\n        [SupportedKeys.H6]: createShortcut(TurnIntoHeading, 'Mod-Alt-6', 6),\n        [SupportedKeys.DowngradeHeading]: createShortcut(DowngradeHeading, ['Backspace', 'Delete']),\n      },\n      prosePlugins: (type, ctx) => {\n        const plugins = [headingIdPlugin(ctx, type, getId)]\n        if (displayHashtag)\n          plugins.push(headingHashPlugin(ctx, type, utils))\n\n        return plugins\n      },\n    }\n  },\n)\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey, schemaCtx } from '@milkdown/core'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { Selection } from '@milkdown/prose/state'\nimport { createNode } from '@milkdown/utils'\n\nconst id = 'hr'\nexport const InsertHr = createCmdKey<string>('InsertHr')\nexport const hr = createNode((utils) => {\n  return {\n    id,\n    schema: () => ({\n      group: 'block',\n      parseDOM: [{ tag: 'hr' }],\n      toDOM: node => ['hr', { class: utils.getClassName(node.attrs, id) }],\n      parseMarkdown: {\n        match: ({ type }) => type === 'thematicBreak',\n        runner: (state, _, type) => {\n          state.addNode(type)\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === id,\n        runner: (state) => {\n          state.addNode('thematicBreak')\n        },\n      },\n    }),\n    inputRules: type => [\n      new InputRule(/^(?:---|___\\s|\\*\\*\\*\\s)$/, (state, match, start, end) => {\n        const { tr } = state\n\n        if (match[0])\n          tr.replaceWith(start - 1, end, type.create())\n\n        return tr\n      }),\n    ],\n    commands: (type, ctx) => [\n      createCmd(InsertHr, () => (state, dispatch) => {\n        if (!dispatch)\n          return true\n\n        const paragraph = ctx.get(schemaCtx).node('paragraph')\n        const { tr, selection } = state\n        const { from } = selection\n        const node = type.create()\n        if (!node)\n          return true\n\n        const _tr = tr.replaceSelectionWith(node).insert(from, paragraph)\n        const sel = Selection.findFrom(_tr.doc.resolve(from), 1, true)\n        if (!sel)\n          return true\n\n        dispatch(_tr.setSelection(sel).scrollIntoView())\n        return true\n      }),\n    ],\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { ThemeImageType, ThemeInputChipType } from '@milkdown/core'\nimport { commandsCtx, createCmd, createCmdKey } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { findSelectedNodeOfType } from '@milkdown/prose'\nimport { InputRule } from '@milkdown/prose/inputrules'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport type { EditorView, NodeView } from '@milkdown/prose/view'\nimport { createNode } from '@milkdown/utils'\n\nexport const ModifyImage = createCmdKey<string>('ModifyImage')\nexport const InsertImage = createCmdKey<string>('InsertImage')\nconst id = 'image'\nexport interface ImageOptions {\n  isBlock: boolean\n  placeholder: string\n  input: {\n    placeholder: string\n    buttonText?: string\n  }\n}\nconst key = new PluginKey('MILKDOWN_IMAGE_INPUT')\n\nexport const image = createNode<string, ImageOptions>((utils, options) => {\n  return {\n    id: 'image',\n    schema: () => ({\n      inline: true,\n      group: 'inline',\n      selectable: true,\n      draggable: true,\n      marks: '',\n      atom: true,\n      defining: true,\n      isolating: true,\n      attrs: {\n        src: { default: '' },\n        alt: { default: '' },\n        title: { default: '' },\n      },\n      parseDOM: [\n        {\n          tag: 'img[src]',\n          getAttrs: (dom) => {\n            if (!(dom instanceof HTMLElement))\n              throw expectDomTypeError(dom)\n\n            return {\n              src: dom.getAttribute('src') || '',\n              alt: dom.getAttribute('alt') || '',\n              title: dom.getAttribute('title') || dom.getAttribute('alt') || '',\n            }\n          },\n        },\n      ],\n      toDOM: (node) => {\n        return [\n          'img',\n          {\n            ...node.attrs,\n            class: utils.getClassName(node.attrs, id),\n          },\n        ]\n      },\n      parseMarkdown: {\n        match: ({ type }) => type === id,\n        runner: (state, node, type) => {\n          const url = node.url as string\n          const alt = node.alt as string\n          const title = node.title as string\n          state.addNode(type, {\n            src: url,\n            alt,\n            title,\n          })\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === id,\n        runner: (state, node) => {\n          state.addNode('image', undefined, undefined, {\n            title: node.attrs.title,\n            url: node.attrs.src,\n            alt: node.attrs.alt,\n          })\n        },\n      },\n    }),\n    commands: type => [\n      createCmd(InsertImage, (src = '') => (state, dispatch) => {\n        if (!dispatch)\n          return true\n        const { tr } = state\n        const node = type.create({ src })\n        if (!node)\n          return true\n\n        const _tr = tr.replaceSelectionWith(node)\n        dispatch(_tr.scrollIntoView())\n        return true\n      }),\n      createCmd(ModifyImage, (src = '') => (state, dispatch) => {\n        const node = findSelectedNodeOfType(state.selection, type)\n        if (!node)\n          return false\n\n        const { tr } = state\n        dispatch?.(\n          tr.setNodeMarkup(node.pos, undefined, { ...node.node.attrs, loading: true, src }).scrollIntoView(),\n        )\n\n        return true\n      }),\n    ],\n    inputRules: type => [\n      new InputRule(\n        /!\\[(?<alt>.*?)]\\((?<filename>.*?)\\s*(?=\"|\\))\"?(?<title>[^\"]+)?\"?\\)/,\n        (state, match, start, end) => {\n          const [okay, alt, src = '', title] = match\n          const { tr } = state\n          if (okay)\n            tr.replaceWith(start, end, type.create({ src, alt, title }))\n\n          return tr\n        },\n      ),\n    ],\n    view: () => (node) => {\n      let currNode = node\n\n      const placeholder = options?.placeholder ?? 'Add an Image'\n      const isBlock = options?.isBlock ?? false\n      const renderer = utils.themeManager.get<ThemeImageType>('image', {\n        placeholder,\n        isBlock,\n      })\n\n      if (!renderer)\n        return {} as NodeView\n\n      const { dom, onUpdate } = renderer\n      onUpdate(currNode)\n\n      return {\n        dom,\n        update: (updatedNode) => {\n          if (updatedNode.type.name !== id)\n            return false\n\n          currNode = updatedNode\n          onUpdate(currNode)\n\n          return true\n        },\n        selectNode: () => {\n          dom.classList.add('ProseMirror-selectednode')\n        },\n        deselectNode: () => {\n          dom.classList.remove('ProseMirror-selectednode')\n        },\n      }\n    },\n    prosePlugins: (type, ctx) => {\n      return [\n        new Plugin({\n          key,\n          view: (editorView) => {\n            const inputChipRenderer = utils.themeManager.get<ThemeInputChipType>('input-chip', {\n              placeholder: options?.input?.placeholder ?? 'Input Image Link',\n              buttonText: options?.input?.buttonText,\n              onUpdate: (value) => {\n                ctx.get(commandsCtx).call(ModifyImage, value)\n              },\n            })\n            if (!inputChipRenderer)\n              return {}\n            const shouldDisplay = (view: EditorView) => {\n              return Boolean(\n                view.hasFocus() && type && findSelectedNodeOfType(view.state.selection, type),\n              )\n            }\n            const getCurrentLink = (view: EditorView) => {\n              const result = findSelectedNodeOfType(view.state.selection, type)\n              if (!result)\n                return\n\n              const value = result.node.attrs.src\n              return value\n            }\n            const renderByView = (view: EditorView) => {\n              if (!view.editable)\n                return\n\n              const display = shouldDisplay(view)\n              if (display) {\n                inputChipRenderer.show(view)\n                inputChipRenderer.update(getCurrentLink(view))\n              }\n              else {\n                inputChipRenderer.hide()\n              }\n            }\n            inputChipRenderer.init(editorView)\n            renderByView(editorView)\n\n            return {\n              update: (view, prevState) => {\n                const isEqualSelection\n                                    = prevState?.doc.eq(view.state.doc) && prevState.selection.eq(view.state.selection)\n                if (isEqualSelection)\n                  return\n\n                renderByView(view)\n              },\n              destroy: () => {\n                inputChipRenderer.destroy()\n              },\n            }\n          },\n        }),\n      ]\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { getNodeFromSchema } from '@milkdown/prose'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport type { NodeType } from '@milkdown/prose/model'\nimport { liftListItem, sinkListItem, splitListItem } from '@milkdown/prose/schema-list'\nimport type { EditorState, Transaction } from '@milkdown/prose/state'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['SinkListItem'] | SupportedKeys['LiftListItem'] | SupportedKeys['NextListItem']\n\nconst id = 'list_item'\n\nexport const SplitListItem = createCmdKey('SplitListItem')\nexport const SinkListItem = createCmdKey('SinkListItem')\nexport const LiftListItem = createCmdKey('LiftListItem')\n\nconst keepListOrderPluginKey = new PluginKey('MILKDOWN_KEEP_LIST_ORDER')\n\nconst createKeepListOrderPlugin = (type: NodeType) => {\n  const walkThrough = (state: EditorState, callback: (tr: Transaction) => void) => {\n    const orderedListType = getNodeFromSchema('ordered_list', state.schema)\n    let tr = state.tr\n    state.doc.descendants((node, pos, parent, index) => {\n      if (node.type === type && parent?.type === orderedListType) {\n        let changed = false\n        const attrs = { ...node.attrs }\n        if (node.attrs.listType !== 'ordered') {\n          attrs.listType = 'ordered'\n          changed = true\n        }\n\n        const base = parent?.maybeChild(0)\n        if (base && base.type === type && base.attrs.listType === 'ordered') {\n          attrs.label = `${index + 1}.`\n          changed = true\n        }\n\n        if (node.attrs.label === '•') {\n          attrs.label = `${index + 1}.`\n          changed = true\n        }\n\n        if (changed)\n          tr = tr.setNodeMarkup(pos, undefined, attrs)\n      }\n    })\n    callback(tr)\n  }\n  return new Plugin({\n    key: keepListOrderPluginKey,\n    appendTransaction: (transactions, _oldState, nextState) => {\n      let tr: Transaction | null = null\n      if (transactions.some(transaction => transaction.docChanged)) {\n        walkThrough(nextState, (t) => {\n          tr = t\n        })\n      }\n\n      return tr\n    },\n  })\n}\n\nexport const listItem = createNode<Keys>(utils => ({\n  id,\n  schema: () => ({\n    group: 'listItem',\n    content: 'paragraph block*',\n    attrs: {\n      label: {\n        default: '•',\n      },\n      listType: {\n        default: 'bullet',\n      },\n      spread: {\n        default: 'true',\n      },\n    },\n    defining: true,\n    parseDOM: [\n      {\n        tag: 'li.list-item',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement))\n            throw expectDomTypeError(dom)\n\n          return {\n            label: dom.dataset.label,\n            listType: dom.dataset['list-type'],\n            spread: dom.dataset.spread,\n          }\n        },\n        contentElement: (dom) => {\n          if (!(dom instanceof HTMLElement))\n            throw expectDomTypeError(dom)\n\n          const body = dom.querySelector<HTMLElement>('.list-item_body')\n          if (!body)\n            return dom\n\n          return body\n        },\n      },\n      { tag: 'li' },\n    ],\n    toDOM: (node) => {\n      return [\n        'li',\n        {\n          'class': utils.getClassName(node.attrs, 'list-item'),\n          'data-label': node.attrs.label,\n          'data-list-type': node.attrs.listType,\n          'data-spread': node.attrs.spread,\n        },\n        ['div', { class: utils.getClassName(node.attrs, 'list-item_label') }, node.attrs.label],\n        ['div', { class: utils.getClassName(node.attrs, 'list-item_body') }, 0],\n      ]\n    },\n    parseMarkdown: {\n      match: ({ type, checked }) => type === 'listItem' && checked === null,\n      runner: (state, node, type) => {\n        const label = node.label != null ? `${node.label}.` : '•'\n        const listType = node.label != null ? 'ordered' : 'bullet'\n        const spread = node.spread != null ? `${node.spread}` : 'true'\n        state.openNode(type, { label, listType, spread })\n        state.next(node.children)\n        state.closeNode()\n      },\n    },\n    toMarkdown: {\n      match: node => node.type.name === id,\n      runner: (state, node) => {\n        state.openNode('listItem', undefined, { spread: node.attrs.spread === 'true' })\n        state.next(node.content)\n        state.closeNode()\n      },\n    },\n  }),\n  inputRules: nodeType => [wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType)],\n  commands: nodeType => [\n    createCmd(SplitListItem, () => splitListItem(nodeType)),\n    createCmd(SinkListItem, () => sinkListItem(nodeType)),\n    createCmd(LiftListItem, () => liftListItem(nodeType)),\n  ],\n  shortcuts: {\n    [SupportedKeys.NextListItem]: createShortcut(SplitListItem, 'Enter'),\n    [SupportedKeys.SinkListItem]: createShortcut(SinkListItem, 'Mod-]'),\n    [SupportedKeys.LiftListItem]: createShortcut(LiftListItem, 'Mod-['),\n  },\n  prosePlugins: nodeType => [createKeepListOrderPlugin(nodeType)],\n}))\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { expectDomTypeError } from '@milkdown/exception'\nimport { wrapIn } from '@milkdown/prose/commands'\nimport { wrappingInputRule } from '@milkdown/prose/inputrules'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['OrderedList']\n\nexport const WrapInOrderedList = createCmdKey('WrapInOrderedList')\n\nconst id = 'ordered_list'\nexport const orderedList = createNode<Keys>(utils => ({\n  id,\n  schema: () => ({\n    content: 'listItem+',\n    group: 'block',\n    attrs: {\n      order: {\n        default: 1,\n      },\n      spread: {\n        default: false,\n      },\n    },\n    parseDOM: [\n      {\n        tag: 'ol',\n        getAttrs: (dom) => {\n          if (!(dom instanceof HTMLElement))\n            throw expectDomTypeError(dom)\n\n          return {\n            spread: dom.dataset.spread,\n            order: dom.hasAttribute('start') ? Number(dom.getAttribute('start')) : 1,\n          }\n        },\n      },\n    ],\n    toDOM: node => [\n      'ol',\n      {\n        ...(node.attrs.order === 1 ? {} : node.attrs.order),\n        'data-spread': node.attrs.spread,\n        'class': utils.getClassName(node.attrs, 'ordered-list'),\n      },\n      0,\n    ],\n    parseMarkdown: {\n      match: ({ type, ordered }) => type === 'list' && !!ordered,\n      runner: (state, node, type) => {\n        const spread = node.spread != null ? `${node.spread}` : 'true'\n        state.openNode(type, { spread }).next(node.children).closeNode()\n      },\n    },\n    toMarkdown: {\n      match: node => node.type.name === id,\n      runner: (state, node) => {\n        state.openNode('list', undefined, { ordered: true, start: 1, spread: node.attrs.spread === 'true' })\n        state.next(node.content)\n        state.closeNode()\n      },\n    },\n  }),\n  inputRules: nodeType => [\n    wrappingInputRule(\n      /^(\\d+)\\.\\s$/,\n      nodeType,\n      match => ({ order: Number(match[1]) }),\n      (match, node) => node.childCount + node.attrs.order === Number(match[1]),\n    ),\n  ],\n  commands: nodeType => [createCmd(WrapInOrderedList, () => wrapIn(nodeType))],\n  shortcuts: {\n    [SupportedKeys.OrderedList]: createShortcut(WrapInOrderedList, 'Mod-Alt-7'),\n  },\n}))\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createCmd, createCmdKey } from '@milkdown/core'\nimport { setBlockType } from '@milkdown/prose/commands'\nimport type { Node } from '@milkdown/prose/model'\nimport { Fragment } from '@milkdown/prose/model'\nimport { createNode, createShortcut } from '@milkdown/utils'\n\nimport { SupportedKeys } from '../supported-keys'\n\ntype Keys = SupportedKeys['Text']\n\nexport const TurnIntoText = createCmdKey('TurnIntoText')\n\nconst id = 'paragraph'\nexport const paragraph = createNode<Keys>((utils) => {\n  return {\n    id,\n    schema: () => ({\n      content: 'inline*',\n      group: 'block',\n      parseDOM: [{ tag: 'p' }],\n      toDOM: node => ['p', { class: utils.getClassName(node.attrs, id) }, 0],\n      parseMarkdown: {\n        match: node => node.type === 'paragraph',\n        runner: (state, node, type) => {\n          state.openNode(type)\n          if (node.children)\n            state.next(node.children)\n          else\n            state.addText(node.value as string)\n\n          state.closeNode()\n        },\n      },\n      toMarkdown: {\n        match: node => node.type.name === 'paragraph',\n        runner: (state, node) => {\n          state.openNode('paragraph')\n          const lastIsHardbreak = node.childCount >= 1 && node.lastChild?.type.name === 'hardbreak'\n          if (lastIsHardbreak) {\n            const contentArr: Node[] = []\n            node.content.forEach((n, _, i) => {\n              if (i === node.childCount - 1)\n                return\n\n              contentArr.push(n)\n            })\n            state.next(Fragment.fromArray(contentArr))\n          }\n          else {\n            state.next(node.content)\n          }\n          state.closeNode()\n        },\n      },\n    }),\n    commands: nodeType => [createCmd(TurnIntoText, () => setBlockType(nodeType))],\n    shortcuts: {\n      [SupportedKeys.Text]: createShortcut(TurnIntoText, 'Mod-Alt-0'),\n    },\n  }\n})\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNode } from '@milkdown/utils'\n\nexport const text = createNode(() => ({\n  id: 'text',\n  schema: () => ({\n    group: 'inline',\n    parseMarkdown: {\n      match: ({ type }) => type === 'text',\n      runner: (state, node) => {\n        state.addText(node.value as string)\n      },\n    },\n    toMarkdown: {\n      match: node => node.type.name === 'text',\n      runner: (state, node) => {\n        state.addNode('text', undefined, node.text as string)\n      },\n    },\n  }),\n}))\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { AtomPlugin } from '@milkdown/utils'\n\nimport { blockquote } from './blockquote'\nimport { bulletList } from './bullet-list'\nimport { codeFence } from './code-fence'\nimport { doc } from './doc'\nimport { hardbreak } from './hardbreak'\nimport { heading } from './heading'\nimport { hr } from './hr'\nimport { image } from './image'\nimport { listItem } from './list-item'\nimport { orderedList } from './ordered-list'\nimport { paragraph } from './paragraph'\nimport { text } from './text'\n\nexport const nodes: AtomPlugin[] = [\n  doc(),\n  paragraph(),\n  hardbreak(),\n  blockquote(),\n  codeFence(),\n  bulletList(),\n  orderedList(),\n  listItem(),\n  heading(),\n  hr(),\n  image(),\n  text(),\n]\n\nexport * from './blockquote'\nexport * from './bullet-list'\nexport * from './code-fence'\nexport * from './doc'\nexport * from './hardbreak'\nexport * from './heading'\nexport * from './hr'\nexport * from './image'\nexport * from './list-item'\nexport * from './ordered-list'\nexport * from './paragraph'\nexport * from './text'\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node } from 'unist'\nimport type { Parent } from 'unist-util-visit'\nimport { visit } from 'unist-util-visit'\n\nexport const addOrderInList = () => {\n  function transformer(ast: Node) {\n    visit(ast, 'list', (node: Parent & { ordered?: boolean; start?: number }) => {\n      if (node.ordered) {\n        const start = node.start ?? 1\n        node.children.forEach((child, index) => {\n          (child as Node & { label: number }).label = index + start\n        })\n      }\n    })\n  }\n\n  return transformer\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Literal, Node, Parent } from 'unist'\n\nconst isParent = (node: Node): node is Parent => !!(node as Parent).children\nconst isHTML = (node: Node): node is Literal<string> => node.type === 'html'\n\nfunction flatMapWithDepth(ast: Node, fn: (node: Node, index: number, parent: Node | null) => Node[]) {\n  return transform(ast, 0, null)[0]\n\n  function transform(node: Node, index: number, parent: Node | null) {\n    if (isParent(node)) {\n      const out = []\n      for (let i = 0, n = node.children.length; i < n; i++) {\n        const nthChild = node.children[i]\n        if (nthChild) {\n          const xs = transform(nthChild, i, node)\n          if (xs) {\n            for (let j = 0, m = xs.length; j < m; j++) {\n              const item = xs[j]\n              if (item)\n                out.push(item)\n            }\n          }\n        }\n      }\n      node.children = out\n    }\n\n    return fn(node, index, parent)\n  }\n}\n\nexport const filterHTMLPlugin = () => {\n  function transformer(tree: Node) {\n    flatMapWithDepth(tree, (node) => {\n      if (!isHTML(node))\n        return [node]\n\n      return []\n    })\n  }\n  return transformer\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\nimport { Decoration, DecorationSet } from '@milkdown/prose/view'\n\nconst inlineNodesCursorPluginKey = new PluginKey('MILKDOWN_INLINE_NODES_CURSOR')\n\n/**\n * This plugin is to solve the chrome 98 bug:\n * https://discuss.prosemirror.net/t/cursor-jumps-at-the-end-of-line-when-it-betweens-two-inline-nodes/4641\n */\nexport const getInlineNodesCursorPlugin = (): Plugin => {\n  let lock = false\n  const inlineNodesCursorPlugin: Plugin = new Plugin({\n    key: inlineNodesCursorPluginKey,\n    state: {\n      init() {\n        return false\n      },\n      apply(tr) {\n        if (!tr.selection.empty)\n          return false\n\n        const pos = tr.selection.$from\n        const left = pos.nodeBefore\n        const right = pos.nodeAfter\n        if (left && right && left.isInline && !left.isText && right.isInline && !right.isText)\n          return true\n\n        return false\n      },\n    },\n    props: {\n      handleDOMEvents: {\n        compositionend: (view, e) => {\n          if (lock) {\n            lock = false\n            requestAnimationFrame(() => {\n              const active = inlineNodesCursorPlugin.getState(view.state)\n              if (active) {\n                const from = view.state.selection.from\n                e.preventDefault()\n                view.dispatch(view.state.tr.insertText(e.data || '', from))\n              }\n            })\n\n            return true\n          }\n          return false\n        },\n        compositionstart: (view) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active)\n            lock = true\n\n          return false\n        },\n        beforeinput: (view, e) => {\n          const active = inlineNodesCursorPlugin.getState(view.state)\n          if (active && e instanceof InputEvent && e.data && !lock) {\n            const from = view.state.selection.from\n            e.preventDefault()\n            view.dispatch(view.state.tr.insertText(e.data || '', from))\n\n            return true\n          }\n\n          return false\n        },\n      },\n      decorations(state) {\n        const active = inlineNodesCursorPlugin.getState(state)\n        if (active) {\n          const pos = state.selection.$from\n          const position = pos.pos\n          const left = document.createElement('span')\n          const leftDec = Decoration.widget(position, left, {\n            side: -1,\n          })\n          const right = document.createElement('span')\n          const rightDec = Decoration.widget(position, right)\n          setTimeout(() => {\n            left.contentEditable = 'true'\n            right.contentEditable = 'true'\n          })\n          return DecorationSet.create(state.doc, [leftDec, rightDec])\n        }\n        return DecorationSet.empty\n      },\n    },\n  })\n\n  return inlineNodesCursorPlugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nexport const linkRegexp = /\\[(?<span>((www|https:\\/\\/|http:\\/\\/)[^\\s\\]]+))]\\((?<url>[^\\s\\]]+)\\)/\n\nexport const punctuationRegexp = (holePlaceholder: string) =>\n  new RegExp(`\\\\\\\\(?=[^\\\\w\\\\s${holePlaceholder}\\\\\\\\]|_)`, 'g')\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Node } from '@milkdown/prose/model'\n\nimport type { SyncNodePlaceholder } from './config'\nimport { linkRegexp, punctuationRegexp } from './regexp'\n\nexport const keepLink = (str: string) => {\n  let text = str\n  let match = text.match(linkRegexp)\n  while (match && match.groups) {\n    const { span } = match.groups\n    text = text.replace(linkRegexp, span as string)\n\n    match = text.match(linkRegexp)\n  }\n  return text\n}\n\nexport const swap = (text: string, first: number, last: number) => {\n  const arr = text.split('')\n  const temp = arr[first]\n  if (arr[first] && arr[last]) {\n    arr[first] = arr[last] as string\n    arr[last] = temp as string\n  }\n  return arr.join('').toString()\n}\n\nexport const replacePunctuation = (holePlaceholder: string) => (text: string) =>\n  text.replace(punctuationRegexp(holePlaceholder), '')\n\nexport const calculatePlaceholder = (placeholder: SyncNodePlaceholder) => (text: string) => {\n  const index = text.indexOf(placeholder.hole)\n  const left = text.charAt(index - 1)\n  const right = text.charAt(index + 1)\n  const notAWord = /[^\\w]|_/\n\n  // cursor on the right\n  if (!right)\n    return placeholder.punctuation\n\n  // cursor on the left\n  if (!left)\n    return placeholder.char\n\n  if (notAWord.test(left) && notAWord.test(right))\n    return placeholder.punctuation\n\n  return placeholder.char\n}\n\nexport const calcOffset = (node: Node, from: number, placeholder: string) => {\n  let offset = from\n  let find = false\n  node.descendants((n) => {\n    if (find)\n      return false\n    if (n.isText) {\n      const i = n.text?.indexOf(placeholder)\n      if (i != null && i >= 0) {\n        find = true\n        offset += i\n        return false\n      }\n    }\n    offset += n.nodeSize\n    return undefined\n  })\n  return offset\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { createSlice } from '@milkdown/core'\nimport type { Node, NodeType } from '@milkdown/prose/model'\nimport type { Transaction } from '@milkdown/prose/state'\n\nimport { swap } from './utils'\n\nexport type ShouldSyncNode = (context: {\n  prevNode: Node\n  nextNode: Node\n  ctx: Ctx\n  tr: Transaction\n  text: string\n}) => boolean\n\nexport interface SyncNodePlaceholder {\n  hole: string\n  punctuation: string\n  char: string\n}\n\nexport interface InlineSyncConfig {\n  placeholderConfig: SyncNodePlaceholder\n  shouldSyncNode: ShouldSyncNode\n  globalNodes: Array<NodeType | string>\n  movePlaceholder: (placeholderToMove: string, text: string) => string\n}\n\nexport const defaultConfig: InlineSyncConfig = {\n  placeholderConfig: {\n    hole: '∅',\n    punctuation: '⁂',\n    char: '∴',\n  },\n  globalNodes: ['footnote_definition'],\n  shouldSyncNode: ({ prevNode, nextNode }) =>\n    prevNode.inlineContent\n        && nextNode\n        // if node type changes, do not sync\n        && prevNode.type === nextNode.type\n        // if two node fully equal, we don't modify them\n        && !prevNode.eq(nextNode),\n  movePlaceholder: (placeholderToMove: string, text: string) => {\n    const symbolsNeedToMove = ['*', '_']\n\n    let index = text.indexOf(placeholderToMove)\n    while (symbolsNeedToMove.includes(text[index - 1] || '') && symbolsNeedToMove.includes(text[index + 1] || '')) {\n      text = swap(text, index, index + 1)\n      index = index + 1\n    }\n\n    return text\n  },\n}\n\nexport const inlineSyncConfigCtx = createSlice<InlineSyncConfig, 'inlineSyncConfig'>(defaultConfig, 'inlineSyncConfig')\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { parserCtx, serializerCtx } from '@milkdown/core'\nimport type { Node } from '@milkdown/prose/model'\nimport type { EditorState } from '@milkdown/prose/state'\nimport { pipe } from '@milkdown/utils'\n\nimport { inlineSyncConfigCtx } from './config'\nimport { calculatePlaceholder, keepLink, replacePunctuation } from './utils'\n\nexport * from './config'\n\nexport interface InlineSyncContext {\n  text: string\n  prevNode: Node\n  nextNode: Node\n  placeholder: string\n}\n\nconst getNodeFromSelection = (state: EditorState) => {\n  const { selection } = state\n  const { $from } = selection\n  const node = $from.node()\n\n  return node\n}\n\nconst getMarkdown = (ctx: Ctx, state: EditorState, node: Node, globalNode: Node[]) => {\n  const serializer = ctx.get(serializerCtx)\n  const doc = state.schema.topNodeType.create(undefined, [node, ...globalNode])\n\n  const markdown = serializer(doc)\n\n  return markdown\n}\n\nconst addPlaceholder = (ctx: Ctx, markdown: string) => {\n  const config = ctx.get(inlineSyncConfigCtx)\n  const holePlaceholder = config.placeholderConfig.hole\n\n  const [firstLine = '', ...rest] = markdown.split('\\n\\n')\n\n  const movePlaceholder = (text: string) => config.movePlaceholder(holePlaceholder, text)\n\n  const handleText = pipe(replacePunctuation(holePlaceholder), movePlaceholder, keepLink)\n\n  let text = handleText(firstLine)\n  const placeholder = calculatePlaceholder(config.placeholderConfig)(text)\n\n  text = text.replace(holePlaceholder, placeholder)\n\n  text = [text, ...rest].join('\\n\\n')\n\n  return [text, placeholder] as [markdown: string, placeholder: string]\n}\n\nconst getNewNode = (ctx: Ctx, text: string) => {\n  const parser = ctx.get(parserCtx)\n  const parsed = parser(text)\n\n  if (!parsed)\n    return null\n\n  return parsed.firstChild\n}\n\nconst collectGlobalNodes = (ctx: Ctx, state: EditorState) => {\n  const { globalNodes } = ctx.get(inlineSyncConfigCtx)\n  const nodes: Node[] = []\n\n  state.doc.descendants((node) => {\n    if (globalNodes.includes(node.type.name) || globalNodes.includes(node.type)) {\n      nodes.push(node)\n      return false\n    }\n\n    return undefined\n  })\n\n  return nodes\n}\n\nconst removeGlobalFromText = (text: string) => text.split('\\n\\n')[0] || ''\n\nexport const getContextByState = (ctx: Ctx, state: EditorState): InlineSyncContext | null => {\n  try {\n    const globalNode = collectGlobalNodes(ctx, state)\n    const node = getNodeFromSelection(state)\n\n    const markdown = getMarkdown(ctx, state, node, globalNode)\n    const [text, placeholder] = addPlaceholder(ctx, markdown)\n\n    const newNode = getNewNode(ctx, text)\n\n    if (!newNode || node.type !== newNode.type)\n      return null\n\n    // @ts-expect-error hijack the node attribute\n    newNode.attrs = { ...node.attrs }\n\n    newNode.descendants((node) => {\n      const marks = node.marks\n      const link = marks.find(mark => mark.type.name === 'link')\n      if (link && node.text?.includes(placeholder) && link.attrs.href.includes(placeholder)) {\n        // @ts-expect-error hijack the mark attribute\n        link.attrs.href = link.attrs.href.replace(placeholder, '')\n      }\n    })\n\n    return {\n      text: removeGlobalFromText(text),\n      prevNode: node,\n      nextNode: newNode,\n      placeholder,\n    }\n  }\n  catch {\n    return null\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport type { Attrs } from '@milkdown/prose/model'\nimport type { EditorState, PluginKey, Transaction } from '@milkdown/prose/state'\nimport { TextSelection } from '@milkdown/prose/state'\n\nimport { inlineSyncConfigCtx } from './config'\nimport { getContextByState } from './context'\nimport { calcOffset } from './utils'\n\nexport const runReplacer = (\n  ctx: Ctx,\n  key: PluginKey,\n  state: EditorState,\n  dispatch: (tr: Transaction) => void,\n  attrs: Attrs,\n) => {\n  const { placeholderConfig } = ctx.get(inlineSyncConfigCtx)\n  const holePlaceholder = placeholderConfig.hole\n  // insert a placeholder to restore the selection\n  let tr = state.tr.setMeta(key, true).insertText(holePlaceholder, state.selection.from)\n\n  const nextState = state.apply(tr)\n  const context = getContextByState(ctx, nextState)\n\n  if (!context)\n    return\n\n  const { $from } = nextState.selection\n  const from = $from.before()\n  const to = $from.after()\n\n  const offset = calcOffset(context.nextNode, from, context.placeholder)\n\n  tr = tr\n    .replaceWith(from, to, context.nextNode)\n    .setNodeMarkup(from, undefined, attrs)\n  // delete the placeholder\n    .delete(offset + 1, offset + 2)\n\n  // restore the selection\n  tr = tr.setSelection(TextSelection.near(tr.doc.resolve(offset + 1)))\n\n  dispatch(tr)\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx } from '@milkdown/core'\nimport { Plugin, PluginKey } from '@milkdown/prose/state'\n\nimport { inlineSyncConfigCtx } from './config'\nimport { getContextByState } from './context'\nimport { runReplacer } from './replacer'\n\nexport * from './config'\n\nexport const inlineSyncPluginKey = new PluginKey('MILKDOWN_INLINE_SYNC')\nexport const getInlineSyncPlugin = (ctx: Ctx) => {\n  let requestId: number | null = null\n  const inlineSyncPlugin = new Plugin<null>({\n    key: inlineSyncPluginKey,\n    state: {\n      init: () => {\n        return null\n      },\n      apply: (tr, _value, _oldState, newState) => {\n        const view = ctx.get(editorViewCtx)\n        if (!view.hasFocus?.() || !view.editable)\n          return null\n\n        if (!tr.docChanged)\n          return null\n\n        const meta = tr.getMeta(inlineSyncPluginKey)\n        if (meta)\n          return null\n\n        const context = getContextByState(ctx, newState)\n        if (!context)\n          return null\n\n        if (requestId) {\n          cancelAnimationFrame(requestId)\n          requestId = null\n        }\n\n        const { prevNode, nextNode, text } = context\n\n        const { shouldSyncNode } = ctx.get(inlineSyncConfigCtx)\n\n        if (!shouldSyncNode({ prevNode, nextNode, ctx, tr, text }))\n          return null\n\n        requestId = requestAnimationFrame(() => {\n          requestId = null\n\n          const { dispatch, state } = ctx.get(editorViewCtx)\n\n          runReplacer(ctx, inlineSyncPluginKey, state, dispatch, prevNode.attrs)\n        })\n\n        return null\n      },\n    },\n  })\n\n  return inlineSyncPlugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createPlugin } from '@milkdown/utils'\nimport links from 'remark-inline-links'\n\nimport { addOrderInList } from './add-order-in-list'\nimport { filterHTMLPlugin } from './filter-html'\nimport { getInlineNodesCursorPlugin } from './inline-nodes-cursor'\nimport { getInlineSyncPlugin, inlineSyncConfigCtx } from './inline-sync'\n\nexport { inlineSyncConfigCtx }\nexport const commonmarkPlugins = [\n  createPlugin(() => ({\n    injectSlices: [inlineSyncConfigCtx],\n    prosePlugins: (_, ctx) => [getInlineNodesCursorPlugin(), getInlineSyncPlugin(ctx)],\n    remarkPlugins: () => [links, filterHTMLPlugin, addOrderInList],\n  }))(),\n]\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { AtomList } from '@milkdown/utils'\n\nimport { ModifyLink, ToggleBold, ToggleInlineCode, ToggleItalic, ToggleLink, marks } from './mark'\nimport {\n  InsertHardbreak,\n  InsertHr,\n  InsertImage,\n  LiftListItem,\n  ModifyImage,\n  SinkListItem,\n  SplitListItem,\n  TurnIntoCodeFence,\n  TurnIntoHeading,\n  TurnIntoText,\n  WrapInBlockquote,\n  WrapInBulletList,\n  WrapInOrderedList,\n  nodes,\n} from './node'\nimport { commonmarkPlugins } from './plugin'\n\nexport * from './mark'\nexport * from './node'\nexport { inlineSyncConfigCtx } from './plugin'\nexport * from './supported-keys'\n\nexport const commonmarkNodes = AtomList.create([...nodes, ...marks])\nexport { commonmarkPlugins }\nexport const commonmark = AtomList.create([...commonmarkPlugins, ...commonmarkNodes])\n\nexport const commands = {\n  ToggleInlineCode,\n  ToggleItalic,\n  ToggleLink,\n  ToggleBold,\n\n  ModifyLink,\n  ModifyImage,\n\n  WrapInBlockquote,\n  WrapInBulletList,\n  WrapInOrderedList,\n\n  TurnIntoCodeFence,\n  TurnIntoHeading,\n  TurnIntoText,\n\n  InsertHardbreak,\n  InsertHr,\n  InsertImage,\n\n  SplitListItem,\n  SinkListItem,\n  LiftListItem,\n} as const\nexport type Commands = typeof commands\n"],"names":["SupportedKeys","id","ToggleInlineCode","createCmdKey","codeInline","createMark","utils","mark","node","state","markType","createCmd","dispatch","selection","tr","from","to","x","name","t","createShortcut","ToggleItalic","em","value","toggleMark","key","PluginKey","ToggleLink","ModifyLink","link","options","dom","expectDomTypeError","url","title","href","marks","pos","n","p","_a","type","start","end","linkMark","TextSelection","ctx","renderOnTop","Plugin","editorView","inputChipRenderer","_b","_c","commandsCtx","view","input","calculateTextPosition","target","parent","$editor","missingRootElement","selectionWidth","left","top","maxLeft","shouldDisplay","doc","NodeSelection","getCurrentLink","m","renderByView","prevState","ToggleBold","strong","WrapInBlockquote","blockquote","createNode","nodeType","wrappingInputRule","wrapIn","WrapInBulletList","bulletList","ordered","spread","languageOptions","backtickInputRegex","tildeInputRegex","TurnIntoCodeFence","codeFence","languageList","schema","text","Fragment","textNode","select","lang","option","e","editorViewCtx","result","language","textblockTypeInputRule","match","ok","setBlockType","getPos","currNode","onSelectLanguage","onBlur","onFocus","renderer","contentDOM","onUpdate","onDestroy","updatedNode","InsertHardbreak","HardbreakFilterPluginKey","hardbreak","notIn","_","Selection","isInsertHr","step","$from","curDepth","canApply","trs","_oldState","newState","ReplaceStep","AddMarkStep","_tr","headingIndex","i","TurnIntoHeading","DowngradeHeading","headingIdPluginKey","headingHashPluginKey","createId","headingIdPlugin","getId","lock","walkThrough","callback","found","attrs","transactions","nextState","transaction","headingHashPlugin","DecorationSet","level","getHashes","widget","style","css","palette","getPalette","deco","Decoration","cloneTr","heading","displayHashtag","depth","contentArr","schemaCtx","plugins","InsertHr","hr","InputRule","paragraph","sel","ModifyImage","InsertImage","image","alt","src","findSelectedNodeOfType","okay","placeholder","isBlock","SplitListItem","SinkListItem","LiftListItem","keepListOrderPluginKey","createKeepListOrderPlugin","orderedListType","getNodeFromSchema","index","changed","base","listItem","body","checked","label","listType","splitListItem","sinkListItem","liftListItem","WrapInOrderedList","orderedList","TurnIntoText","nodes","addOrderInList","transformer","ast","visit","child","isParent","isHTML","flatMapWithDepth","fn","transform","out","nthChild","xs","j","item","filterHTMLPlugin","tree","inlineNodesCursorPluginKey","getInlineNodesCursorPlugin","inlineNodesCursorPlugin","right","position","leftDec","rightDec","linkRegexp","punctuationRegexp","holePlaceholder","keepLink","str","span","swap","first","last","arr","temp","replacePunctuation","calculatePlaceholder","notAWord","calcOffset","offset","find","defaultConfig","prevNode","nextNode","placeholderToMove","symbolsNeedToMove","inlineSyncConfigCtx","createSlice","getNodeFromSelection","getMarkdown","globalNode","serializer","serializerCtx","addPlaceholder","markdown","config","firstLine","rest","movePlaceholder","pipe","getNewNode","parsed","parserCtx","collectGlobalNodes","globalNodes","removeGlobalFromText","getContextByState","newNode","runReplacer","placeholderConfig","context","inlineSyncPluginKey","getInlineSyncPlugin","requestId","_value","shouldSyncNode","commonmarkPlugins","createPlugin","links","commonmarkNodes","AtomList","commonmark","commands"],"mappings":"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"}