import { createMark as q, createShortcut as M, createNode as C, pipe as Se, createPlugin as ve, AtomList as we } from "@milkdown/utils";
import { createCmdKey as I, createCmd as N, commandsCtx as Le, editorViewCtx as v, schemaCtx as R, getPalette as Ae, createSlice as Ee, serializerCtx as _e, parserCtx as $e } from "@milkdown/core";
import { toggleMark as pe, wrapIn as ge, setBlockType as A } from "@milkdown/prose/commands";
import { expectDomTypeError as x, missingRootElement as Pe } from "@milkdown/exception";
import { calculateTextPosition as Be, cloneTr as Re, findSelectedNodeOfType as F, getNodeFromSchema as We } from "@milkdown/prose";
import { PluginKey as H, TextSelection as Q, Plugin as T, NodeSelection as qe, Selection as Ce } from "@milkdown/prose/state";
import { wrappingInputRule as K, textblockTypeInputRule as X, InputRule as xe } from "@milkdown/prose/inputrules";
import { Fragment as W } from "@milkdown/prose/model";
import { ReplaceStep as Ke, AddMarkStep as Fe } from "@milkdown/prose/transform";
import { DecorationSet as S, Decoration as Z } from "@milkdown/prose/view";
import { splitListItem as je, sinkListItem as ze, liftListItem as Ue } from "@milkdown/prose/schema-list";
import Ve from "remark-inline-links";
import { visit as Ge } from "unist-util-visit";
const y = {
  HardBreak: "HardBreak",
  Blockquote: "Blockquote",
  BulletList: "BulletList",
  OrderedList: "OrderedList",
  CodeFence: "CodeFence",
  H1: "H1",
  H2: "H2",
  H3: "H3",
  H4: "H4",
  H5: "H5",
  H6: "H6",
  DowngradeHeading: "DowngradeHeading",
  Text: "Text",
  CodeInline: "CodeInline",
  Em: "Em",
  Bold: "Bold",
  NextListItem: "NextListItem",
  SinkListItem: "SinkListItem",
  LiftListItem: "LiftListItem"
}, ke = "code_inline", ee = I("ToggleInlineCode"), Ye = q((a) => ({
  id: ke,
  schema: () => ({
    priority: 100,
    code: !0,
    inclusive: !1,
    parseDOM: [{ tag: "code" }],
    toDOM: (e) => ["code", { class: a.getClassName(e.attrs, "code-inline") }],
    parseMarkdown: {
      match: (e) => e.type === "inlineCode",
      runner: (e, t, r) => {
        e.openMark(r), e.addText(t.value), e.closeMark(r);
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === ke,
      runner: (e, t, r) => {
        e.withMark(t, "inlineCode", r.text || "");
      }
    }
  }),
  commands: (e) => [
    N(ee, () => (t, r) => {
      const { selection: n, tr: o } = t;
      if (n.empty)
        return !1;
      const { from: l, to: s } = n;
      return t.doc.rangeHasMark(l, s, e) ? (r == null || r(o.removeMark(l, s, e)), !0) : (Object.keys(t.schema.marks).filter((u) => u !== e.name).map((u) => t.schema.marks[u]).forEach((u) => {
        o.removeMark(l, s, u);
      }), r == null || r(o.addMark(l, s, e.create())), !0);
    })
  ],
  shortcuts: {
    [y.CodeInline]: M(ee, "Mod-e")
  }
})), j = "em", te = I("ToggleItalic"), Je = q((a) => ({
  id: j,
  schema: () => ({
    inclusive: !1,
    parseDOM: [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style", getAttrs: (e) => e === "italic" }
    ],
    toDOM: (e) => ["em", { class: a.getClassName(e.attrs, j) }],
    parseMarkdown: {
      match: (e) => e.type === "emphasis",
      runner: (e, t, r) => {
        e.openMark(r), e.next(t.children), e.closeMark(r);
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === j,
      runner: (e, t) => {
        e.withMark(t, "emphasis");
      }
    }
  }),
  commands: (e) => [N(te, () => pe(e))],
  shortcuts: {
    [y.Em]: M(te, "Mod-i")
  }
})), Qe = new H("MILKDOWN_LINK_INPUT"), Te = I("ToggleLink"), re = I("ModifyLink"), $ = "link", Xe = q((a, e) => ({
  id: $,
  schema: () => ({
    attrs: {
      href: {},
      title: { default: null }
    },
    parseDOM: [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          if (!(t instanceof HTMLElement))
            throw x(t);
          return { href: t.getAttribute("href"), title: t.getAttribute("title") };
        }
      }
    ],
    toDOM: (t) => ["a", { ...t.attrs, class: a.getClassName(t.attrs, $) }],
    parseMarkdown: {
      match: (t) => t.type === "link",
      runner: (t, r, n) => {
        const o = r.url, l = r.title;
        t.openMark(n, { href: o, title: l }), t.next(r.children), t.closeMark(n);
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === $,
      runner: (t, r) => {
        t.withMark(r, "link", void 0, {
          title: r.attrs.title,
          url: r.attrs.href
        });
      }
    }
  }),
  commands: (t) => [
    N(Te, (r = "") => pe(t, { href: r })),
    N(re, (r = "") => (n, o) => {
      var k;
      if (!o)
        return !1;
      const { marks: l } = n.schema;
      let s, c = -1;
      const { selection: i } = n, { from: u, to: f } = i;
      if (n.doc.nodesBetween(u, u === f ? f + 1 : f, (b, w) => {
        var L;
        if ((L = l.link) != null && L.isInSet(b.marks))
          return s = b, c = w, !1;
      }), !s)
        return !1;
      const d = s.marks.find(({ type: b }) => b === t);
      if (!d)
        return !1;
      const m = c, p = c + s.nodeSize, { tr: g } = n, h = (k = l.link) == null ? void 0 : k.create({ ...d.attrs, href: r });
      return h ? (o(
        g.removeMark(m, p, d).addMark(m, p, h).setSelection(new Q(g.selection.$anchor)).scrollIntoView()
      ), !0) : !1;
    })
  ],
  prosePlugins: (t, r) => {
    let n = !1;
    return [
      new T({
        key: Qe,
        view: (o) => {
          var u, f, d;
          const l = a.themeManager.get("input-chip", {
            placeholder: (f = (u = e == null ? void 0 : e.input) == null ? void 0 : u.placeholder) != null ? f : "Input Web Link",
            buttonText: (d = e == null ? void 0 : e.input) == null ? void 0 : d.buttonText,
            onUpdate: (m) => {
              r.get(Le).call(re, m);
            },
            calculatePosition: (m, p) => {
              Be(m, p, (g, h, k, b) => {
                const w = m.dom.parentElement;
                if (!w)
                  throw Pe();
                const L = h.left - g.left;
                let D = g.left - b.left - (k.width - L) / 2, _ = g.bottom - b.top + 14 + w.scrollTop;
                n && (_ = g.top - b.top - k.height - 14 + w.scrollTop), D < 0 && (D = 0);
                const he = w.clientWidth - (k.width + 4);
                return D > he && (D = he), [_, D];
              });
            }
          });
          if (!l)
            return {};
          const s = (m) => {
            var b;
            const { selection: p, doc: g } = m.state, { from: h, to: k } = p;
            if (!m.hasFocus())
              return !1;
            if (p instanceof Q && k < g.content.size && h < g.content.size && g.rangeHasMark(h, h === k ? k + 1 : k, t)) {
              let w = p.empty;
              if (((b = e == null ? void 0 : e.input) == null ? void 0 : b.displayWhenSelected) && !w && g.nodesBetween(h, h === k ? k + 1 : k, (L, D) => {
                if (L.marks.some(
                  (_) => _.type === t && h >= D && k <= D + L.nodeSize
                ))
                  return w = !0, !1;
              }), w)
                return n = !1, !0;
            }
            if (p instanceof qe) {
              const { node: w } = p;
              if (w.type.name === "image" && w.marks.findIndex((L) => L.type.name === $) > -1)
                return n = !0, !0;
            }
            return !1;
          }, c = (m) => {
            const { selection: p } = m.state;
            let g;
            const { from: h, to: k } = p;
            if (m.state.doc.nodesBetween(h, h === k ? k + 1 : k, (L) => {
              if (t.isInSet(L.marks))
                return g = L, !1;
            }), !g)
              return;
            const b = g.marks.find((L) => L.type === t);
            return b ? b.attrs.href : void 0;
          }, i = (m) => {
            if (!m.editable)
              return;
            s(m) ? (l.show(m), l.update(c(m))) : l.hide();
          };
          return l.init(o), i(o), {
            update: (m, p) => {
              (p == null ? void 0 : p.doc.eq(m.state.doc)) && p.selection.eq(m.state.selection) || requestAnimationFrame(() => {
                i(m);
              });
            },
            destroy: () => {
              l.destroy();
            }
          };
        }
      })
    ];
  }
})), z = "strong", ne = I("ToggleBold"), Ze = q((a) => ({
  id: z,
  schema: () => ({
    inclusive: !1,
    parseDOM: [
      { tag: "b" },
      { tag: "strong" },
      { style: "font-style", getAttrs: (e) => e === "bold" }
    ],
    toDOM: (e) => ["strong", { class: a.getClassName(e.attrs, z) }],
    parseMarkdown: {
      match: (e) => e.type === "strong",
      runner: (e, t, r) => {
        e.openMark(r), e.next(t.children), e.closeMark(r);
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === z,
      runner: (e, t) => {
        e.withMark(t, "strong");
      }
    }
  }),
  commands: (e) => [N(ne, () => pe(e))],
  shortcuts: {
    [y.Bold]: M(ne, "Mod-b")
  }
})), et = [Ye(), Je(), Ze(), Xe()], P = "blockquote", se = I("WrapInBlockquote"), tt = C((a) => ({
  id: P,
  schema: () => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", { class: a.getClassName(e.attrs, P) }, 0],
    parseMarkdown: {
      match: ({ type: e }) => e === P,
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === P,
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  }),
  inputRules: (e) => [K(/^\s*>\s$/, e)],
  commands: (e) => [N(se, () => ge(e))],
  shortcuts: {
    [y.Blockquote]: M(se, "Mod-Shift-b")
  }
})), oe = I("WrapInBulletList"), rt = C((a) => {
  const e = "bullet_list";
  return {
    id: e,
    schema: () => ({
      content: "listItem+",
      group: "block",
      attrs: {
        spread: {
          default: !1
        }
      },
      parseDOM: [
        {
          tag: "ul",
          getAttrs: (t) => {
            if (!(t instanceof HTMLElement))
              throw x(t);
            return {
              spread: t.dataset.spread
            };
          }
        }
      ],
      toDOM: (t) => [
        "ul",
        {
          "data-spread": t.attrs.spread,
          class: a.getClassName(t.attrs, "bullet-list")
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: t, ordered: r }) => t === "list" && !r,
        runner: (t, r, n) => {
          const o = r.spread != null ? `${r.spread}` : "false";
          t.openNode(n, { spread: o }).next(r.children).closeNode();
        }
      },
      toMarkdown: {
        match: (t) => t.type.name === e,
        runner: (t, r) => {
          t.openNode("list", void 0, { ordered: !1, spread: r.attrs.spread === "true" }).next(r.content).closeNode();
        }
      }
    }),
    inputRules: (t) => [K(/^\s*([-+*])\s$/, t)],
    commands: (t) => [N(oe, () => ge(t))],
    shortcuts: {
      [y.BulletList]: M(oe, "Mod-Alt-8")
    }
  };
}), nt = [
  "",
  "javascript",
  "typescript",
  "bash",
  "sql",
  "json",
  "html",
  "css",
  "c",
  "cpp",
  "java",
  "ruby",
  "python",
  "go",
  "rust",
  "markdown"
], st = /^```(?<language>[a-z]*)?[\s\n]$/, ot = /^~~~(?<language>[a-z]*)?[\s\n]$/, ae = I("TurnIntoCodeFence"), U = "fence", at = C((a, e) => {
  const t = (e == null ? void 0 : e.languageList) || nt;
  return {
    id: U,
    schema: (r) => ({
      content: "text*",
      group: "block",
      marks: "",
      defining: !0,
      code: !0,
      attrs: {
        language: {
          default: ""
        },
        fold: {
          default: !0
        }
      },
      parseDOM: [
        {
          tag: "div.code-fence-container",
          preserveWhitespace: "full",
          getAttrs: (n) => {
            var o;
            if (!(n instanceof HTMLElement))
              throw x(n);
            return { language: (o = n.querySelector("pre")) == null ? void 0 : o.dataset.language };
          },
          getContent: (n, o) => {
            var c, i;
            if (!(n instanceof HTMLElement))
              throw x(n);
            const l = (i = (c = n.querySelector("pre")) == null ? void 0 : c.textContent) != null ? i : "";
            if (!l)
              return W.empty;
            const s = o.text(l);
            return W.from(s);
          }
        },
        {
          tag: "pre",
          preserveWhitespace: "full",
          getAttrs: (n) => {
            if (!(n instanceof HTMLElement))
              throw x(n);
            return { language: n.dataset.language };
          }
        }
      ],
      toDOM: (n) => {
        const o = document.createElement("select");
        return t.forEach((l) => {
          const s = document.createElement("option");
          s.value = l, s.innerText = l || "--", l === n.attrs.language && (s.selected = !0), o.appendChild(s);
        }), o.onchange = (l) => {
          const s = l.target;
          if (!(s instanceof HTMLSelectElement))
            return;
          const c = r.get(v);
          if (!c.editable) {
            s.value = n.attrs.language;
            return;
          }
          const { top: i, left: u } = s.getBoundingClientRect(), f = c.posAtCoords({ top: i, left: u });
          if (!f)
            return;
          const { tr: d } = c.state;
          c.dispatch(
            d.setNodeMarkup(f.inside, void 0, {
              ...n.attrs,
              language: s.value
            })
          );
        }, [
          "div",
          {
            class: "code-fence-container"
          },
          o,
          [
            "pre",
            {
              "data-language": n.attrs.language,
              class: a.getClassName(n.attrs, "code-fence")
            },
            ["code", { spellCheck: "false" }, 0]
          ]
        ];
      },
      parseMarkdown: {
        match: ({ type: n }) => n === "code",
        runner: (n, o, l) => {
          const s = o.lang, c = o.value;
          n.openNode(l, { language: s }), c && n.addText(c), n.closeNode();
        }
      },
      toMarkdown: {
        match: (n) => n.type.name === U,
        runner: (n, o) => {
          var l;
          n.addNode("code", void 0, ((l = o.content.firstChild) == null ? void 0 : l.text) || "", {
            lang: o.attrs.language
          });
        }
      }
    }),
    inputRules: (r) => [
      X(st, r, (n) => {
        const [o, l] = n;
        if (!!o)
          return { language: l };
      }),
      X(ot, r, (n) => {
        const [o, l] = n;
        if (!!o)
          return { language: l };
      })
    ],
    commands: (r) => [N(ae, () => A(r))],
    shortcuts: {
      [y.CodeFence]: M(ae, "Mod-Alt-c")
    },
    view: () => (r, n, o) => {
      let l = r;
      const s = (g) => {
        const { tr: h } = n.state;
        n.dispatch(
          h.setNodeMarkup(o(), void 0, {
            fold: !0,
            language: g
          })
        );
      }, c = () => {
        const { tr: g } = n.state;
        n.dispatch(
          g.setNodeMarkup(o(), void 0, {
            ...l.attrs,
            fold: !0
          })
        );
      }, i = () => {
        const { tr: g } = n.state;
        n.dispatch(
          g.setNodeMarkup(o(), void 0, {
            ...l.attrs,
            fold: !1
          })
        );
      }, u = a.themeManager.get("code-fence", {
        view: n,
        onBlur: c,
        onFocus: i,
        onSelectLanguage: s,
        editable: () => n.editable,
        languageList: t
      });
      if (!u)
        return {};
      const { dom: f, contentDOM: d, onUpdate: m, onDestroy: p } = u;
      return m(l), {
        dom: f,
        contentDOM: d,
        update: (g) => g.type.name !== U ? !1 : (l = g, m(l), !0),
        destroy: p
      };
    }
  };
}), lt = C(() => ({
  id: "doc",
  schema: () => ({
    content: "block+",
    parseMarkdown: {
      match: ({ type: a }) => a === "root",
      runner: (a, e, t) => {
        a.injectRoot(e, t);
      }
    },
    toMarkdown: {
      match: (a) => a.type.name === "doc",
      runner: (a, e) => {
        a.openNode("root"), a.next(e.content);
      }
    }
  })
})), le = I("InsertHardbreak"), ct = new H("MILKDOWN_HARDBREAK_FILTER"), it = C((a, e) => {
  var r;
  const t = (r = e == null ? void 0 : e.notIn) != null ? r : ["table", "fence"];
  return {
    id: "hardbreak",
    schema: () => ({
      inline: !0,
      group: "inline",
      selectable: !1,
      parseDOM: [{ tag: "br" }],
      toDOM: (n) => ["br", { class: a.getClassName(n.attrs, "hardbreak") }],
      parseMarkdown: {
        match: ({ type: n }) => n === "break",
        runner: (n, o, l) => {
          n.addNode(l);
        }
      },
      toMarkdown: {
        match: (n) => n.type.name === "hardbreak",
        runner: (n) => {
          n.addNode("break");
        }
      }
    }),
    commands: (n) => [
      N(le, () => (o, l) => {
        var i;
        const { selection: s, tr: c } = o;
        if (s.empty) {
          const u = s.$from.node();
          if (u.childCount > 0 && ((i = u.lastChild) == null ? void 0 : i.type.name) === "hardbreak")
            return l == null || l(
              c.replaceRangeWith(s.to - 1, s.to, o.schema.node("paragraph")).setSelection(Ce.near(c.doc.resolve(s.to))).scrollIntoView()
            ), !0;
        }
        return l == null || l(c.setMeta("hardbreak", !0).replaceSelectionWith(n.create()).scrollIntoView()), !0;
      })
    ],
    shortcuts: {
      [y.HardBreak]: M(le, "Shift-Enter")
    },
    prosePlugins: (n) => [
      new T({
        key: ct,
        filterTransaction: (o, l) => {
          const s = o.getMeta("hardbreak"), [c] = o.steps;
          if (s && c) {
            const { from: i } = c, u = l.doc.resolve(i);
            let f = u.depth, d = !0;
            for (; f > 0; )
              t.includes(u.node(f).type.name) && (d = !1), f--;
            return d;
          }
          return !0;
        }
      }),
      new T({
        key: new H("MILKDOWN_HARDBREAK_MARKS"),
        appendTransaction: (o, l, s) => {
          if (!o.length)
            return;
          const [c] = o;
          if (!c)
            return;
          const [i] = c.steps;
          if (c.getMeta("hardbreak")) {
            if (!(i instanceof Ke))
              return;
            const { from: d } = i;
            return s.tr.setNodeMarkup(d, n, void 0, []);
          }
          if (i instanceof Fe) {
            let d = s.tr;
            const { from: m, to: p } = i;
            return s.doc.nodesBetween(m, p, (g, h) => {
              g.type === n && (d = d.setNodeMarkup(h, n, void 0, []));
            }), d;
          }
        }
      })
    ]
  };
}), Me = Array(6).fill(0).map((a, e) => e + 1), O = I("TurnIntoHeading"), ye = I("DowngradeHeading"), V = new H("MILKDOWN_HEADING_ID"), ut = new H("MILKDOWN_HEADING_HASH"), dt = (a) => a.textContent.replace(/[\p{P}\p{S}]/gu, "").replace(/\s/g, "-").toLowerCase().trim(), ft = (a, e, t) => {
  let r = !1;
  const n = (o, l) => {
    const s = o.tr.setMeta("addToHistory", !1);
    let c = !1;
    o.doc.descendants((i, u) => {
      if (i.type === e && !r) {
        if (i.textContent.trim().length === 0)
          return;
        const f = i.attrs, d = t(i);
        f.id !== d && (c = !0, s.setMeta(V, !0).setNodeMarkup(u, void 0, {
          ...f,
          id: d
        }));
      }
    }), c && l(s);
  };
  return new T({
    key: V,
    props: {
      handleDOMEvents: {
        compositionstart: () => (r = !0, !1),
        compositionend: () => {
          r = !1;
          const o = a.get(v);
          return setTimeout(() => {
            n(o.state, (l) => o.dispatch(l));
          }, 0), !1;
        }
      }
    },
    appendTransaction: (o, l, s) => {
      let c = null;
      return o.every((i) => !i.getMeta(V)) && o.some((i) => i.docChanged) && n(s, (i) => {
        c = i;
      }), c;
    },
    view: (o) => {
      const l = o.state.doc;
      let s = o.state.tr.setMeta("addToHistory", !1);
      return l.descendants((c, i) => {
        c.type.name === "heading" && c.attrs.level && (c.attrs.id || (s = s.setNodeMarkup(i, void 0, {
          ...c.attrs,
          id: t(c)
        })));
      }), o.dispatch(s), {};
    }
  });
}, mt = (a, e, t) => new T({
  key: ut,
  state: {
    init: () => S.empty,
    apply: (r) => {
      var f;
      const n = a.get(v);
      if (!((f = n.hasFocus) != null && f.call(n)) || !n.editable)
        return S.empty;
      const { $from: o } = r.selection, l = o.node();
      if (l.type !== e)
        return S.empty;
      const s = l.attrs.level, c = (d) => Array(d).fill(0).map((m) => "#").join(""), i = document.createElement("span");
      i.textContent = c(s), i.contentEditable = "false", t.themeManager.onFlush(() => {
        const d = t.getStyle(({ css: m }) => {
          const p = Ae(t.themeManager);
          return m`
                            margin-right: 4px;
                            color: ${p("primary")};
                        `;
        });
        d && (i.className = d);
      });
      const u = Z.widget(o.before() + 1, i, { side: -1 });
      return S.create(r.doc, [u]);
    }
  },
  props: {
    handleDOMEvents: {
      focus: (r) => {
        const n = Re(r.state.tr);
        return r.dispatch(n), !1;
      }
    },
    decorations(r) {
      return this.getState(r);
    }
  }
}), pt = C(
  (a, e) => {
    var o, l;
    const t = "heading", r = (o = e == null ? void 0 : e.getId) != null ? o : dt, n = (l = e == null ? void 0 : e.displayHashtag) != null ? l : !0;
    return {
      id: t,
      schema: () => ({
        content: "inline*",
        group: "block",
        defining: !0,
        attrs: {
          id: {
            default: ""
          },
          level: {
            default: 1
          }
        },
        parseDOM: Me.map((s) => ({
          tag: `h${s}`,
          getAttrs: (c) => {
            if (!(c instanceof HTMLElement))
              throw x(c);
            return { level: s, id: c.id };
          }
        })),
        toDOM: (s) => [
          `h${s.attrs.level}`,
          {
            id: s.attrs.id || r(s),
            class: a.getClassName(s.attrs, `heading h${s.attrs.level}`)
          },
          0
        ],
        parseMarkdown: {
          match: ({ type: s }) => s === t,
          runner: (s, c, i) => {
            const u = c.depth;
            s.openNode(i, { level: u }), s.next(c.children), s.closeNode();
          }
        },
        toMarkdown: {
          match: (s) => s.type.name === t,
          runner: (s, c) => {
            var u;
            if (s.openNode("heading", void 0, { depth: c.attrs.level }), c.childCount >= 1 && ((u = c.lastChild) == null ? void 0 : u.type.name) === "hardbreak") {
              const f = [];
              c.content.forEach((d, m, p) => {
                p !== c.childCount - 1 && f.push(d);
              }), s.next(W.fromArray(f));
            } else
              s.next(c.content);
            s.closeNode();
          }
        }
      }),
      inputRules: (s, c) => Me.map(
        (i) => X(new RegExp(`^(#{1,${i}})\\s$`), s, () => {
          const u = c.get(v), { $from: f } = u.state.selection, d = f.node();
          if (d.type.name === "heading") {
            let m = Number(d.attrs.level) + Number(i);
            return m > 6 && (m = 6), {
              level: m
            };
          }
          return {
            level: i
          };
        })
      ),
      commands: (s, c) => [
        N(O, (i = 1) => i < 1 ? A(i === 0 && c.get(R).nodes.paragraph || s) : A(i === 0 && c.get(R).nodes.paragraph || s, { level: i })),
        N(ye, () => (i, u, f) => {
          const { $from: d } = i.selection, m = d.node();
          if (m.type !== s || !i.selection.empty || d.parentOffset !== 0)
            return !1;
          const p = m.attrs.level - 1;
          return p ? (u == null || u(
            i.tr.setNodeMarkup(i.selection.$from.before(), void 0, {
              ...m.attrs,
              level: p
            })
          ), !0) : A(c.get(R).nodes.paragraph || s)(i, u, f);
        })
      ],
      shortcuts: {
        [y.H1]: M(O, "Mod-Alt-1", 1),
        [y.H2]: M(O, "Mod-Alt-2", 2),
        [y.H3]: M(O, "Mod-Alt-3", 3),
        [y.H4]: M(O, "Mod-Alt-4", 4),
        [y.H5]: M(O, "Mod-Alt-5", 5),
        [y.H6]: M(O, "Mod-Alt-6", 6),
        [y.DowngradeHeading]: M(ye, ["Backspace", "Delete"])
      },
      prosePlugins: (s, c) => {
        const i = [ft(c, s, r)];
        return n && i.push(mt(c, s, a)), i;
      }
    };
  }
), G = "hr", He = I("InsertHr"), gt = C((a) => ({
  id: G,
  schema: () => ({
    group: "block",
    parseDOM: [{ tag: "hr" }],
    toDOM: (e) => ["hr", { class: a.getClassName(e.attrs, G) }],
    parseMarkdown: {
      match: ({ type: e }) => e === "thematicBreak",
      runner: (e, t, r) => {
        e.addNode(r);
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === G,
      runner: (e) => {
        e.addNode("thematicBreak");
      }
    }
  }),
  inputRules: (e) => [
    new xe(/^(?:---|___\s|\*\*\*\s)$/, (t, r, n, o) => {
      const { tr: l } = t;
      return r[0] && l.replaceWith(n - 1, o, e.create()), l;
    })
  ],
  commands: (e, t) => [
    N(He, () => (r, n) => {
      if (!n)
        return !0;
      const o = t.get(R).node("paragraph"), { tr: l, selection: s } = r, { from: c } = s, i = e.create();
      if (!i)
        return !0;
      const u = l.replaceSelectionWith(i).insert(c, o), f = Ce.findFrom(u.doc.resolve(c), 1, !0);
      return f && n(u.setSelection(f).scrollIntoView()), !0;
    })
  ]
})), ce = I("ModifyImage"), De = I("InsertImage"), B = "image", ht = new H("MILKDOWN_IMAGE_INPUT"), kt = C((a, e) => ({
  id: "image",
  schema: () => ({
    inline: !0,
    group: "inline",
    selectable: !0,
    draggable: !0,
    marks: "",
    atom: !0,
    defining: !0,
    isolating: !0,
    attrs: {
      src: { default: "" },
      alt: { default: "" },
      title: { default: "" }
    },
    parseDOM: [
      {
        tag: "img[src]",
        getAttrs: (t) => {
          if (!(t instanceof HTMLElement))
            throw x(t);
          return {
            src: t.getAttribute("src") || "",
            alt: t.getAttribute("alt") || "",
            title: t.getAttribute("title") || t.getAttribute("alt") || ""
          };
        }
      }
    ],
    toDOM: (t) => [
      "img",
      {
        ...t.attrs,
        class: a.getClassName(t.attrs, B)
      }
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === B,
      runner: (t, r, n) => {
        const o = r.url, l = r.alt, s = r.title;
        t.addNode(n, {
          src: o,
          alt: l,
          title: s
        });
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === B,
      runner: (t, r) => {
        t.addNode("image", void 0, void 0, {
          title: r.attrs.title,
          url: r.attrs.src,
          alt: r.attrs.alt
        });
      }
    }
  }),
  commands: (t) => [
    N(De, (r = "") => (n, o) => {
      if (!o)
        return !0;
      const { tr: l } = n, s = t.create({ src: r });
      if (!s)
        return !0;
      const c = l.replaceSelectionWith(s);
      return o(c.scrollIntoView()), !0;
    }),
    N(ce, (r = "") => (n, o) => {
      const l = F(n.selection, t);
      if (!l)
        return !1;
      const { tr: s } = n;
      return o == null || o(
        s.setNodeMarkup(l.pos, void 0, { ...l.node.attrs, loading: !0, src: r }).scrollIntoView()
      ), !0;
    })
  ],
  inputRules: (t) => [
    new xe(
      /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
      (r, n, o, l) => {
        const [s, c, i = "", u] = n, { tr: f } = r;
        return s && f.replaceWith(o, l, t.create({ src: i, alt: c, title: u })), f;
      }
    )
  ],
  view: () => (t) => {
    var i, u;
    let r = t;
    const n = (i = e == null ? void 0 : e.placeholder) != null ? i : "Add an Image", o = (u = e == null ? void 0 : e.isBlock) != null ? u : !1, l = a.themeManager.get("image", {
      placeholder: n,
      isBlock: o
    });
    if (!l)
      return {};
    const { dom: s, onUpdate: c } = l;
    return c(r), {
      dom: s,
      update: (f) => f.type.name !== B ? !1 : (r = f, c(r), !0),
      selectNode: () => {
        s.classList.add("ProseMirror-selectednode");
      },
      deselectNode: () => {
        s.classList.remove("ProseMirror-selectednode");
      }
    };
  },
  prosePlugins: (t, r) => [
    new T({
      key: ht,
      view: (n) => {
        var i, u, f;
        const o = a.themeManager.get("input-chip", {
          placeholder: (u = (i = e == null ? void 0 : e.input) == null ? void 0 : i.placeholder) != null ? u : "Input Image Link",
          buttonText: (f = e == null ? void 0 : e.input) == null ? void 0 : f.buttonText,
          onUpdate: (d) => {
            r.get(Le).call(ce, d);
          }
        });
        if (!o)
          return {};
        const l = (d) => Boolean(
          d.hasFocus() && t && F(d.state.selection, t)
        ), s = (d) => {
          const m = F(d.state.selection, t);
          return m ? m.node.attrs.src : void 0;
        }, c = (d) => {
          if (!d.editable)
            return;
          l(d) ? (o.show(d), o.update(s(d))) : o.hide();
        };
        return o.init(n), c(n), {
          update: (d, m) => {
            (m == null ? void 0 : m.doc.eq(d.state.doc)) && m.selection.eq(d.state.selection) || c(d);
          },
          destroy: () => {
            o.destroy();
          }
        };
      }
    })
  ]
})), Ne = "list_item", ie = I("SplitListItem"), ue = I("SinkListItem"), de = I("LiftListItem"), Mt = new H("MILKDOWN_KEEP_LIST_ORDER"), yt = (a) => {
  const e = (t, r) => {
    const n = We("ordered_list", t.schema);
    let o = t.tr;
    t.doc.descendants((l, s, c, i) => {
      if (l.type === a && (c == null ? void 0 : c.type) === n) {
        let u = !1;
        const f = { ...l.attrs };
        l.attrs.listType !== "ordered" && (f.listType = "ordered", u = !0);
        const d = c == null ? void 0 : c.maybeChild(0);
        d && d.type === a && d.attrs.listType === "ordered" && (f.label = `${i + 1}.`, u = !0), l.attrs.label === "\u2022" && (f.label = `${i + 1}.`, u = !0), u && (o = o.setNodeMarkup(s, void 0, f));
      }
    }), r(o);
  };
  return new T({
    key: Mt,
    appendTransaction: (t, r, n) => {
      let o = null;
      return t.some((l) => l.docChanged) && e(n, (l) => {
        o = l;
      }), o;
    }
  });
}, Nt = C((a) => ({
  id: Ne,
  schema: () => ({
    group: "listItem",
    content: "paragraph block*",
    attrs: {
      label: {
        default: "\u2022"
      },
      listType: {
        default: "bullet"
      },
      spread: {
        default: "true"
      }
    },
    defining: !0,
    parseDOM: [
      {
        tag: "li.list-item",
        getAttrs: (e) => {
          if (!(e instanceof HTMLElement))
            throw x(e);
          return {
            label: e.dataset.label,
            listType: e.dataset["list-type"],
            spread: e.dataset.spread
          };
        },
        contentElement: (e) => {
          if (!(e instanceof HTMLElement))
            throw x(e);
          const t = e.querySelector(".list-item_body");
          return t || e;
        }
      },
      { tag: "li" }
    ],
    toDOM: (e) => [
      "li",
      {
        class: a.getClassName(e.attrs, "list-item"),
        "data-label": e.attrs.label,
        "data-list-type": e.attrs.listType,
        "data-spread": e.attrs.spread
      },
      ["div", { class: a.getClassName(e.attrs, "list-item_label") }, e.attrs.label],
      ["div", { class: a.getClassName(e.attrs, "list-item_body") }, 0]
    ],
    parseMarkdown: {
      match: ({ type: e, checked: t }) => e === "listItem" && t === null,
      runner: (e, t, r) => {
        const n = t.label != null ? `${t.label}.` : "\u2022", o = t.label != null ? "ordered" : "bullet", l = t.spread != null ? `${t.spread}` : "true";
        e.openNode(r, { label: n, listType: o, spread: l }), e.next(t.children), e.closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === Ne,
      runner: (e, t) => {
        e.openNode("listItem", void 0, { spread: t.attrs.spread === "true" }), e.next(t.content), e.closeNode();
      }
    }
  }),
  inputRules: (e) => [K(/^\s*([-+*])\s$/, e)],
  commands: (e) => [
    N(ie, () => je(e)),
    N(ue, () => ze(e)),
    N(de, () => Ue(e))
  ],
  shortcuts: {
    [y.NextListItem]: M(ie, "Enter"),
    [y.SinkListItem]: M(ue, "Mod-]"),
    [y.LiftListItem]: M(de, "Mod-[")
  },
  prosePlugins: (e) => [yt(e)]
})), fe = I("WrapInOrderedList"), Ie = "ordered_list", It = C((a) => ({
  id: Ie,
  schema: () => ({
    content: "listItem+",
    group: "block",
    attrs: {
      order: {
        default: 1
      },
      spread: {
        default: !1
      }
    },
    parseDOM: [
      {
        tag: "ol",
        getAttrs: (e) => {
          if (!(e instanceof HTMLElement))
            throw x(e);
          return {
            spread: e.dataset.spread,
            order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
          };
        }
      }
    ],
    toDOM: (e) => [
      "ol",
      {
        ...e.attrs.order === 1 ? {} : e.attrs.order,
        "data-spread": e.attrs.spread,
        class: a.getClassName(e.attrs, "ordered-list")
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: e, ordered: t }) => e === "list" && !!t,
      runner: (e, t, r) => {
        const n = t.spread != null ? `${t.spread}` : "true";
        e.openNode(r, { spread: n }).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === Ie,
      runner: (e, t) => {
        e.openNode("list", void 0, { ordered: !0, start: 1, spread: t.attrs.spread === "true" }), e.next(t.content), e.closeNode();
      }
    }
  }),
  inputRules: (e) => [
    K(
      /^(\d+)\.\s$/,
      e,
      (t) => ({ order: Number(t[1]) }),
      (t, r) => r.childCount + r.attrs.order === Number(t[1])
    )
  ],
  commands: (e) => [N(fe, () => ge(e))],
  shortcuts: {
    [y.OrderedList]: M(fe, "Mod-Alt-7")
  }
})), me = I("TurnIntoText"), be = "paragraph", bt = C((a) => ({
  id: be,
  schema: () => ({
    content: "inline*",
    group: "block",
    parseDOM: [{ tag: "p" }],
    toDOM: (e) => ["p", { class: a.getClassName(e.attrs, be) }, 0],
    parseMarkdown: {
      match: (e) => e.type === "paragraph",
      runner: (e, t, r) => {
        e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value), e.closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "paragraph",
      runner: (e, t) => {
        var n;
        if (e.openNode("paragraph"), t.childCount >= 1 && ((n = t.lastChild) == null ? void 0 : n.type.name) === "hardbreak") {
          const o = [];
          t.content.forEach((l, s, c) => {
            c !== t.childCount - 1 && o.push(l);
          }), e.next(W.fromArray(o));
        } else
          e.next(t.content);
        e.closeNode();
      }
    }
  }),
  commands: (e) => [N(me, () => A(e))],
  shortcuts: {
    [y.Text]: M(me, "Mod-Alt-0")
  }
})), wt = C(() => ({
  id: "text",
  schema: () => ({
    group: "inline",
    parseMarkdown: {
      match: ({ type: a }) => a === "text",
      runner: (a, e) => {
        a.addText(e.value);
      }
    },
    toMarkdown: {
      match: (a) => a.type.name === "text",
      runner: (a, e) => {
        a.addNode("text", void 0, e.text);
      }
    }
  })
})), Lt = [
  lt(),
  bt(),
  it(),
  tt(),
  at(),
  rt(),
  It(),
  Nt(),
  pt(),
  gt(),
  kt(),
  wt()
], Ct = () => {
  function a(e) {
    Ge(e, "list", (t) => {
      var r;
      if (t.ordered) {
        const n = (r = t.start) != null ? r : 1;
        t.children.forEach((o, l) => {
          o.label = l + n;
        });
      }
    });
  }
  return a;
}, xt = (a) => !!a.children, Tt = (a) => a.type === "html";
function Ht(a, e) {
  return t(a, 0, null)[0];
  function t(r, n, o) {
    if (xt(r)) {
      const l = [];
      for (let s = 0, c = r.children.length; s < c; s++) {
        const i = r.children[s];
        if (i) {
          const u = t(i, s, r);
          if (u)
            for (let f = 0, d = u.length; f < d; f++) {
              const m = u[f];
              m && l.push(m);
            }
        }
      }
      r.children = l;
    }
    return e(r, n, o);
  }
}
const Dt = () => {
  function a(e) {
    Ht(e, (t) => Tt(t) ? [] : [t]);
  }
  return a;
}, Ot = new H("MILKDOWN_INLINE_NODES_CURSOR"), St = () => {
  let a = !1;
  const e = new T({
    key: Ot,
    state: {
      init() {
        return !1;
      },
      apply(t) {
        if (!t.selection.empty)
          return !1;
        const r = t.selection.$from, n = r.nodeBefore, o = r.nodeAfter;
        return !!(n && o && n.isInline && !n.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (t, r) => a ? (a = !1, requestAnimationFrame(() => {
          if (e.getState(t.state)) {
            const o = t.state.selection.from;
            r.preventDefault(), t.dispatch(t.state.tr.insertText(r.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (t) => (e.getState(t.state) && (a = !0), !1),
        beforeinput: (t, r) => {
          if (e.getState(t.state) && r instanceof InputEvent && r.data && !a) {
            const o = t.state.selection.from;
            return r.preventDefault(), t.dispatch(t.state.tr.insertText(r.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(t) {
        if (e.getState(t)) {
          const o = t.selection.$from.pos, l = document.createElement("span"), s = Z.widget(o, l, {
            side: -1
          }), c = document.createElement("span"), i = Z.widget(o, c);
          return setTimeout(() => {
            l.contentEditable = "true", c.contentEditable = "true";
          }), S.create(t.doc, [s, i]);
        }
        return S.empty;
      }
    }
  });
  return e;
}, Y = /\[(?<span>((www|https:\/\/|http:\/\/)[^\s\]]+))]\((?<url>[^\s\]]+)\)/, vt = (a) => new RegExp(`\\\\(?=[^\\w\\s${a}\\\\]|_)`, "g"), At = (a) => {
  let e = a, t = e.match(Y);
  for (; t && t.groups; ) {
    const { span: r } = t.groups;
    e = e.replace(Y, r), t = e.match(Y);
  }
  return e;
}, Et = (a, e, t) => {
  const r = a.split(""), n = r[e];
  return r[e] && r[t] && (r[e] = r[t], r[t] = n), r.join("").toString();
}, _t = (a) => (e) => e.replace(vt(a), ""), $t = (a) => (e) => {
  const t = e.indexOf(a.hole), r = e.charAt(t - 1), n = e.charAt(t + 1), o = /[^\w]|_/;
  return n ? r && o.test(r) && o.test(n) ? a.punctuation : a.char : a.punctuation;
}, Pt = (a, e, t) => {
  let r = e, n = !1;
  return a.descendants((o) => {
    var l;
    if (n)
      return !1;
    if (o.isText) {
      const s = (l = o.text) == null ? void 0 : l.indexOf(t);
      if (s != null && s >= 0)
        return n = !0, r += s, !1;
    }
    r += o.nodeSize;
  }), r;
}, Bt = {
  placeholderConfig: {
    hole: "\u2205",
    punctuation: "\u2042",
    char: "\u2234"
  },
  globalNodes: ["footnote_definition"],
  shouldSyncNode: ({ prevNode: a, nextNode: e }) => a.inlineContent && e && a.type === e.type && !a.eq(e),
  movePlaceholder: (a, e) => {
    const t = ["*", "_"];
    let r = e.indexOf(a);
    for (; t.includes(e[r - 1] || "") && t.includes(e[r + 1] || ""); )
      e = Et(e, r, r + 1), r = r + 1;
    return e;
  }
}, E = Ee(Bt, "inlineSyncConfig"), Rt = (a) => {
  const { selection: e } = a, { $from: t } = e;
  return t.node();
}, Wt = (a, e, t, r) => {
  const n = a.get(_e), o = e.schema.topNodeType.create(void 0, [t, ...r]);
  return n(o);
}, qt = (a, e) => {
  const t = a.get(E), r = t.placeholderConfig.hole, [n = "", ...o] = e.split(`

`), l = (u) => t.movePlaceholder(r, u);
  let c = Se(_t(r), l, At)(n);
  const i = $t(t.placeholderConfig)(c);
  return c = c.replace(r, i), c = [c, ...o].join(`

`), [c, i];
}, Kt = (a, e) => {
  const r = a.get($e)(e);
  return r ? r.firstChild : null;
}, Ft = (a, e) => {
  const { globalNodes: t } = a.get(E), r = [];
  return e.doc.descendants((n) => {
    if (t.includes(n.type.name) || t.includes(n.type))
      return r.push(n), !1;
  }), r;
}, jt = (a) => a.split(`

`)[0] || "", Oe = (a, e) => {
  try {
    const t = Ft(a, e), r = Rt(e), n = Wt(a, e, r, t), [o, l] = qt(a, n), s = Kt(a, o);
    return !s || r.type !== s.type ? null : (s.attrs = { ...r.attrs }, s.descendants((c) => {
      var f;
      const u = c.marks.find((d) => d.type.name === "link");
      u && ((f = c.text) == null ? void 0 : f.includes(l)) && u.attrs.href.includes(l) && (u.attrs.href = u.attrs.href.replace(l, ""));
    }), {
      text: jt(o),
      prevNode: r,
      nextNode: s,
      placeholder: l
    });
  } catch {
    return null;
  }
}, zt = (a, e, t, r, n) => {
  const { placeholderConfig: o } = a.get(E), l = o.hole;
  let s = t.tr.setMeta(e, !0).insertText(l, t.selection.from);
  const c = t.apply(s), i = Oe(a, c);
  if (!i)
    return;
  const { $from: u } = c.selection, f = u.before(), d = u.after(), m = Pt(i.nextNode, f, i.placeholder);
  s = s.replaceWith(f, d, i.nextNode).setNodeMarkup(f, void 0, n).delete(m + 1, m + 2), s = s.setSelection(Q.near(s.doc.resolve(m + 1))), r(s);
}, J = new H("MILKDOWN_INLINE_SYNC"), Ut = (a) => {
  let e = null;
  return new T({
    key: J,
    state: {
      init: () => null,
      apply: (r, n, o, l) => {
        var p;
        const s = a.get(v);
        if (!((p = s.hasFocus) != null && p.call(s)) || !s.editable || !r.docChanged || r.getMeta(J))
          return null;
        const i = Oe(a, l);
        if (!i)
          return null;
        e && (cancelAnimationFrame(e), e = null);
        const { prevNode: u, nextNode: f, text: d } = i, { shouldSyncNode: m } = a.get(E);
        return m({ prevNode: u, nextNode: f, ctx: a, tr: r, text: d }) && (e = requestAnimationFrame(() => {
          e = null;
          const { dispatch: g, state: h } = a.get(v);
          zt(a, J, h, g, u.attrs);
        })), null;
      }
    }
  });
}, Vt = [
  ve(() => ({
    injectSlices: [E],
    prosePlugins: (a, e) => [St(), Ut(e)],
    remarkPlugins: () => [Ve, Dt, Ct]
  }))()
], Gt = we.create([...Lt, ...et]), cr = we.create([...Vt, ...Gt]), ir = {
  ToggleInlineCode: ee,
  ToggleItalic: te,
  ToggleLink: Te,
  ToggleBold: ne,
  ModifyLink: re,
  ModifyImage: ce,
  WrapInBlockquote: se,
  WrapInBulletList: oe,
  WrapInOrderedList: fe,
  TurnIntoCodeFence: ae,
  TurnIntoHeading: O,
  TurnIntoText: me,
  InsertHardbreak: le,
  InsertHr: He,
  InsertImage: De,
  SplitListItem: ie,
  SinkListItem: ue,
  LiftListItem: de
};
export {
  ye as DowngradeHeading,
  ct as HardbreakFilterPluginKey,
  le as InsertHardbreak,
  He as InsertHr,
  De as InsertImage,
  de as LiftListItem,
  ce as ModifyImage,
  re as ModifyLink,
  ue as SinkListItem,
  ie as SplitListItem,
  y as SupportedKeys,
  ne as ToggleBold,
  ee as ToggleInlineCode,
  te as ToggleItalic,
  Te as ToggleLink,
  ae as TurnIntoCodeFence,
  O as TurnIntoHeading,
  me as TurnIntoText,
  se as WrapInBlockquote,
  oe as WrapInBulletList,
  fe as WrapInOrderedList,
  st as backtickInputRegex,
  tt as blockquote,
  rt as bulletList,
  at as codeFence,
  Ye as codeInline,
  ir as commands,
  cr as commonmark,
  Gt as commonmarkNodes,
  Vt as commonmarkPlugins,
  lt as doc,
  Je as em,
  it as hardbreak,
  pt as heading,
  ut as headingHashPluginKey,
  V as headingIdPluginKey,
  gt as hr,
  kt as image,
  E as inlineSyncConfigCtx,
  Xe as link,
  Nt as listItem,
  et as marks,
  Lt as nodes,
  It as orderedList,
  bt as paragraph,
  Ze as strong,
  wt as text,
  ot as tildeInputRegex
};
//# sourceMappingURL=index.es.js.map
