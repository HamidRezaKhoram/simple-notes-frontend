import { ThemeIcon as D, getPalette as M, ThemeSize as L, ThemeFont as B, ThemeBorder as z, ThemeShadow as W, ThemeScrollbar as j } from "@milkdown/core";
import { missingRootElement as A } from "@milkdown/exception";
import { baseKeymap as O, chainCommands as H, deleteSelection as N } from "@milkdown/prose/commands";
import { history as U, undo as K, redo as F } from "@milkdown/prose/history";
import { keymap as _ } from "@milkdown/prose/keymap";
import { EditorState as V, TextSelection as I } from "@milkdown/prose/state";
import { StepMap as Y } from "@milkdown/prose/transform";
import { EditorView as q } from "@milkdown/prose/view";
import { calculateTextPosition as G } from "@milkdown/prose";
const he = ({ injectGlobal: e }) => e`
    /* copy from https://github.com/ProseMirror/@milkdown/prose/blob/master/style/prosemirror.css */
    .ProseMirror {
        position: relative;
    }

    .ProseMirror {
        word-wrap: break-word;
        white-space: pre-wrap;
        white-space: break-spaces;
        -webkit-font-variant-ligatures: none;
        font-variant-ligatures: none;
        font-feature-settings: 'liga' 0; /* the above doesn't seem to work in Edge */
    }

    .ProseMirror pre {
        white-space: pre-wrap;
    }

    .ProseMirror li {
        position: relative;
    }

    .ProseMirror-hideselection *::selection {
        background: transparent;
    }
    .ProseMirror-hideselection *::-moz-selection {
        background: transparent;
    }
    .ProseMirror-hideselection {
        caret-color: transparent;
    }

    .ProseMirror-selectednode {
        outline: 2px solid #8cf;
    }

    /* Make sure li selections wrap around markers */

    li.ProseMirror-selectednode {
        outline: none;
    }

    li.ProseMirror-selectednode:after {
        content: '';
        position: absolute;
        left: -32px;
        right: -2px;
        top: -2px;
        bottom: -2px;
        border: 2px solid #8cf;
        pointer-events: none;
    }

    /* Protect against generic img rules */

    img.ProseMirror-separator {
        display: inline !important;
        border: none !important;
        margin: 0 !important;
    }
`, J = (e, { css: h }) => {
  const s = M(e), n = e.get(L, "radius"), y = e.get(L, "lineWidth");
  return h`
        background-color: ${s("background")};
        color: ${s("neutral")};
        font-size: 14px;
        padding: 18px 6px 22px;
        border-radius: ${n};
        font-family: ${e.get(B, "typography")};

        .code-fence_selector-wrapper {
            position: relative;
        }

        .code-fence_selector {
            width: 180px;
            box-sizing: border-box;
            border-radius: ${n};
            margin: 0 18px 18px;
            cursor: pointer;
            background-color: ${s("surface")};
            position: relative;
            display: flex;
            color: ${s("neutral", 0.87)};
            letter-spacing: 0.5px;
            height: 42px;
            align-items: center;

            ${e.get(z, void 0)};
            ${e.get(W, void 0)};

            & > .icon {
                width: 42px;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                color: ${s("solid", 0.87)};
                border-left: ${y} solid ${s("line")};

                text-align: center;
                transition: all 0.2s ease-in-out;
                &:hover {
                    background: ${s("background")};
                    color: ${s("primary")};
                }
            }

            > span:first-child {
                padding-left: 16px;
                flex: 1;
                font-weight: 500;
            }
        }

        .code-fence_selector-list-item {
            list-style: none;
            line-height: 2;
            padding-left: 16px;
            cursor: pointer;
            margin: 0 !important;
            :hover {
                background: ${s("secondary", 0.12)};
                color: ${s("primary")};
            }
        }

        .code-fence_selector-list {
            &[data-fold='true'] {
                display: none;
            }

            margin: 0 !important;
            font-weight: 500;
            position: absolute;
            z-index: 1;
            top: 42px;
            box-sizing: border-box;
            left: 18px;
            padding: 8px 0;
            max-height: 260px;
            width: 180px;
            background-color: ${s("surface")};
            border-top: none;
            overflow-y: auto;
            display: flex;
            flex-direction: column;

            ${e.get(j, ["y"])}
            ${e.get(z, void 0)};
            ${e.get(W, void 0)};
        }
    `;
}, Q = (e, h) => {
  e.set(
    "code-fence",
    ({ view: s, editable: n, onSelectLanguage: y, onBlur: x, onFocus: d, languageList: p }) => {
      const t = document.createElement("div"), c = document.createElement("div"), i = document.createElement("ul"), a = document.createElement("pre"), r = document.createElement("code"), o = document.createElement("div");
      o.className = "code-fence_selector";
      const m = document.createElement("span");
      o.appendChild(m);
      const u = e.get(D, "downArrow");
      n() && u && o.appendChild(u.dom), r.spellcheck = !1, c.className = "code-fence_selector-wrapper", c.contentEditable = "false", c.append(o), c.append(i), a.append(r);
      const f = document.createElement("div");
      r.append(f), f.style.whiteSpace = "inherit", t.append(c, a), t.classList.add("code-fence"), e.onFlush(() => {
        const g = J(e, h);
        g && t.classList.add(g);
      }), i.className = "code-fence_selector-list", i.addEventListener("mousedown", (g) => {
        if (g.preventDefault(), g.stopPropagation(), !n())
          return;
        const l = g.target;
        if (!(l instanceof HTMLLIElement))
          return;
        const v = l.dataset.value;
        v != null && y(v);
      }), o.addEventListener("mousedown", (g) => {
        g.preventDefault(), g.stopPropagation(), n() && d();
      });
      const b = () => {
        !n() || i.dataset.fold === "true" || x();
      };
      return document.addEventListener("mousedown", b), p.forEach((g) => {
        const l = document.createElement("li");
        l.className = "code-fence_selector-list-item", l.innerText = g || "--", i.appendChild(l), l.setAttribute("data-value", g);
      }), {
        dom: t,
        contentDOM: f,
        onUpdate: (g) => {
          t.dataset.language = g.attrs.language, m.innerText = g.attrs.language || "--", i.style.maxHeight = "", i.setAttribute("data-fold", g.attrs.fold ? "true" : "false");
          const l = s.dom.parentElement;
          if (!l)
            throw A();
          const v = l.getBoundingClientRect(), P = c.getBoundingClientRect(), S = i.getBoundingClientRect();
          let $, E;
          const C = P.top - v.top, T = v.height + v.top - (P.height + P.top);
          T >= S.height + 14 ? $ = "bottom" : C >= S.height + 14 ? $ = "top" : T >= C ? ($ = "bottom", E = T - 14) : ($ = "top", E = C - 14);
          const R = $ === "top" ? -(E != null ? E : S.height) : P.height;
          i.style.maxHeight = E !== void 0 && E > 0 ? `${E}px` : "", i.style.top = `${R}px`;
        },
        onDestroy: () => {
          t.remove(), document.removeEventListener("mousedown", b);
        }
      };
    }
  );
}, X = (e, { css: h }) => {
  const s = M(e);
  e.set("image", ({ placeholder: n, isBlock: y, onError: x, onLoad: d }) => {
    const p = (u) => {
      var f;
      return (f = e.get(D, u)) == null ? void 0 : f.dom;
    }, t = document.createElement("span");
    t.classList.add("image-container"), e.onFlush(() => {
      const u = h`
                display: inline-block;
                position: relative;
                text-align: center;
                font-size: 0;
                vertical-align: text-bottom;
                line-height: 1;

                ${y ? `
                width: 100%;
                margin: 0 auto;
                ` : ""}

                &.ProseMirror-selectednode::after {
                    content: '';
                    background: ${s("secondary", 0.38)};
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                }

                img {
                    max-width: 100%;
                    height: auto;
                    object-fit: contain;
                    margin: 0 2px;
                }
                .icon,
                .placeholder {
                    display: none;
                }

                &.system {
                    width: 100%;
                    padding: 0 32px;
                    font-size: inherit;

                    img {
                        width: 0;
                        height: 0;
                        display: none;
                    }

                    .icon,
                    .placeholder {
                        display: inline;
                    }

                    box-sizing: border-box;
                    height: 48px;
                    background-color: ${s("background")};
                    border-radius: ${e.get(L, "radius")};
                    display: inline-flex;
                    gap: 32px;
                    justify-content: flex-start;
                    align-items: center;
                    .placeholder {
                        margin: 0;
                        line-height: 1;
                        &::before {
                            content: '';
                            font-size: 14px;
                            color: ${s("neutral", 0.6)};
                        }
                    }
                }

                &.empty {
                    .placeholder {
                        &::before {
                            content: '${n}';
                        }
                    }
                }
            `;
      u && t.classList.add(u);
    });
    const c = document.createElement("img");
    t.append(c);
    let i = p("image");
    const a = document.createElement("span");
    a.classList.add("placeholder"), t.append(i, a);
    const r = (u) => {
      const f = p(u);
      t.replaceChild(f, i), i = f;
    }, o = (u) => {
      t.classList.add("system", "loading"), r("loading");
      const f = document.createElement("img");
      f.src = u, f.onerror = () => {
        x == null || x(f);
      }, f.onload = () => {
        d == null || d(f);
      };
    };
    return {
      dom: t,
      onUpdate: (u) => {
        const { src: f, alt: b, title: w, loading: k, failed: g } = u.attrs;
        if (c.src = f, c.title = w || b, c.alt = b, f.length === 0) {
          t.classList.add("system", "empty"), r("image");
          return;
        }
        if (k) {
          o(f);
          return;
        }
        if (g) {
          t.classList.remove("loading", "empty"), t.classList.add("system", "failed"), r("brokenImage");
          return;
        }
        if (f.length > 0) {
          t.classList.remove("system", "empty", "loading");
          return;
        }
        t.classList.add("system", "empty"), r("image");
      }
    };
  });
}, Z = (e, { css: h }) => {
  const s = M(e), n = e.get(L, "radius"), y = e.get(B, "code"), x = h`
        color: ${s("neutral", 0.87)};
        background-color: ${s("background")};
        border-radius: ${n};
        padding: 16px 32px;
        font-size: 14px;
        font-family: ${y};
        overflow: hidden;
        line-height: 1.5;
        .ProseMirror {
            outline: none;
        }
    `, d = h`
        display: none;
    `, p = h`
        display: flex;
        justify-content: center;
        padding: 16px 0;
    `;
  return {
    codeStyle: x,
    hideCodeStyle: d,
    previewPanelStyle: p
  };
}, ee = (e, h) => {
  let s = !1, n;
  return {
    isEditing: () => s,
    innerView: () => n,
    openEditor: (d, p) => {
      n = new q(d, {
        state: V.create({
          doc: p,
          plugins: [
            U(),
            _({
              ...O,
              Backspace: H(N, (c) => {
                var u;
                if (!c.selection.empty || n && n.state.doc.textContent.length > 0)
                  return !1;
                const { dispatch: i, state: a } = e, r = (u = a.schema.nodes.paragraph) == null ? void 0 : u.create();
                if (!r)
                  return !1;
                const o = a.tr.replaceSelectionWith(r);
                let m = o.selection.from - 2;
                return m < 0 && (m = 0), i(o.setSelection(I.create(o.doc, m))), e.focus(), !0;
              }),
              "Mod-Enter": (c, i) => {
                var a;
                if (i) {
                  const { state: r } = e, { to: o } = r.selection, m = (a = r.schema.nodes.paragraph) == null ? void 0 : a.createAndFill();
                  if (!m)
                    return !1;
                  const u = r.tr.replaceWith(o, o, m);
                  e.dispatch(u.setSelection(I.create(u.doc, o))), e.focus();
                }
                return !0;
              }
            }),
            _({
              "Mod-z": K,
              "Mod-y": F,
              "Shift-Mod-z": F
            })
          ]
        }),
        plugins: [],
        dispatchTransaction: (c) => {
          if (!n)
            return;
          const { state: i, transactions: a } = n.state.applyTransaction(c);
          if (n.updateState(i), !c.getMeta("fromOutside")) {
            const r = e.state.tr, o = Y.offset(h() + 1);
            a.forEach((m) => {
              const { steps: u } = m;
              u.forEach((f) => {
                const b = f.map(o);
                if (!b)
                  throw new Error("step discarded!");
                r.step(b);
              });
            }), r.docChanged && e.dispatch(r);
          }
        }
      }), n.focus();
      const { state: t } = n;
      n.dispatch(t.tr.setSelection(I.create(t.doc, 0))), s = !0;
    },
    closeEditor: () => {
      n && n.destroy(), n = void 0, s = !1;
    }
  };
}, te = (e, h) => {
  e.set("inner-editor", ({ view: s, getPos: n, render: y }) => {
    const x = ee(s, n), d = document.createElement("div");
    d.classList.add("math-block");
    const p = document.createElement("div"), t = document.createElement("div");
    let c = "", i = "", a = "";
    return e.onFlush(() => {
      ({ codeStyle: c, hideCodeStyle: i, previewPanelStyle: a } = Z(e, h)), c && i && p.classList.add(c, i), a && t.classList.add(a);
    }), d.append(p), {
      dom: d,
      preview: t,
      editor: p,
      onUpdate: (r, o) => {
        var f;
        if (o) {
          const b = r.attrs.value || r.textContent || "";
          p.dataset.value = b, y(b);
          return;
        }
        const m = x.innerView();
        if (m) {
          const b = m.state, w = r.content.findDiffStart(b.doc.content);
          if (w != null) {
            const k = r.content.findDiffEnd(b.doc.content);
            if (k) {
              let { a: g, b: l } = k;
              const v = w - Math.min(g, l);
              v > 0 && (g += v, l += v), m.dispatch(
                b.tr.replace(w, l, r.slice(w, g)).setMeta("fromOutside", !0)
              );
            }
          }
        }
        const u = ((f = r.content.firstChild) == null ? void 0 : f.text) || "";
        p.dataset.value = u, y(u);
      },
      onFocus: (r) => {
        !s.editable || (i && p.classList.remove(i), x.openEditor(p, r), d.classList.add("ProseMirror-selectednode"));
      },
      onBlur: () => {
        i && p.classList.add(i), x.closeEditor(), d.classList.remove("ProseMirror-selectednode");
      },
      onDestroy: () => {
        t.remove(), p.remove(), d.remove();
      },
      stopEvent: (r) => {
        const o = x.innerView(), { target: m } = r, u = m && (o == null ? void 0 : o.dom.contains(m));
        return !!(o && u);
      }
    };
  });
}, oe = (e, { css: h }, s) => {
  const n = M(e);
  return h`
        ${e.get(z, void 0)}
        ${e.get(W, void 0)}

        display: inline-flex;
        justify-content: space-between;
        align-items: center;
        position: absolute;
        background: ${n("surface")};
        border-radius: ${e.get(L, "radius")};
        font-size: 16px;

        height: 56px;
        box-sizing: border-box;
        width: ${s.width};
        padding: 0 16px;
        gap: 16px;
        z-index: 2;

        input,
        button {
            all: unset;
        }

        input {
            flex-grow: 1;
            caret-color: ${n("primary")};
            &::placeholder {
                color: ${n("neutral", 0.6)};
            }
        }

        button {
            cursor: pointer;
            height: 36px;
            color: ${n("primary")};
            font-size: 14px;
            padding: 0 8px;
            font-weight: 500;
            letter-spacing: 1.25px;
            &:hover {
                background-color: ${n("secondary", 0.12)};
            }
            &.disable {
                color: ${n("neutral", 0.38)};
                cursor: not-allowed;
                &:hover {
                    background: transparent;
                }
            }
            &.hide {
                display: none;
            }
        }

        &.hide {
            display: none;
        }
    `;
}, ne = (e, h) => {
  G(e, h, (s, n, y, x) => {
    const d = e.dom.parentElement;
    if (!d)
      throw A();
    const p = n.left - s.left;
    let t = s.left - x.left - (y.width - p) / 2;
    const c = s.bottom - x.top + 14 + d.scrollTop;
    t < 0 && (t = 0);
    const i = d.clientWidth - (y.width + 4);
    return t > i && (t = i), [c, t];
  });
}, ie = (e, h) => {
  e.set(
    "input-chip",
    ({ isBindMode: s, onUpdate: n, buttonText: y, placeholder: x, width: d = "400px", calculatePosition: p = ne }) => {
      let t = null, c = !1, i = "";
      const a = document.createElement("div");
      e.onFlush(() => {
        const l = oe(e, h, { width: d });
        l && a.classList.add(l);
      }), a.classList.add("tooltip-input");
      const r = document.createElement("input");
      x && (r.placeholder = x), a.appendChild(r), s || (t = document.createElement("button"), t.innerText = y || "APPLY", a.appendChild(t));
      const o = () => {
        a.classList.add("hide");
      }, m = (l) => {
        a.classList.remove("hide"), p(l, a);
      }, u = (l) => {
        const { target: v } = l;
        if (v instanceof HTMLInputElement) {
          if (i = v.value, !t) {
            n(i);
            return;
          }
          if (!i) {
            t.classList.add("disable"), c = !0;
            return;
          }
          t.classList.remove("disable"), c = !1;
        }
      }, f = (l) => {
        c || (l.stopPropagation(), n(i), o());
      }, b = (l) => {
        "key" in l && l.key === "Enter" && (n(i), o());
      };
      return {
        dom: a,
        init: (l) => {
          const v = l.dom.parentElement;
          if (!v)
            throw A();
          r.addEventListener("input", u), r.addEventListener("keydown", b), t == null || t.addEventListener("mousedown", f), v.appendChild(a), o();
        },
        show: m,
        hide: o,
        destroy: () => {
          r.removeEventListener("input", u), r.removeEventListener("keydown", b), t == null || t.removeEventListener("mousedown", f), a.remove();
        },
        update: (l) => {
          i = l, r.value = l;
        }
      };
    }
  );
}, se = (e, { css: h }) => {
  const s = M(e);
  e.set("task-list-item", ({ onChange: n, editable: y }) => {
    const x = (o) => {
      var m;
      return (m = e.get(D, o)) == null ? void 0 : m.dom;
    }, d = document.createElement("li"), p = document.createElement("label"), t = document.createElement("span"), c = document.createElement("input"), i = document.createElement("div");
    let a = x("unchecked");
    p.appendChild(a);
    const r = (o) => {
      const m = x(o);
      p.replaceChild(m, a), a = m;
    };
    return p.append(c, t), d.append(p, i), p.contentEditable = "false", c.type = "checkbox", y() || (c.disabled = !0, p.style.cursor = "not-allowed"), c.onchange = (o) => {
      if (o.target instanceof HTMLInputElement) {
        if (!y()) {
          c.checked = !c.checked;
          return;
        }
        o.preventDefault(), n(c.checked);
      }
    }, d.dataset.type = "task-item", d.classList.add("task-list-item"), e.onFlush(() => {
      const o = h`
                list-style-type: none;
                position: relative;

                & > div {
                    overflow: hidden;
                    padding: 0 2px;
                    width: 100%;
                }

                label {
                    display: inline-block;
                    width: 24px;
                    height: 24px;
                    cursor: pointer;
                    input {
                        visibility: hidden;
                    }
                }
                &[data-checked='true'] {
                    > label {
                        color: ${s("primary")};
                    }
                }
                &[data-checked='false'] {
                    > label {
                        color: ${s("solid", 0.87)};
                    }
                }
                .paragraph {
                    margin: 8px 0;
                }
            `;
      o && d.classList.add(o);
    }), {
      dom: d,
      contentDOM: i,
      onUpdate: (o) => {
        d.dataset.checked = o.attrs.checked, o.attrs.checked ? c.setAttribute("checked", "checked") : c.removeAttribute("checked"), r(o.attrs.checked ? "checked" : "unchecked");
      }
    };
  });
}, ge = (e, h) => {
  [ie, X, Q, se, te].forEach((s) => {
    s(e, h);
  });
};
export {
  Q as codeFence,
  X as image,
  he as injectProsemirrorView,
  te as innerEditor,
  ie as inputChip,
  se as taskListItem,
  ge as useAllPresetRenderer
};
//# sourceMappingURL=index.es.js.map
