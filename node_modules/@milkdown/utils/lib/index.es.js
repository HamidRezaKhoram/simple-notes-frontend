import { createTimer as jt, SchemaReady as g, commandsCtx as S, commandsTimerCtx as St, inputRulesCtx as K, editorStateTimerCtx as X, ThemeReady as M, marksCtx as $, schemaCtx as R, schemaTimerCtx as Y, nodesCtx as b, prosePluginsCtx as j, InitReady as Z, remarkPluginsCtx as q, nodeViewCtx as B, markViewCtx as G, editorViewTimerCtx as Tt, themeManagerCtx as _, emotionCtx as Rt, createSlice as k, createContainer as Et, createClock as Ot, Env as At, editorCtx as $t, editorViewCtx as E, serializerCtx as bt, parserCtx as yt, editorStateOptionsCtx as Mt } from "@milkdown/core";
import { customAlphabet as It } from "nanoid";
import { missingMarkInSchema as ft, missingNodeInSchema as Pt, themeMustInstalled as gt } from "@milkdown/exception";
import { keymap as x } from "@milkdown/prose/keymap";
import { NodeType as kt, DOMSerializer as Vt, Slice as vt } from "@milkdown/prose/model";
import { EditorState as zt } from "@milkdown/prose/state";
const ht = (s) => Object.prototype.hasOwnProperty.call(s, "origin");
class Ct extends Array {
  findThenRun(n, t) {
    const e = this.findIndex((a) => ht(a) && a.origin === n);
    return e < 0 ? this : (t(e), this);
  }
  configure(n, t) {
    return this.findThenRun(n, (e) => {
      this.splice(e, 1, n(t));
    });
  }
  replace(n, t) {
    return this.findThenRun(n, (e) => {
      this.splice(e, 1, t);
    });
  }
  remove(n) {
    return this.findThenRun(n, (t) => {
      this.splice(t, 1);
    });
  }
  headless() {
    return this.filter(ht).forEach((n) => {
      this.configure(n.origin, { headless: !0 });
    }), this;
  }
  static create(n) {
    return new Ct(...n);
  }
}
const Lt = It("abcedfghicklmn", 10), T = (s, n, t) => {
  const e = jt(t || Lt());
  let a = !1;
  const c = () => async (r) => {
    const o = () => {
      r.done(e), a = !0;
    };
    r.update(n, (u) => u.concat(e)), await s(r, c, o), a || r.done(e);
  };
  return c.timer = e, c;
}, Wt = (s) => {
  const n = () => async (t) => {
    await t.wait(g);
    const [e, a] = s(t);
    t.get(S).create(e, a), n.run = (c) => t.get(S).call(e, c), n.key = e;
  };
  return n;
}, Xt = (s, n) => T(
  async (t, e) => {
    await t.wait(g);
    const [a, c] = await s(t);
    t.get(S).create(a, c), e.run = (r) => t.get(S).call(a, r), e.key = a;
  },
  St,
  n
), Yt = (s) => {
  const n = () => async (t) => {
    await t.wait(g);
    const e = s(t);
    t.update(K, (a) => [...a, e]), n.inputRule = e;
  };
  return n;
}, Zt = (s, n) => T(
  async (t, e) => {
    await t.wait(g);
    const a = await s(t);
    t.update(K, (c) => [...c, a]), e.inputRule = a;
  },
  X,
  n
), _t = (s, n) => {
  const t = () => async (e) => {
    await e.wait(M);
    const a = n(e);
    e.update($, (r) => [...r, [s, a]]), t.id = s, t.schema = a, await e.wait(g);
    const c = e.get(R).marks[s];
    if (!c)
      throw ft(s);
    t.type = c;
  };
  return t;
}, xt = (s, n, t) => T(
  async (e, a, c) => {
    await e.wait(M);
    const r = await n(e);
    e.update($, (u) => [...u, [s, r]]), a.id = s, a.schema = r, c(), await e.wait(g);
    const o = e.get(R).marks[s];
    if (!o)
      throw ft(s);
    a.type = o;
  },
  Y,
  t
), te = (s, n) => {
  const t = () => async (e) => {
    await e.wait(M);
    const a = n(e);
    e.update(b, (r) => [...r, [s, a]]), t.id = s, t.schema = a, await e.wait(g);
    const c = e.get(R).nodes[s];
    if (!c)
      throw Pt(s);
    t.type = c;
  };
  return t;
}, ee = (s, n, t) => T(
  async (e, a, c) => {
    await e.wait(M);
    const r = await n(e);
    e.update(b, (u) => [...u, [s, r]]), a.id = s, a.schema = r, c(), await e.wait(g);
    const o = e.get(R).nodes[s];
    if (!o)
      throw Pt(s);
    a.type = o;
  },
  Y,
  t
), ne = (s) => {
  const n = () => async (t) => {
    await t.wait(g);
    const e = s(t);
    t.update(j, (a) => [...a, e]), n.plugin = e;
  };
  return n;
}, se = (s, n) => T(
  async (t, e) => {
    await t.wait(g);
    const a = await s(t);
    t.update(j, (c) => [...c, a]), e.plugin = a;
  },
  X,
  n
), ae = (s) => {
  const n = () => async (t) => {
    await t.wait(Z);
    const e = s(t);
    t.update(q, (a) => [...a, e]), n.plugin = e;
  };
  return n;
}, ce = (s, n) => T(
  async (t, e) => {
    await t.wait(Z);
    const a = await s(t);
    t.update(q, (c) => [...c, a]), e.plugin = a;
  },
  Y,
  n
), re = (s) => {
  const n = () => async (t) => {
    await t.wait(g);
    const e = s(t);
    t.update(j, (a) => [...a, x(e)]), n.keymap = e;
  };
  return n;
}, ie = (s, n) => T(
  async (t, e) => {
    await t.wait(g);
    const a = await s(t);
    t.update(j, (c) => [...c, x(a)]), e.keymap = a;
  },
  X,
  n
), oe = (s, n) => {
  const t = () => async (e) => {
    await e.wait(g);
    const a = n(e);
    s.type instanceof kt ? e.update(B, (c) => [...c, [s.id, a]]) : e.update(G, (c) => [...c, [s.id, a]]), t.view = a, t.type = s;
  };
  return t;
}, ue = (s, n, t) => T(
  async (e, a) => {
    await e.wait(g);
    const c = await n(e);
    s.type instanceof kt ? e.update(B, (r) => [...r, [s.id, c]]) : e.update(G, (r) => [...r, [s.id, c]]), a.view = c, a.type = s;
  },
  Tt,
  t
), Nt = (s) => (n, ...t) => {
  var a;
  const e = (a = s == null ? void 0 : s(n, ...t)) != null ? a : t;
  return Array.isArray(e) ? e.filter((c) => c).join(" ") : e;
}, le = (s, n, t) => [s, n, t];
function J(s, n) {
  try {
    const t = s.get(_), e = s.get(Rt);
    if (!e.css)
      throw gt();
    return {
      getClassName: Nt(n == null ? void 0 : n.className),
      getStyle: (a) => n != null && n.headless ? "" : a(e),
      themeManager: t
    };
  } catch {
    throw gt();
  }
}
const de = J, tt = (s) => {
  const n = (t) => {
    const e = s(t);
    return e.origin = n, e;
  };
  return n;
}, et = (s, n) => (t) => {
  const e = t, a = (c) => n((...r) => c(s(...r), ...r));
  return e.extend = a, e;
}, nt = (...s) => {
  const n = s.length;
  let t = n;
  for (; t--; )
    if (typeof s[t] != "function")
      throw new TypeError("Expected a function");
  return (...e) => {
    let a = 0, c = n ? s[a](...e) : e[0];
    for (; ++a < n; )
      c = s[a](c);
    return c;
  };
}, O = k({}, "optionsPipeCtx"), I = k([], "injectPipeCtx"), st = async (s, n) => {
  const { pipelineCtx: t, onCleanup: e, pre: a } = s, c = t.get(I);
  c && (c.forEach((r) => a.inject(r)), e((r) => {
    c.forEach((o) => r.remove(o));
  })), await n();
}, at = async (s, n) => {
  const { ctx: t } = s;
  await t.wait(M), await n();
}, V = k(
  void 0,
  "getRemarkPluginsPipeCtx"
), ct = async (s, n) => {
  const { ctx: t, pipelineCtx: e, onCleanup: a } = s;
  await t.wait(Z);
  const c = e.get(V);
  if (c) {
    const r = c(t);
    t.update(q, (o) => o.concat(r)), a(() => {
      t.update(q, (o) => o.filter((u) => !r.includes(u)));
    });
  }
  await n();
}, z = k(void 0, "getSchemaPipeCtx"), L = k({}, "Type"), rt = async (s, n) => {
  var h;
  const { ctx: t, pipelineCtx: e, onCleanup: a } = s, c = e.get(z), r = (h = c == null ? void 0 : c(s.ctx)) != null ? h : {};
  let o = {}, u = {};
  if (r.node) {
    o = r.node;
    const p = Object.entries(r.node);
    t.update(b, (w) => [...w, ...p]), a(() => {
      t.update(b, (w) => w.filter((y) => !p.includes(y)));
    });
  }
  if (r.mark) {
    u = r.mark;
    const p = Object.entries(r.mark);
    t.update($, (w) => [...w, ...p]), a(() => {
      t.update($, (w) => w.filter((y) => !p.includes(y)));
    });
  }
  await t.wait(g);
  const l = t.get(R), i = Object.keys(o).map((p) => [p, l.nodes[p]]), d = Object.keys(u).map((p) => [p, l.marks[p]]), f = Object.fromEntries([...i, ...d]);
  e.set(L, f), await n();
}, N = k(
  void 0,
  "getCommandsPipeCtx"
), it = async (s, n) => {
  const { ctx: t, pipelineCtx: e, onCleanup: a } = s, c = e.get(N);
  if (c) {
    const r = e.get(L), o = c(r, t);
    o.forEach(([u, l]) => {
      t.get(S).create(u, l);
    }), a(() => {
      o.forEach(([u]) => {
        t.get(S).remove(u);
      });
    });
  }
  await n();
}, U = k(
  void 0,
  "getInputRulesPipeCtx"
), ot = async (s, n) => {
  const { ctx: t, pipelineCtx: e, onCleanup: a } = s, c = e.get(U);
  if (c) {
    const r = e.get(L), o = c(r, t);
    t.update(K, (u) => [...u, ...o]), a(() => {
      t.update(K, (u) => u.filter((l) => !o.includes(l)));
    });
  }
  await n();
}, D = k({}, "shortcutsPipeCtx"), ut = async (s, n) => {
  const { pipelineCtx: t, ctx: e, onCleanup: a } = s, c = t.get(D), r = t.get(O), o = (i, d) => {
    var f, h;
    return (h = (f = r == null ? void 0 : r.keymap) == null ? void 0 : f[i]) != null ? h : d;
  }, u = Object.entries(c).flatMap(([i, [d, f, h]]) => {
    const p = () => e.get(S).call(d, h), w = o(i, f);
    return Array.isArray(w) ? w.map((y) => ({ key: y, runner: p })) : { key: w, runner: p };
  }).map((i) => [i.key, i.runner]), l = x(Object.fromEntries(u));
  e.update(j, (i) => i.concat(l)), a(() => {
    e.update(j, (i) => i.filter((d) => d !== l));
  }), await n();
}, H = k(
  void 0,
  "getProsePluginsPipeCtx"
), lt = async (s, n) => {
  const { pipelineCtx: t, ctx: e, onCleanup: a } = s, c = t.get(H);
  if (c) {
    const r = t.get(L), o = c(r, e);
    e.update(j, (u) => [...u, ...o]), a(() => {
      e.update(j, (u) => u.filter((l) => !o.includes(l)));
    });
  }
  await n();
}, F = k(void 0, "getViewPipeCtx"), dt = async (s, n) => {
  const { pipelineCtx: t, ctx: e, onCleanup: a } = s, c = t.get(F), r = t.get(O), o = r.view ? r.view(e) : c == null ? void 0 : c(e);
  if (o) {
    const u = Object.entries(o).filter(
      ([i]) => e.get(b).findIndex((d) => d[0] === i) !== -1
    ), l = Object.entries(o).filter(
      ([i]) => e.get($).findIndex((d) => d[0] === i) !== -1
    );
    e.update(B, (i) => [...i, ...u]), e.update(G, (i) => [...i, ...l]), a(() => {
      e.update(B, (i) => i.filter((d) => !u.includes(d))), e.update(G, (i) => i.filter((d) => !l.includes(d)));
    });
  }
  await n();
}, pt = k("", "idPipeCtx"), mt = async (s, n) => {
  const { pipelineCtx: t } = s;
  t.inject(pt).inject(O).inject(I).inject(V).inject(z).inject(L).inject(N).inject(U).inject(D).inject(H).inject(F), await n();
}, Ut = (s) => (n, t) => {
  let e = -1;
  const a = (c) => {
    if (c <= e)
      return Promise.reject(new Error("next() called multiple times"));
    e = c;
    let r = s[c];
    if (c === s.length && (r = t), !r)
      return Promise.resolve();
    try {
      return Promise.resolve(r(n, () => a(c + 1)));
    } catch (o) {
      return Promise.reject(o);
    }
  };
  return a(0);
}, wt = (s) => {
  const n = Ut(s), t = Et(), e = Ot(), a = /* @__PURE__ */ new Set(), c = new At(t, e), r = (l) => {
    a.add(l);
  }, o = async (l) => {
    await Promise.all(
      [...a].map((i) => i(l))
    );
  }, u = (l, i) => n({
    pre: l,
    ctx: i,
    pipelineCtx: c,
    onCleanup: r
  });
  return u.runCleanup = o, u;
}, Dt = (s) => nt(
  tt,
  et(s, Dt)
)(
  (n) => (t) => async (e) => {
    const c = wt([
      mt,
      at,
      async ({ pipelineCtx: r }, o) => {
        const u = J(e, n), l = s(u, n), {
          id: i,
          commands: d,
          remarkPlugins: f,
          schema: h,
          inputRules: p,
          shortcuts: w,
          prosePlugins: y,
          view: v,
          injectSlices: C
        } = l, A = n == null ? void 0 : n.view, Q = C != null ? C : [], W = {
          ...n || {},
          view: A ? (m) => ({ [i]: A(m) }) : void 0
        };
        r.set(I, Q), r.set(pt, i), r.set(O, W), r.set(V, f), r.set(z, (m) => ({ mark: { [i]: h(m) } })), d && r.set(N, (m, P) => d(m[i], P)), p && r.set(U, (m, P) => p(m[i], P)), w && r.set(D, w), y && r.set(H, (m, P) => y(m[i], P)), v && r.set(F, (m) => ({ [i]: v(m) })), await o();
      },
      st,
      ct,
      rt,
      it,
      ot,
      ut,
      lt,
      dt
    ]);
    return await c(t, e), c.runCleanup;
  }
), Ht = (s) => nt(
  tt,
  et(s, Ht)
)(
  (n) => (t) => async (e) => {
    const c = wt([
      mt,
      at,
      async ({ pipelineCtx: r }, o) => {
        const u = J(e, n), l = s(u, n), {
          id: i,
          commands: d,
          remarkPlugins: f,
          schema: h,
          inputRules: p,
          shortcuts: w,
          prosePlugins: y,
          view: v,
          injectSlices: C
        } = l, A = n == null ? void 0 : n.view, Q = C != null ? C : [], W = {
          ...n || {},
          view: A ? (m) => ({ [i]: A(m) }) : void 0
        };
        r.set(I, Q), r.set(pt, i), r.set(O, W), r.set(V, f), r.set(z, (m) => ({ node: { [i]: h(m) } })), d && r.set(N, (m, P) => d(m[i], P)), p && r.set(U, (m, P) => p(m[i], P)), w && r.set(D, w), y && r.set(H, (m, P) => y(m[i], P)), v && r.set(F, (m) => ({ [i]: v(m) })), await o();
      },
      st,
      ct,
      rt,
      it,
      ot,
      ut,
      lt,
      dt
    ]);
    return await c(t, e), c.runCleanup;
  }
), Ft = (s) => nt(
  tt,
  et(s, Ft)
)(
  (n) => (t) => async (e) => {
    const c = wt([
      mt,
      at,
      async ({ pipelineCtx: r }, o) => {
        const u = J(e, n), l = s(u, n), { commands: i, remarkPlugins: d, schema: f, inputRules: h, shortcuts: p, prosePlugins: w, view: y, injectSlices: v } = l, C = v != null ? v : [];
        r.set(I, C), r.set(O, n || {}), r.set(V, d), f && r.set(z, f), i && r.set(N, i), h && r.set(U, h), p && r.set(D, p), w && r.set(H, w), y && r.set(F, y), await o();
      },
      st,
      ct,
      rt,
      it,
      ot,
      ut,
      lt,
      dt
    ]);
    return await c(t, e), c.runCleanup;
  }
);
function pe(s, n) {
  return (t) => t.get(S).call(s, n);
}
const me = () => (s) => s.get($t).destroy(), we = () => (s) => {
  const n = s.get(E), { tr: t } = n.state, e = Object.assign(Object.create(t), t).setTime(Date.now());
  return n.dispatch(e);
}, ge = () => (s) => {
  const n = document.createElement("div"), t = s.get(R), e = s.get(E), a = Vt.fromSchema(t).serializeFragment(e.state.doc.content);
  return n.appendChild(a), n.innerHTML;
}, he = () => (s) => {
  const n = s.get(E);
  return s.get(bt)(n.state.doc);
}, ye = (s) => (n) => {
  const t = n.get(E), a = n.get(yt)(s);
  if (!a)
    return;
  const c = t.state.selection.content();
  return t.dispatch(
    t.state.tr.replaceSelection(new vt(a.content, c.openStart, c.openEnd)).scrollIntoView()
  );
}, fe = () => (s) => {
  const n = s.get(E), t = [];
  return n.state.doc.descendants((a) => {
    a.type.name === "heading" && a.attrs.level && t.push({ text: a.textContent, level: a.attrs.level, id: a.attrs.id });
  }), t;
}, Pe = (s, n = !1) => (t) => {
  const e = t.get(E), c = t.get(yt)(s);
  if (!c)
    return;
  if (!n) {
    const { state: d } = e;
    return e.dispatch(d.tr.replace(0, d.doc.content.size, new vt(c.content, 0, 0)));
  }
  const r = t.get(R), o = t.get(Mt), u = t.get(j), l = t.get(_), i = zt.create({
    schema: r,
    doc: c,
    plugins: u,
    ...o
  });
  e.updateState(i), l.flush(t);
}, ke = (s, n) => (t) => {
  const e = t.get(E), { tr: a } = e.state, c = a.doc.nodeAt(s);
  if (!c)
    return;
  const r = n(c.attrs);
  return e.dispatch(a.setNodeMarkup(s, void 0, r));
}, ve = (s) => (n) => n.get(_).switch(n, s);
export {
  Wt as $command,
  Xt as $commandAsync,
  Yt as $inputRule,
  Zt as $inputRuleAsync,
  _t as $mark,
  xt as $markAsync,
  te as $node,
  ee as $nodeAsync,
  ne as $prose,
  se as $proseAsync,
  ae as $remark,
  ce as $remarkAsync,
  re as $shortcut,
  ie as $shortcutAsync,
  oe as $view,
  ue as $viewAsync,
  Ct as AtomList,
  tt as addMetadata,
  pe as callCommand,
  Dt as createMark,
  Ht as createNode,
  Ft as createPlugin,
  le as createShortcut,
  me as destroy,
  we as forceUpdate,
  Nt as getClassName,
  ge as getHTML,
  he as getMarkdown,
  J as getThemeUtils,
  de as getUtils,
  ye as insert,
  fe as outline,
  nt as pipe,
  Pe as replaceAll,
  ke as setAttr,
  ve as switchTheme,
  et as withExtend
};
//# sourceMappingURL=index.es.js.map
