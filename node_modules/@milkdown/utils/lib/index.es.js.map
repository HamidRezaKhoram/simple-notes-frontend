{"version":3,"file":"index.es.js","sources":["../src/atom/atom-list.ts","../src/composable/utils.ts","../src/composable/$command.ts","../src/composable/$inputRule.ts","../src/composable/$mark.ts","../src/composable/$node.ts","../src/composable/$prose.ts","../src/composable/$remark.ts","../src/composable/$shortcut.ts","../src/composable/$view.ts","../src/factory/common.ts","../src/pipe.ts","../src/factory/pieces.ts","../src/factory/pipeline.ts","../src/factory/create-mark.ts","../src/factory/create-node.ts","../src/factory/create-plugin.ts","../src/macro/call-command.ts","../src/macro/destroy.ts","../src/macro/force-update.ts","../src/macro/get-html.ts","../src/macro/get-markdown.ts","../src/macro/insert.ts","../src/macro/outline.ts","../src/macro/replace-all.ts","../src/macro/set-attr.ts","../src/macro/switch-theme.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { MilkdownPlugin } from '@milkdown/core'\n\nimport type { AddMetadata, Metadata } from '../types'\n\nexport type MilkdownPluginWithMetadata = MilkdownPlugin & Metadata\nexport type AtomPlugin = MilkdownPlugin | MilkdownPluginWithMetadata\n\nconst hasMetadata = (x: AtomPlugin): x is MilkdownPluginWithMetadata =>\n  Object.prototype.hasOwnProperty.call(x, 'origin')\n\nexport class AtomList<T extends AtomPlugin = AtomPlugin> extends Array<T> {\n  private findThenRun<U extends AddMetadata>(target: U, callback: (index: number) => void): this {\n    const index = this.findIndex(x => hasMetadata(x) && x.origin === target)\n    if (index < 0)\n      return this\n\n    callback(index)\n\n    return this\n  }\n\n  configure<U extends AddMetadata>(target: U, config: Parameters<U>[0]): this {\n    return this.findThenRun(target, (index) => {\n      this.splice(index, 1, target(config) as T)\n    })\n  }\n\n  replace<U extends AddMetadata, Next extends AtomPlugin>(target: U, next: Next): this {\n    return this.findThenRun(target, (index) => {\n      this.splice(index, 1, next as AtomPlugin as T)\n    })\n  }\n\n  remove<U extends AddMetadata>(target: U): this {\n    return this.findThenRun(target, (index) => {\n      this.splice(index, 1)\n    })\n  }\n\n  headless(): this {\n    this.filter(hasMetadata).forEach((x) => {\n      this.configure((x as MilkdownPluginWithMetadata).origin as AddMetadata, { headless: true })\n    })\n    return this\n  }\n\n  static create<T extends AtomPlugin = AtomPlugin>(from: T[]): AtomList<T> {\n    return new AtomList(...from)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, MilkdownPlugin, Slice, Timer } from '@milkdown/core'\nimport { createTimer } from '@milkdown/core'\nimport { customAlphabet } from 'nanoid'\n\nexport const nanoid = customAlphabet('abcedfghicklmn', 10)\n\nexport const addTimer = <T extends MilkdownPlugin, PluginWithTimer extends T = T & { timer: Timer }>(\n  runner: (ctx: Ctx, plugin: PluginWithTimer, done: () => void) => Promise<void>,\n  injectTo: Slice<Timer[], string>,\n  timerName?: string,\n): PluginWithTimer => {\n  const timer = createTimer(timerName || nanoid())\n  let doneCalled = false\n\n  const plugin: MilkdownPlugin = () => {\n    return async (ctx) => {\n      const done = () => {\n        ctx.done(timer)\n        doneCalled = true\n      }\n      ctx.update(injectTo, x => x.concat(timer))\n\n      await runner(ctx, <PluginWithTimer>plugin, done)\n\n      if (!doneCalled)\n        ctx.done(timer)\n    }\n  };\n  (<T & { timer: Timer }>plugin).timer = timer\n\n  return <PluginWithTimer>plugin\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { CmdKey, CmdTuple, Ctx, MilkdownPlugin } from '@milkdown/core'\nimport { SchemaReady, commandsCtx, commandsTimerCtx } from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\nexport type $Command<T> = MilkdownPlugin & {\n  run: (payload?: T) => boolean\n  key: CmdKey<T>\n}\n\nexport const $command = <T>(cmd: (ctx: Ctx) => CmdTuple<T>): $Command<T> => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(SchemaReady)\n    const [key, command] = cmd(ctx)\n    ctx.get(commandsCtx).create(key, command);\n    (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload);\n    (<$Command<T>>plugin).key = key\n  }\n\n  return <$Command<T>>plugin\n}\n\nexport const $commandAsync = <T>(cmd: (ctx: Ctx) => Promise<CmdTuple<T>>, timerName?: string) => {\n  return addTimer<$Command<T>>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const [key, command] = await cmd(ctx)\n      ctx.get(commandsCtx).create(key, command);\n      (<$Command<T>>plugin).run = (payload?: T) => ctx.get(commandsCtx).call(key, payload);\n      (<$Command<T>>plugin).key = key\n    },\n    commandsTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/core'\nimport { SchemaReady, editorStateTimerCtx, inputRulesCtx } from '@milkdown/core'\nimport type { InputRule } from '@milkdown/prose/inputrules'\n\nimport { addTimer } from './utils'\n\nexport type $InputRule = MilkdownPlugin & {\n  inputRule: InputRule\n}\n\nexport const $inputRule = (inputRule: (ctx: Ctx) => InputRule): $InputRule => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(SchemaReady)\n    const ir = inputRule(ctx)\n    ctx.update(inputRulesCtx, irs => [...irs, ir]);\n    (<$InputRule>plugin).inputRule = ir\n  }\n\n  return <$InputRule>plugin\n}\n\nexport const $inputRuleAsync = (inputRule: (ctx: Ctx) => Promise<InputRule>, timerName?: string) => {\n  return addTimer<$InputRule>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const ir = await inputRule(ctx)\n      ctx.update(inputRulesCtx, irs => [...irs, ir])\n      plugin.inputRule = ir\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type {\n  Ctx,\n  MarkSchema,\n  MilkdownPlugin,\n} from '@milkdown/core'\nimport {\n  SchemaReady,\n  ThemeReady,\n  marksCtx,\n  schemaCtx,\n  schemaTimerCtx,\n} from '@milkdown/core'\nimport { missingMarkInSchema } from '@milkdown/exception'\nimport type { MarkType } from '@milkdown/prose/model'\n\nimport { addTimer } from './utils'\n\nexport type $Mark = MilkdownPlugin & {\n  id: string\n  type: MarkType\n  schema: MarkSchema\n}\n\nexport const $mark = (id: string, schema: (ctx: Ctx) => MarkSchema): $Mark => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(ThemeReady)\n    const markSchema = schema(ctx)\n    ctx.update(marksCtx, ns => [...ns, [id, markSchema] as [string, MarkSchema]]);\n\n    (<$Mark>plugin).id = id;\n    (<$Mark>plugin).schema = markSchema\n\n    await ctx.wait(SchemaReady)\n\n    const markType = ctx.get(schemaCtx).marks[id]\n\n    if (!markType)\n      throw missingMarkInSchema(id);\n\n    (<$Mark>plugin).type = markType\n  }\n\n  return <$Mark>plugin\n}\n\nexport const $markAsync = (id: string, schema: (ctx: Ctx) => Promise<MarkSchema>, timerName?: string) => {\n  return addTimer<$Mark>(\n    async (ctx, plugin, done) => {\n      await ctx.wait(ThemeReady)\n      const markSchema = await schema(ctx)\n      ctx.update(marksCtx, ns => [...ns, [id, markSchema] as [string, MarkSchema]])\n\n      plugin.id = id\n      plugin.schema = markSchema\n      done()\n\n      await ctx.wait(SchemaReady)\n\n      const markType = ctx.get(schemaCtx).marks[id]\n      if (!markType)\n        throw missingMarkInSchema(id)\n\n      plugin.type = markType\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type {\n  Ctx,\n  MilkdownPlugin,\n  NodeSchema,\n} from '@milkdown/core'\nimport {\n  SchemaReady,\n  ThemeReady,\n  nodesCtx,\n  schemaCtx,\n  schemaTimerCtx,\n} from '@milkdown/core'\nimport { missingNodeInSchema } from '@milkdown/exception'\nimport type { NodeType } from '@milkdown/prose/model'\n\nimport { addTimer } from './utils'\n\nexport type $Node = MilkdownPlugin & {\n  id: string\n  type: NodeType\n  schema: NodeSchema\n}\n\nexport const $node = (id: string, schema: (ctx: Ctx) => NodeSchema): $Node => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(ThemeReady)\n    const nodeSchema = schema(ctx)\n    ctx.update(nodesCtx, ns => [...ns, [id, nodeSchema] as [string, NodeSchema]]);\n\n    (<$Node>plugin).id = id;\n    (<$Node>plugin).schema = nodeSchema\n\n    await ctx.wait(SchemaReady)\n\n    const nodeType = ctx.get(schemaCtx).nodes[id]\n\n    if (!nodeType)\n      throw missingNodeInSchema(id);\n\n    (<$Node>plugin).type = nodeType\n  }\n\n  return <$Node>plugin\n}\n\nexport const $nodeAsync = (id: string, schema: (ctx: Ctx) => Promise<NodeSchema>, timerName?: string) => {\n  return addTimer<$Node>(\n    async (ctx, plugin, done) => {\n      await ctx.wait(ThemeReady)\n      const nodeSchema = await schema(ctx)\n      ctx.update(nodesCtx, ns => [...ns, [id, nodeSchema] as [string, NodeSchema]])\n\n      plugin.id = id\n      plugin.schema = nodeSchema\n      done()\n\n      await ctx.wait(SchemaReady)\n\n      const nodeType = ctx.get(schemaCtx).nodes[id]\n\n      if (!nodeType)\n        throw missingNodeInSchema(id)\n\n      plugin.type = nodeType\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/core'\nimport { SchemaReady, editorStateTimerCtx, prosePluginsCtx } from '@milkdown/core'\nimport type { Plugin } from '@milkdown/prose/state'\n\nimport { addTimer } from './utils'\n\nexport type $Prose = MilkdownPlugin & {\n  plugin: Plugin\n}\n\nexport const $prose = (prose: (ctx: Ctx) => Plugin): $Prose => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(SchemaReady)\n    const prosePlugin = prose(ctx)\n    ctx.update(prosePluginsCtx, ps => [...ps, prosePlugin]);\n    (<$Prose>plugin).plugin = prosePlugin\n  }\n\n  return <$Prose>plugin\n}\n\nexport const $proseAsync = (prose: (ctx: Ctx) => Promise<Plugin>, timerName?: string) => {\n  return addTimer<$Prose>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const prosePlugin = await prose(ctx)\n      ctx.update(prosePluginsCtx, ps => [...ps, prosePlugin])\n      plugin.plugin = prosePlugin\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin, RemarkPlugin } from '@milkdown/core'\nimport { InitReady, remarkPluginsCtx, schemaTimerCtx } from '@milkdown/core'\n\nimport { addTimer } from './utils'\n\nexport type $Remark = MilkdownPlugin & {\n  plugin: RemarkPlugin\n}\n\nexport const $remark = (remark: (ctx: Ctx) => RemarkPlugin): $Remark => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(InitReady)\n    const re = remark(ctx)\n    ctx.update(remarkPluginsCtx, rp => [...rp, re]);\n    (<$Remark>plugin).plugin = re\n  }\n\n  return <$Remark>plugin\n}\n\nexport const $remarkAsync = (remark: (ctx: Ctx) => Promise<RemarkPlugin>, timerName?: string) =>\n  addTimer<$Remark>(\n    async (ctx, plugin) => {\n      await ctx.wait(InitReady)\n      const re = await remark(ctx)\n      ctx.update(remarkPluginsCtx, rp => [...rp, re])\n      plugin.plugin = re\n    },\n    schemaTimerCtx,\n    timerName,\n  )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/core'\nimport { SchemaReady, editorStateTimerCtx, prosePluginsCtx } from '@milkdown/core'\nimport { keymap } from '@milkdown/prose/keymap'\nimport type { Command } from '@milkdown/prose/state'\n\nimport { addTimer } from './utils'\n\ntype Keymap = Record<string, Command>\n\nexport type $Shortcut = MilkdownPlugin & {\n  keymap: Keymap\n}\n\nexport const $shortcut = (shortcut: (ctx: Ctx) => Keymap): $Shortcut => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(SchemaReady)\n    const k = shortcut(ctx)\n    ctx.update(prosePluginsCtx, ps => [...ps, keymap(k)]);\n    (<$Shortcut>plugin).keymap = k\n  }\n\n  return <$Shortcut>plugin\n}\n\nexport const $shortcutAsync = (shortcut: (ctx: Ctx) => Promise<Keymap>, timerName?: string) =>\n  addTimer<$Shortcut>(\n    async (ctx, plugin) => {\n      await ctx.wait(SchemaReady)\n      const k = await shortcut(ctx)\n      ctx.update(prosePluginsCtx, ps => [...ps, keymap(k)])\n      plugin.keymap = k\n    },\n    editorStateTimerCtx,\n    timerName,\n  )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin } from '@milkdown/core'\nimport { SchemaReady, editorViewTimerCtx, markViewCtx, nodeViewCtx } from '@milkdown/core'\nimport { NodeType } from '@milkdown/prose/model'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\n\nimport { addTimer } from './utils'\nimport type { $Mark, $Node } from '.'\n\nexport type $View<T extends $Node | $Mark, V extends NodeViewConstructor | MarkViewConstructor> = MilkdownPlugin & {\n  view: V\n  type: T\n}\n\nexport const $view = <\n    T extends $Node | $Mark,\n    V extends NodeViewConstructor | MarkViewConstructor = T extends $Node\n      ? NodeViewConstructor\n      : T extends $Mark\n        ? MarkViewConstructor\n        : NodeViewConstructor | MarkViewConstructor,\n>(\n    type: T,\n    view: (ctx: Ctx) => V,\n  ): $View<T, V> => {\n  const plugin: MilkdownPlugin = () => async (ctx) => {\n    await ctx.wait(SchemaReady)\n    const v = view(ctx)\n    if (type.type instanceof NodeType)\n      ctx.update(nodeViewCtx, ps => [...ps, [type.id, v] as [string, NodeViewConstructor]])\n    else\n      ctx.update(markViewCtx, ps => [...ps, [type.id, v] as [string, MarkViewConstructor]]);\n\n    (<$View<T, V>>plugin).view = v;\n    (<$View<T, V>>plugin).type = type\n  }\n\n  return <$View<T, V>>plugin\n}\n\nexport const $viewAsync = <\n    T extends $Node | $Mark,\n    V extends NodeViewConstructor | MarkViewConstructor = T extends $Node\n      ? NodeViewConstructor\n      : T extends $Mark\n        ? MarkViewConstructor\n        : NodeViewConstructor | MarkViewConstructor,\n>(\n    type: T,\n    view: (ctx: Ctx) => Promise<V>,\n    timerName?: string,\n  ) =>\n    addTimer<$View<T, V>>(\n      async (ctx, plugin) => {\n        await ctx.wait(SchemaReady)\n        const v = await view(ctx)\n        if (type.type instanceof NodeType)\n          ctx.update(nodeViewCtx, ps => [...ps, [type.id, v] as [string, NodeViewConstructor]])\n        else\n          ctx.update(markViewCtx, ps => [...ps, [type.id, v] as [string, MarkViewConstructor]])\n\n        plugin.view = v\n        plugin.type = type\n      },\n      editorViewTimerCtx,\n      timerName,\n    )\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Attrs, CmdKey, Ctx } from '@milkdown/core'\nimport { emotionCtx, themeManagerCtx } from '@milkdown/core'\nimport { themeMustInstalled } from '@milkdown/exception'\n\nimport type {\n  AddMetadata,\n  CommandConfig,\n  CommonOptions,\n  Factory,\n  GetPlugin,\n  ThemeUtils,\n  WithExtend,\n} from '../types'\n\nexport const getClassName\n    = (className: CommonOptions['className']) =>\n      (attrs: Attrs, ...defaultValue: (string | null | undefined)[]): string => {\n        const classList = className?.(attrs, ...defaultValue) ?? defaultValue\n        return Array.isArray(classList) ? classList.filter(x => x).join(' ') : classList\n      }\n\nexport const createShortcut = <T>(commandKey: CmdKey<T>, defaultKey: string | string[], args?: T) =>\n  [commandKey, defaultKey, args] as CommandConfig<unknown>\n\nexport function getThemeUtils<Options extends CommonOptions>(ctx: Ctx, options?: Options): ThemeUtils {\n  try {\n    const themeManager = ctx.get(themeManagerCtx)\n    const emotion = ctx.get(emotionCtx)\n    if (!emotion.css)\n      throw themeMustInstalled()\n\n    return {\n      getClassName: getClassName(options?.className as undefined),\n      getStyle: style => (options?.headless ? '' : (style(emotion) as string | undefined)),\n      themeManager,\n    }\n  }\n  catch {\n    throw themeMustInstalled()\n  }\n}\n\n/**\n * @deprecated Use `getThemeUtils` instead.\n */\nexport const getUtils = getThemeUtils\n\nexport const addMetadata = <SupportedKeys extends string = string, Options extends {} = {}>(\n  x: GetPlugin<SupportedKeys, Options>,\n): AddMetadata<SupportedKeys, Options> => {\n  const fn: AddMetadata<SupportedKeys, Options> = (options) => {\n    const result = x(options) as ReturnType<AddMetadata<SupportedKeys, Options>>\n    result.origin = fn\n    return result\n  }\n  return fn\n}\n\nexport const withExtend\n    = <SupportedKeys extends string, Options extends {}, Type, Rest>(\n      factory: Factory<SupportedKeys, Options, Type, Rest>,\n      creator: (\n        factory: Factory<SupportedKeys, Options, Type, Rest>,\n      ) => WithExtend<SupportedKeys, Options, Type, Rest>,\n    ) =>\n        (origin: AddMetadata<SupportedKeys, Options>): WithExtend<SupportedKeys, Options, Type, Rest> => {\n        type Ext = WithExtend<SupportedKeys, Options, Type, Rest>\n        const next = origin as Ext\n        const extend = (extendFactory: Parameters<Ext['extend']>[0]) =>\n          creator((...args) => extendFactory(factory(...args), ...args))\n\n        next.extend = extend as Ext['extend']\n\n        return next\n        }\n","/* Copyright 2021, Milkdown by Mirone. */\n\nexport type Many<T> = T | ReadonlyArray<T>\n\ninterface Pipe {\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n    f7: (a: R6) => R7,\n  ): (...args: A) => R7\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6, R7>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n    f7: (a: R6) => R7,\n    ...func: Array<Many<(a: any) => any>>\n  ): (...args: A) => any\n  pipe<A extends any[], R1, R2, R3, R4, R5, R6>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n    f6: (a: R5) => R6,\n  ): (...args: A) => R6\n  pipe<A extends any[], R1, R2, R3, R4, R5>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n    f5: (a: R4) => R5,\n  ): (...args: A) => R5\n  pipe<A extends any[], R1, R2, R3, R4>(\n    f1: (...args: A) => R1,\n    f2: (a: R1) => R2,\n    f3: (a: R2) => R3,\n    f4: (a: R3) => R4,\n  ): (...args: A) => R4\n  pipe<A extends any[], R1, R2, R3>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3): (...args: A) => R3\n  pipe<A extends any[], R1, R2>(f1: (...args: A) => R1, f2: (a: R1) => R2): (...args: A) => R2\n  pipe(...func: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any\n}\n\nexport const pipe: Pipe['pipe'] = (...funcs: any[]) => {\n  const length = funcs.length\n  let index = length\n  while (index--) {\n    if (typeof funcs[index] !== 'function')\n      throw new TypeError('Expected a function')\n  }\n  return (...args: any[]) => {\n    let index = 0\n    let result = length ? funcs[index](...args) : args[0]\n    while (++index < length)\n      result = funcs[index](result)\n\n    return result\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type {\n  CmdTuple,\n  Ctx,\n  MarkSchema,\n  NodeSchema,\n  RemarkPlugin,\n} from '@milkdown/core'\nimport {\n  InitReady,\n  SchemaReady,\n  ThemeReady,\n  commandsCtx,\n  createSlice,\n  inputRulesCtx,\n  markViewCtx,\n  marksCtx,\n  nodeViewCtx,\n  nodesCtx,\n  prosePluginsCtx,\n  remarkPluginsCtx,\n  schemaCtx,\n} from '@milkdown/core'\nimport type { InputRule } from '@milkdown/prose/inputrules'\nimport { keymap } from '@milkdown/prose/keymap'\nimport type { MarkType, NodeType } from '@milkdown/prose/model'\nimport type { Plugin } from '@milkdown/prose/state'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\n\nimport type { AnySlice, CommandConfig, CommonOptions } from '../types'\nimport type { Pipeline } from './pipeline'\n\nexport type PluginOptions = Omit<CommonOptions<string, unknown>, 'view'> & { view?: (ctx: Ctx) => PluginView }\nexport const optionsPipeCtx = createSlice<PluginOptions>({}, 'optionsPipeCtx')\n\nexport type UserSchema = (ctx: Ctx) => {\n  node?: Record<string, NodeSchema>\n  mark?: Record<string, MarkSchema>\n}\n\nexport type PluginType = Record<string, NodeType | MarkType>\n\nexport type PluginView = Record<string, NodeViewConstructor | MarkViewConstructor>\n\ntype Maybe<T> = T | undefined\n\nexport const injectSlicesPipeCtx = createSlice<AnySlice[]>([], 'injectPipeCtx')\nexport const injectSlices: Pipeline = async (env, next) => {\n  const { pipelineCtx, onCleanup, pre } = env\n  const inject = pipelineCtx.get(injectSlicesPipeCtx)\n  if (inject) {\n    inject.forEach(slice => pre.inject(slice))\n    onCleanup((post) => {\n      inject.forEach(slice => post.remove(slice))\n    })\n  }\n  await next()\n}\n\nexport const waitThemeReady: Pipeline = async (env, next) => {\n  const { ctx } = env\n  await ctx.wait(ThemeReady)\n\n  await next()\n}\n\nexport const getRemarkPluginsPipeCtx = createSlice<Maybe<(ctx: Ctx) => RemarkPlugin[]>>(\n  undefined,\n'getRemarkPluginsPipeCtx',\n)\nexport const applyRemarkPlugins: Pipeline = async (env, next) => {\n  const { ctx, pipelineCtx, onCleanup } = env\n\n  await ctx.wait(InitReady)\n\n  const remarkPlugins = pipelineCtx.get(getRemarkPluginsPipeCtx)\n\n  if (remarkPlugins) {\n    const plugins = remarkPlugins(ctx)\n\n    ctx.update(remarkPluginsCtx, ps => ps.concat(plugins))\n\n    onCleanup(() => {\n      ctx.update(remarkPluginsCtx, ps => ps.filter(p => !plugins.includes(p)))\n    })\n  }\n\n  await next()\n}\n\nexport const getSchemaPipeCtx = createSlice<Maybe<UserSchema>>(undefined, 'getSchemaPipeCtx')\nexport const typePipeCtx = createSlice<PluginType, 'Type'>({} as PluginType, 'Type')\nexport const applySchema: Pipeline = async (env, next) => {\n  const { ctx, pipelineCtx, onCleanup } = env\n\n  const getSchema = pipelineCtx.get(getSchemaPipeCtx)\n\n  const userSchema = getSchema?.(env.ctx) ?? {}\n\n  let node: Record<string, NodeSchema> = {}\n  let mark: Record<string, MarkSchema> = {}\n\n  if (userSchema.node) {\n    node = userSchema.node\n    const nodes = Object.entries<NodeSchema>(userSchema.node)\n    ctx.update(nodesCtx, ns => [...ns, ...nodes])\n    onCleanup(() => {\n      ctx.update(nodesCtx, ns => ns.filter(n => !nodes.includes(n)))\n    })\n  }\n\n  if (userSchema.mark) {\n    mark = userSchema.mark\n    const marks = Object.entries<MarkSchema>(userSchema.mark)\n    ctx.update(marksCtx, ms => [...ms, ...marks])\n    onCleanup(() => {\n      ctx.update(marksCtx, ms => ms.filter(m => !marks.includes(m)))\n    })\n  }\n\n  await ctx.wait(SchemaReady)\n\n  const schema = ctx.get(schemaCtx)\n  const nodeTypes = Object.keys(node).map(id => [id, schema.nodes[id]] as const)\n  const markTypes = Object.keys(mark).map(id => [id, schema.marks[id]] as const)\n\n  const type = Object.fromEntries([...nodeTypes, ...markTypes])\n  pipelineCtx.set(typePipeCtx, type)\n\n  await next()\n}\n\nexport const getCommandsPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => CmdTuple[]>>(\n  undefined,\n'getCommandsPipeCtx',\n)\nexport const createCommands: Pipeline = async (env, next) => {\n  const { ctx, pipelineCtx, onCleanup } = env\n  const commands = pipelineCtx.get(getCommandsPipeCtx)\n  if (commands) {\n    const type = pipelineCtx.get(typePipeCtx)\n    const cs = commands(type, ctx)\n    cs.forEach(([key, command]) => {\n      ctx.get(commandsCtx).create(key, command)\n    })\n    onCleanup(() => {\n      cs.forEach(([key]) => {\n        ctx.get(commandsCtx).remove(key)\n      })\n    })\n  }\n  await next()\n}\n\nexport const getInputRulesPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => InputRule[]>>(\n  undefined,\n'getInputRulesPipeCtx',\n)\nexport const createInputRules: Pipeline = async (env, next) => {\n  const { ctx, pipelineCtx, onCleanup } = env\n  const inputRules = pipelineCtx.get(getInputRulesPipeCtx)\n  if (inputRules) {\n    const type = pipelineCtx.get(typePipeCtx)\n    const rules = inputRules(type, ctx)\n    ctx.update(inputRulesCtx, ir => [...ir, ...rules])\n\n    onCleanup(() => {\n      ctx.update(inputRulesCtx, ir => ir.filter(r => !rules.includes(r)))\n    })\n  }\n\n  await next()\n}\n\nexport const shortcutsPipeCtx = createSlice<Record<string, CommandConfig>>({}, 'shortcutsPipeCtx')\nexport const createShortcuts: Pipeline = async (env, next) => {\n  const { pipelineCtx, ctx, onCleanup } = env\n\n  const shortcuts = pipelineCtx.get(shortcutsPipeCtx)\n\n  const options = pipelineCtx.get(optionsPipeCtx)\n  const getKey = (key: string, defaultValue: string | string[]): string | string[] => {\n    return options?.keymap?.[key] ?? defaultValue\n  }\n\n  const tuples = Object.entries<CommandConfig>(shortcuts)\n    .flatMap(([id, [commandKey, defaultKey, args]]) => {\n      const runner = () => ctx.get(commandsCtx).call(commandKey, args)\n      const key = getKey(id, defaultKey)\n      if (Array.isArray(key))\n        return key.map(k => ({ key: k, runner }))\n\n      return { key, runner }\n    })\n    .map(x => [x.key, x.runner] as [string, () => boolean])\n\n  const plugin = keymap(Object.fromEntries(tuples))\n  ctx.update(prosePluginsCtx, ps => ps.concat(plugin))\n  onCleanup(() => {\n    ctx.update(prosePluginsCtx, ps => ps.filter(p => p !== plugin))\n  })\n\n  await next()\n}\n\nexport const getProsePluginsPipeCtx = createSlice<Maybe<(types: PluginType, ctx: Ctx) => Plugin[]>>(\n  undefined,\n'getProsePluginsPipeCtx',\n)\nexport const applyProsePlugins: Pipeline = async (env, next) => {\n  const { pipelineCtx, ctx, onCleanup } = env\n\n  const prosePlugins = pipelineCtx.get(getProsePluginsPipeCtx)\n  if (prosePlugins) {\n    const type = pipelineCtx.get(typePipeCtx)\n    const plugins = prosePlugins(type, ctx)\n    ctx.update(prosePluginsCtx, ps => [...ps, ...plugins])\n    onCleanup(() => {\n      ctx.update(prosePluginsCtx, ps => ps.filter(p => !plugins.includes(p)))\n    })\n  }\n\n  await next()\n}\n\nexport const getViewPipeCtx = createSlice<Maybe<(ctx: Ctx) => PluginView>>(undefined, 'getViewPipeCtx')\nexport const applyView: Pipeline = async (env, next) => {\n  const { pipelineCtx, ctx, onCleanup } = env\n\n  const getView = pipelineCtx.get(getViewPipeCtx)\n\n  const options = pipelineCtx.get(optionsPipeCtx)\n\n  const view = options.view ? options.view(ctx) : getView?.(ctx)\n\n  if (view) {\n    const nodeViews = Object.entries(view).filter(\n      ([id]) => ctx.get(nodesCtx).findIndex(ns => ns[0] === id) !== -1,\n    )\n    const markViews = Object.entries(view).filter(\n      ([id]) => ctx.get(marksCtx).findIndex(ns => ns[0] === id) !== -1,\n    )\n    ctx.update(nodeViewCtx, v => [...v, ...(nodeViews as [string, NodeViewConstructor][])])\n    ctx.update(markViewCtx, v => [...v, ...(markViews as [string, MarkViewConstructor][])])\n\n    onCleanup(() => {\n      ctx.update(nodeViewCtx, v => v.filter(x => !nodeViews.includes(x)))\n      ctx.update(markViewCtx, v => v.filter(x => !markViews.includes(x)))\n    })\n  }\n\n  await next()\n}\n\nexport const idPipeCtx = createSlice('', 'idPipeCtx')\n\nexport const injectPipeEnv: Pipeline = async (env, next) => {\n  const { pipelineCtx } = env\n  pipelineCtx\n    .inject(idPipeCtx)\n    .inject(optionsPipeCtx)\n    .inject(injectSlicesPipeCtx)\n    .inject(getRemarkPluginsPipeCtx)\n    .inject(getSchemaPipeCtx)\n    .inject(typePipeCtx)\n    .inject(getCommandsPipeCtx)\n    .inject(getInputRulesPipeCtx)\n    .inject(shortcutsPipeCtx)\n    .inject(getProsePluginsPipeCtx)\n    .inject(getViewPipeCtx)\n\n  await next()\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Cleanup, Ctx, Post, Pre } from '@milkdown/core'\nimport { Env, createClock, createContainer } from '@milkdown/core'\n\nexport interface PipelineEnv {\n  readonly pre: Pre\n  readonly ctx: Ctx\n  readonly pipelineCtx: Env\n  readonly onCleanup: (cleanup: Cleanup) => void\n}\n\nexport type Pipeline = (env: PipelineEnv, next: () => Promise<void>) => Promise<void>\n\nconst runPipeline = (pipelines: Pipeline[]) => {\n  return (env: PipelineEnv, next?: Pipeline): Promise<void> => {\n    let index = -1\n    const dispatch = (i: number): Promise<void> => {\n      if (i <= index)\n        return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = pipelines[i]\n      if (i === pipelines.length)\n        fn = next\n      if (!fn)\n        return Promise.resolve()\n      try {\n        return Promise.resolve(fn(env, () => dispatch(i + 1)))\n      }\n      catch (err) {\n        return Promise.reject(err)\n      }\n    }\n    return dispatch(0)\n  }\n}\n\nexport const run = (pipelines: Pipeline[]) => {\n  const runner = runPipeline(pipelines)\n  const container = createContainer()\n  const clock = createClock()\n\n  const cleanupSet = new Set<Cleanup>()\n\n  const pipelineCtx = new Env(container, clock)\n\n  const onCleanup = (cleanup: Cleanup) => {\n    cleanupSet.add(cleanup)\n  }\n\n  const runCleanup = async (post: Post) => {\n    await Promise.all(\n      [...cleanupSet].map((cleanup) => {\n        return cleanup(post)\n      }),\n    )\n  }\n\n  const main = (pre: Pre, ctx: Ctx) =>\n    runner({\n      pre,\n      ctx,\n      pipelineCtx,\n      onCleanup,\n    })\n\n  main.runCleanup = runCleanup\n\n  return main\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MarkSchema, MilkdownPlugin } from '@milkdown/core'\nimport type { MarkType } from '@milkdown/prose/model'\nimport type { MarkViewConstructor } from '@milkdown/prose/view'\n\nimport { pipe } from '../pipe'\nimport type { CommonOptions, Factory, WithExtend } from '../types'\nimport { addMetadata, getThemeUtils, withExtend } from './common'\nimport {\n  applyProsePlugins,\n  applyRemarkPlugins,\n  applySchema,\n  applyView,\n  createCommands,\n  createInputRules,\n  createShortcuts,\n  getCommandsPipeCtx,\n  getInputRulesPipeCtx,\n  getProsePluginsPipeCtx,\n  getRemarkPluginsPipeCtx,\n  getSchemaPipeCtx,\n  getViewPipeCtx,\n  idPipeCtx,\n  injectPipeEnv,\n  injectSlices,\n  injectSlicesPipeCtx,\n  optionsPipeCtx,\n  shortcutsPipeCtx,\n  waitThemeReady,\n} from './pieces'\nimport type { Pipeline } from './pipeline'\nimport { run } from './pipeline'\n\nexport interface MarkRest {\n  id: string\n  schema: (ctx: Ctx) => MarkSchema\n  view?: (ctx: Ctx) => MarkViewConstructor\n}\n\nexport type MarkFactory<SupportedKeys extends string, Options extends {}> = Factory<\n    SupportedKeys,\n    Options,\n    MarkType,\n    MarkRest\n>\n\nexport type MarkCreator<SupportedKeys extends string, Options extends {}> = WithExtend<\n    SupportedKeys,\n    Options,\n    MarkType,\n    MarkRest\n>\n\nexport const createMark = <SupportedKeys extends string = string, Options extends {} = {}>(\n  factory: MarkFactory<SupportedKeys, Options>,\n): MarkCreator<string, Options> =>\n    pipe(\n      addMetadata,\n      withExtend(factory, createMark),\n    )(\n      (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n        pre =>\n          async (ctx) => {\n            const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n              const utils = getThemeUtils(ctx, options)\n              const plugin = factory(utils, options)\n\n              const {\n                id,\n                commands,\n                remarkPlugins,\n                schema,\n                inputRules,\n                shortcuts,\n                prosePlugins,\n                view,\n                injectSlices,\n              } = plugin\n\n              const viewOption = options?.view\n              const injectOptions = injectSlices ?? []\n\n              const pluginOptions = {\n                ...(options || {}),\n                view: viewOption ? (ctx: Ctx) => ({ [id]: viewOption(ctx) }) : undefined,\n              }\n\n              pipelineCtx.set(injectSlicesPipeCtx, injectOptions)\n              pipelineCtx.set(idPipeCtx, id)\n              pipelineCtx.set(optionsPipeCtx, pluginOptions)\n              pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins)\n              pipelineCtx.set(getSchemaPipeCtx, ctx => ({ mark: { [id]: schema(ctx) } }))\n              if (commands)\n                pipelineCtx.set(getCommandsPipeCtx, (type, ctx) => commands(type[id] as MarkType, ctx))\n\n              if (inputRules)\n                pipelineCtx.set(getInputRulesPipeCtx, (type, ctx) => inputRules(type[id] as MarkType, ctx))\n\n              if (shortcuts)\n                pipelineCtx.set(shortcutsPipeCtx, shortcuts)\n\n              if (prosePlugins)\n                pipelineCtx.set(getProsePluginsPipeCtx, (type, ctx) => prosePlugins(type[id] as MarkType, ctx))\n\n              if (view)\n                pipelineCtx.set(getViewPipeCtx, ctx => ({ [id]: view(ctx) }))\n\n              await next()\n            }\n\n            const runner = run([\n              injectPipeEnv,\n              waitThemeReady,\n              setPipelineEnv,\n              injectSlices,\n              applyRemarkPlugins,\n              applySchema,\n              createCommands,\n              createInputRules,\n              createShortcuts,\n              applyProsePlugins,\n              applyView,\n            ])\n\n            await runner(pre, ctx)\n\n            return runner.runCleanup\n          },\n    )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MilkdownPlugin, NodeSchema } from '@milkdown/core'\nimport type { NodeType } from '@milkdown/prose/model'\nimport type { NodeViewConstructor } from '@milkdown/prose/view'\n\nimport { pipe } from '../pipe'\nimport type { CommonOptions, Factory, WithExtend } from '../types'\nimport { addMetadata, getThemeUtils, withExtend } from './common'\nimport {\n  applyProsePlugins,\n  applyRemarkPlugins,\n  applySchema,\n  applyView,\n  createCommands,\n  createInputRules,\n  createShortcuts,\n  getCommandsPipeCtx,\n  getInputRulesPipeCtx,\n  getProsePluginsPipeCtx,\n  getRemarkPluginsPipeCtx,\n  getSchemaPipeCtx,\n  getViewPipeCtx,\n  idPipeCtx,\n  injectPipeEnv,\n  injectSlices,\n  injectSlicesPipeCtx,\n  optionsPipeCtx,\n  shortcutsPipeCtx,\n  waitThemeReady,\n} from './pieces'\nimport type { Pipeline } from './pipeline'\nimport { run } from './pipeline'\n\nexport interface NodeRest {\n  id: string\n  schema: (ctx: Ctx) => NodeSchema\n  view?: (ctx: Ctx) => NodeViewConstructor\n}\n\nexport type NodeFactory<SupportedKeys extends string, Options extends {}> = Factory<\n    SupportedKeys,\n    Options,\n    NodeType,\n    NodeRest\n>\n\nexport type NodeCreator<\n    SupportedKeys extends string = string,\n    Options extends {} = {},\n> = WithExtend<SupportedKeys, Options, NodeType, NodeRest>\n\nexport const createNode = <SupportedKeys extends string = string, Options extends {} = {}>(\n  factory: NodeFactory<SupportedKeys, Options>,\n): NodeCreator<SupportedKeys, Options> =>\n    pipe(\n      addMetadata,\n      withExtend(factory, createNode),\n    )(\n      (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n        pre =>\n          async (ctx) => {\n            const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n              const utils = getThemeUtils(ctx, options)\n              const plugin = factory(utils, options)\n\n              const {\n                id,\n                commands,\n                remarkPlugins,\n                schema,\n                inputRules,\n                shortcuts,\n                prosePlugins,\n                view,\n                injectSlices,\n              } = plugin\n\n              const viewOption = options?.view\n              const injectOptions = injectSlices ?? []\n\n              const pluginOptions = {\n                ...(options || {}),\n                view: viewOption ? (ctx: Ctx) => ({ [id]: viewOption(ctx) }) : undefined,\n              }\n\n              pipelineCtx.set(injectSlicesPipeCtx, injectOptions)\n              pipelineCtx.set(idPipeCtx, id)\n              pipelineCtx.set(optionsPipeCtx, pluginOptions)\n              pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins)\n              pipelineCtx.set(getSchemaPipeCtx, ctx => ({ node: { [id]: schema(ctx) } }))\n              if (commands)\n                pipelineCtx.set(getCommandsPipeCtx, (type, ctx) => commands(type[id] as NodeType, ctx))\n\n              if (inputRules)\n                pipelineCtx.set(getInputRulesPipeCtx, (type, ctx) => inputRules(type[id] as NodeType, ctx))\n\n              if (shortcuts)\n                pipelineCtx.set(shortcutsPipeCtx, shortcuts)\n\n              if (prosePlugins)\n                pipelineCtx.set(getProsePluginsPipeCtx, (type, ctx) => prosePlugins(type[id] as NodeType, ctx))\n\n              if (view)\n                pipelineCtx.set(getViewPipeCtx, ctx => ({ [id]: view(ctx) }))\n\n              await next()\n            }\n\n            const runner = run([\n              injectPipeEnv,\n              waitThemeReady,\n              setPipelineEnv,\n              injectSlices,\n              applyRemarkPlugins,\n              applySchema,\n              createCommands,\n              createInputRules,\n              createShortcuts,\n              applyProsePlugins,\n              applyView,\n            ])\n\n            await runner(pre, ctx)\n\n            return runner.runCleanup\n          },\n    )\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Ctx, MarkSchema, MilkdownPlugin, NodeSchema } from '@milkdown/core'\nimport type { MarkType, NodeType } from '@milkdown/prose/model'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@milkdown/prose/view'\n\nimport { pipe } from '../pipe'\nimport type { CommonOptions, Factory, WithExtend } from '../types'\nimport { addMetadata, getThemeUtils, withExtend } from './common'\nimport {\n  applyProsePlugins,\n  applyRemarkPlugins,\n  applySchema,\n  applyView,\n  createCommands,\n  createInputRules,\n  createShortcuts,\n  getCommandsPipeCtx,\n  getInputRulesPipeCtx,\n  getProsePluginsPipeCtx,\n  getRemarkPluginsPipeCtx,\n  getSchemaPipeCtx,\n  getViewPipeCtx,\n  injectPipeEnv,\n  injectSlices,\n  injectSlicesPipeCtx,\n  optionsPipeCtx,\n  shortcutsPipeCtx,\n  waitThemeReady,\n} from './pieces'\nimport type { Pipeline } from './pipeline'\nimport { run } from './pipeline'\n\nexport type TypeMapping<NodeKeys extends string, MarkKeys extends string> = {\n  [K in NodeKeys]: NodeType;\n} & {\n  [K in MarkKeys]: MarkType;\n}\n\nexport type ViewMapping<NodeKeys extends string, MarkKeys extends string> = {\n  [K in NodeKeys]: NodeViewConstructor;\n} & {\n  [K in MarkKeys]: MarkViewConstructor;\n}\n\nexport interface PluginRest<NodeKeys extends string, MarkKeys extends string> {\n  schema?: (ctx: Ctx) => {\n    node?: Record<NodeKeys, NodeSchema>\n    mark?: Record<MarkKeys, MarkSchema>\n  }\n  view?: (ctx: Ctx) => Partial<ViewMapping<NodeKeys, MarkKeys>>\n}\nexport type PluginFactory<\n    SupportedKeys extends string = string,\n    Options extends {} = {},\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n> = Factory<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>>\n\nexport const createPlugin = <\n    SupportedKeys extends string = string,\n    Options extends {} = {},\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n>(\n    factory: PluginFactory<SupportedKeys, Options, NodeKeys, MarkKeys>,\n  ): WithExtend<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>> =>\n    pipe(\n      addMetadata,\n      withExtend(factory, createPlugin),\n    )(\n      (options?: Partial<CommonOptions<SupportedKeys, Options>>): MilkdownPlugin =>\n        pre =>\n          async (ctx) => {\n            const setPipelineEnv: Pipeline = async ({ pipelineCtx }, next) => {\n              const utils = getThemeUtils(ctx, options)\n              const plugin = factory(utils, options)\n\n              const { commands, remarkPlugins, schema, inputRules, shortcuts, prosePlugins, view, injectSlices }\n                        = plugin\n\n              const injectOptions = injectSlices ?? []\n\n              pipelineCtx.set(injectSlicesPipeCtx, injectOptions)\n              pipelineCtx.set(optionsPipeCtx, (options || {}) as Options)\n              pipelineCtx.set(getRemarkPluginsPipeCtx, remarkPlugins)\n              if (schema)\n                pipelineCtx.set(getSchemaPipeCtx, schema)\n\n              if (commands)\n                pipelineCtx.set(getCommandsPipeCtx, commands as never)\n\n              if (inputRules)\n                pipelineCtx.set(getInputRulesPipeCtx, inputRules as never)\n\n              if (shortcuts)\n                pipelineCtx.set(shortcutsPipeCtx, shortcuts)\n\n              if (prosePlugins)\n                pipelineCtx.set(getProsePluginsPipeCtx, prosePlugins as never)\n\n              if (view)\n                pipelineCtx.set(getViewPipeCtx, view as never)\n\n              await next()\n            }\n\n            const runner = run([\n              injectPipeEnv,\n              waitThemeReady,\n              setPipelineEnv,\n              injectSlices,\n              applyRemarkPlugins,\n              applySchema,\n              createCommands,\n              createInputRules,\n              createShortcuts,\n              applyProsePlugins,\n              applyView,\n            ])\n\n            await runner(pre, ctx)\n\n            return runner.runCleanup\n          },\n    )\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { CmdKey, Ctx } from '@milkdown/core'\nimport { commandsCtx } from '@milkdown/core'\n\ntype InferParams<T> = T extends CmdKey<infer U> ? U : never\n\nexport function callCommand<T extends CmdKey<any>>(slice: string, payload?: InferParams<T>): (ctx: Ctx) => boolean\nexport function callCommand<T>(slice: CmdKey<T>, payload?: T): (ctx: Ctx) => boolean\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean\nexport function callCommand(slice: string | CmdKey<any>, payload?: any): (ctx: Ctx) => boolean {\n  return (ctx: Ctx) => {\n    return ctx.get(commandsCtx).call(slice, payload)\n  }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorCtx } from '@milkdown/core'\n\n/**\n * @deprecated Use `editor.destroy()` instead.\n */\nexport const destroy = () => (ctx: Ctx) => ctx.get(editorCtx).destroy()\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx } from '@milkdown/core'\n\nexport const forceUpdate\n    = () =>\n      (ctx: Ctx): void => {\n        const view = ctx.get(editorViewCtx)\n        const { tr } = view.state\n\n        const nextTr = Object.assign(Object.create(tr), tr).setTime(Date.now())\n        return view.dispatch(nextTr)\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx, schemaCtx } from '@milkdown/core'\nimport { DOMSerializer } from '@milkdown/prose/model'\n\nexport const getHTML\n    = () =>\n      (ctx: Ctx): string => {\n        const div = document.createElement('div')\n        const schema = ctx.get(schemaCtx)\n        const view = ctx.get(editorViewCtx)\n        const fragment = DOMSerializer.fromSchema(schema).serializeFragment(view.state.doc.content)\n\n        div.appendChild(fragment)\n\n        return div.innerHTML\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx, serializerCtx } from '@milkdown/core'\n\nexport const getMarkdown\n    = () =>\n      (ctx: Ctx): string => {\n        const view = ctx.get(editorViewCtx)\n        const serializer = ctx.get(serializerCtx)\n\n        return serializer(view.state.doc)\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx, parserCtx } from '@milkdown/core'\nimport { Slice } from '@milkdown/prose/model'\n\nexport const insert = (markdown: string) => (ctx: Ctx) => {\n  const view = ctx.get(editorViewCtx)\n  const parser = ctx.get(parserCtx)\n  const doc = parser(markdown)\n  if (!doc)\n    return\n\n  const contentSlice = view.state.selection.content()\n  return view.dispatch(\n    view.state.tr\n      .replaceSelection(new Slice(doc.content, contentSlice.openStart, contentSlice.openEnd))\n      .scrollIntoView(),\n  )\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport { editorViewCtx } from '@milkdown/core'\n\nexport const outline\n    = () =>\n      (ctx: Ctx): Array<{ text: string; level: number; id: string }> => {\n        const view = ctx.get(editorViewCtx)\n        const data: { text: string; level: number; id: string }[] = []\n        const doc = view.state.doc\n        doc.descendants((node) => {\n          if (node.type.name === 'heading' && node.attrs.level)\n            data.push({ text: node.textContent, level: node.attrs.level, id: node.attrs.id })\n        })\n        return data\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx } from '@milkdown/core'\nimport {\n  editorStateOptionsCtx,\n  editorViewCtx,\n  parserCtx,\n  prosePluginsCtx,\n  schemaCtx,\n  themeManagerCtx,\n} from '@milkdown/core'\nimport { Slice } from '@milkdown/prose/model'\nimport { EditorState } from '@milkdown/prose/state'\n\nexport const replaceAll\n    = (markdown: string, flush = false) =>\n      (ctx: Ctx): void => {\n        const view = ctx.get(editorViewCtx)\n        const parser = ctx.get(parserCtx)\n        const doc = parser(markdown)\n        if (!doc)\n          return\n\n        if (!flush) {\n          const { state } = view\n          return view.dispatch(state.tr.replace(0, state.doc.content.size, new Slice(doc.content, 0, 0)))\n        }\n\n        const schema = ctx.get(schemaCtx)\n        const options = ctx.get(editorStateOptionsCtx)\n        const plugins = ctx.get(prosePluginsCtx)\n        const themeManager = ctx.get(themeManagerCtx)\n\n        const state = EditorState.create({\n          schema,\n          doc,\n          plugins,\n          ...options,\n        })\n\n        view.updateState(state)\n        themeManager.flush(ctx)\n      }\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport type { Attrs, Ctx } from '@milkdown/core'\nimport { editorViewCtx } from '@milkdown/core'\n\nexport const setAttr = (pos: number, update: (prevAttrs: Attrs) => Attrs) => (ctx: Ctx) => {\n  const view = ctx.get(editorViewCtx)\n  const { tr } = view.state\n  const node = tr.doc.nodeAt(pos)\n  if (!node)\n    return\n  const nextAttr = update(node.attrs)\n  return view.dispatch(tr.setNodeMarkup(pos, undefined, nextAttr))\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Ctx, ThemePlugin } from '@milkdown/core'\nimport { themeManagerCtx } from '@milkdown/core'\n\nexport const switchTheme = (theme: ThemePlugin) => (ctx: Ctx) => ctx.get(themeManagerCtx).switch(ctx, theme)\n"],"names":["hasMetadata","x","AtomList","target","callback","index","config","next","from","nanoid","customAlphabet","addTimer","runner","injectTo","timerName","timer","createTimer","doneCalled","plugin","ctx","done","$command","cmd","SchemaReady","key","command","commandsCtx","payload","$commandAsync","commandsTimerCtx","$inputRule","inputRule","ir","inputRulesCtx","irs","$inputRuleAsync","editorStateTimerCtx","$mark","id","schema","ThemeReady","markSchema","marksCtx","ns","markType","schemaCtx","missingMarkInSchema","$markAsync","schemaTimerCtx","$node","nodeSchema","nodesCtx","nodeType","missingNodeInSchema","$nodeAsync","$prose","prose","prosePlugin","prosePluginsCtx","ps","$proseAsync","$remark","remark","InitReady","re","remarkPluginsCtx","rp","$remarkAsync","$shortcut","shortcut","k","keymap","$shortcutAsync","$view","type","view","v","NodeType","nodeViewCtx","markViewCtx","$viewAsync","editorViewTimerCtx","getClassName","className","attrs","defaultValue","classList","_a","createShortcut","commandKey","defaultKey","args","getThemeUtils","options","themeManager","themeManagerCtx","emotion","emotionCtx","themeMustInstalled","style","getUtils","addMetadata","fn","result","withExtend","factory","creator","origin","extend","extendFactory","pipe","funcs","length","optionsPipeCtx","createSlice","injectSlicesPipeCtx","injectSlices","env","pipelineCtx","onCleanup","pre","inject","slice","post","waitThemeReady","getRemarkPluginsPipeCtx","applyRemarkPlugins","remarkPlugins","plugins","p","getSchemaPipeCtx","typePipeCtx","applySchema","getSchema","userSchema","node","mark","nodes","n","marks","ms","m","nodeTypes","markTypes","getCommandsPipeCtx","createCommands","commands","cs","getInputRulesPipeCtx","createInputRules","inputRules","rules","r","shortcutsPipeCtx","createShortcuts","shortcuts","getKey","_b","tuples","getProsePluginsPipeCtx","applyProsePlugins","prosePlugins","getViewPipeCtx","applyView","getView","nodeViews","markViews","idPipeCtx","injectPipeEnv","runPipeline","pipelines","dispatch","i","err","run","container","createContainer","clock","createClock","cleanupSet","Env","cleanup","runCleanup","main","createMark","utils","viewOption","injectOptions","pluginOptions","createNode","createPlugin","callCommand","destroy","editorCtx","forceUpdate","editorViewCtx","tr","nextTr","getHTML","div","fragment","DOMSerializer","getMarkdown","serializerCtx","insert","markdown","doc","parserCtx","contentSlice","Slice","outline","data","replaceAll","flush","state","editorStateOptionsCtx","EditorState","setAttr","pos","update","nextAttr","switchTheme","theme"],"mappings":"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"}